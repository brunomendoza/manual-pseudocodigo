Elementos básicos de programación (l).

El ordenador como máquina de proceso de información.

La informática es el conjunto de conocimientos cientiﬁcos y técnicos que se ocupam
del tratamiento de la infomiación por medio de ordenadores. Un ordenador cs una máquina
para procesar información, elaborándola y transformándola. Una máquina de proceso consta
de: una entrada por donde se introduce la materia prima, una unidad de proceso donde se
realiza el proceso propiamente dicho, y una salida por donde se obtienen los productos
elaborados. En un ordenador los dispositivos de entrada típicos son el teclado y el ratón. la
salida se realiza habitualmente a través de un monitor de vídeo, y el proceso se lleva a cabo
en la unidad central de proceso, que aloja el procesador junto con dispositivos para la

representación y almacenamiento de infonnación y otros elementos de control.

Disms os de salida






Impresora

’ " Unidad de Proceso
l nidades de

al macenamiento




ÉFIoppy dnvcr (FD)

Hard DIsku-ID]

ﬁ Procesador



Dism de entrada emo

n Controladores
de dismsitivos

Ilustración I Partes de un ordenador

Un proceso es un conjunto de acciones que se realizan para conseguir un resultado. El
ente activo encargado de llevar a cabo estas acciones es el procesador. En un ordenador el

procesador es un circuito electrónico capaz de reaccionar a detenninados conjuntos de

estímulos electricos que se identiﬁcan como instrucciones —para ejecutar ncciones- o
como datos —que componen la información en proceso.

Para que un procesador pueda realizar un detenninado proceso —necesario para la
resolución de un problema—— hace falta programas-lo. Un programa informático deﬁne la
representación de los datos que integran tanto la información a procesar como los resultados
esperados (estructuras de datos), y describe la secuencia de acciones (algoritmo) que, en
función de los datos de entrada, se deben ejecutar para obtener la solución buscada.

El conjunto de dispositivos ﬁsicos que conforman un ordenador se denomina
hardware; el conjunto de programas que hacen funcionar esos dispositivos de forma

adecuada recibe el nombre de software. ' '-

El desarrollo de un programa comprende tres fases principales: (l) álisis y dise}o,)

en la que se estudia el problema y se eligen las estructuras de datos y los algoritmos para
resolverlo, (Zlcodiﬁcación y depuraeiﬁnfen la que se escribe el programa y se corrigen los
errores que puedan aparecer y (3) igmtenimiento) en la que se realizan actualizaciones y

correcciones de problemas detectados durante el uso del programa.

Lrrueunuár’ l

7 if" {Tel v

_ Programa esaïiïpor el " p ’ ’
cano: de ‘ y , ____ Iograma ejecutable
o  e 1335233.932: 3a.. _ >  i >Lev wwe

ñ o  l‘

Inlemcnin

EJccma
l
V



l Pmgííníndar l

Ilustración 2 Codiﬁcación de un programa

Un programa se escribe utilizando un lenguaje que el procesador encargado de
ejecutarlo comprenda. En realidad, un procesador infon-nático sólo comprende un lenguaje de
ceros y unos (lenguaje máquina) que representa los impulsos eléctricos a los que responde.

Dado que para un programador humano resulta muy diﬁcil componer aplicaciones con un
2

lenguaje tan falto de abstracción, se han desarrollado lenguajes de programación de "alto
nivel" que utilizan simbolos, palabras y reglas de composición más próximos a un lenguaje
natural humano, aunque muy simpliﬁcado y sin las ambigüedades de este. El programa
escrito en un lenguaje de alto nivel es traducido a lenguaje máquina por otro programa —un
compilador o un intérprete—, a ﬁn de que el procesador pueda ejecutarlo; pero el efecto es
que el programador escribe su programa como si existiese un procesador virtual capaz de
entender el lenguaje de alto nivel.

Muchas veces se suelen escribir algoritmos generales utilizando un pseudolenguaje,
el cual suele parecerse a un lenguaje de programación, pero pennitiendo algunas libertades
que faciliten la descripción del algoritmo sin preocuparse de algunos detalles sintácticos que

se tendrán que concretar al trasladarlo a un auténtico lenguaje de programación.

Concepto de algoritmo.

La palabra algoritmo deriva del nombre del matemático persa del siglo IX Mohammed
¡bn Musa aLKhowárizmí, autor de un libro sobre como operar con el sistema decimal de
numeración originario de la India, libro que, tras ser traducido al latín, fue origen de la
adopción de este sistema en Europa. La característica más relevante de las operaciones
descritas (suma, resta, multiplicación y división) es que se pueden realizar de forma
mecánica: basta con seguir los pasos indicados para obtener una solución correcta sin
necesidad de ningún conocimiento teórico adicional.

La ENCICLOPEDIA DE CIENCIAS DE LA COMPUTACIÓN‘ deﬁne cl término en función de un
problema y un dispositivo que se va a usar para solucionarlo: un algoritmo es una
descripción _pr_ecisa de un metodo para solucionar el problema escrito en un lenguaje
comprensible para el dispositivo que debe cumplir las siguientes propiedades:

l. al aplicarlo a un caso concreto del problema, da lugar a la ejecución dc_una secuencia

ﬁnita de acciones,

2. dicha secuencia tiene una única acción inicial,
3. cada acción en la secuencia tiene una única sucesora, y
4. la secuencia termina en un tiempo ﬁnito encontrando una solución o determinando

que no existe una para ese caso panicular.

‘ENCYCLOPEDIA OF COMPUTER SCIENCE. lEEE Press. New York, 1993. ISBN 0-442-27679-6
3



g mglo: algoritmo de resolución de gcuaclones do «mudo grado
identiﬁcar los coeﬁcientes: a, b, c

2. calcular bz

3. calcular 4ac

4. restar bz - 4ac

5. calcular la raiz cuadrada de] resultado anterior

6. sumar -b al resultado anterior

7. calcular 2a

8. dividir el resultado del paso 6 por el resultado del paso 7 para obtener la l‘ solución
9. restar el resultado del paso S a -b

10. dividir el resultado anterior por el resultado del paso 7 para obtener la 2“ solución

Nótese que en la deﬁnición de algoritmo no se hace ninguna suposición acerca de la
naturaleza del problema ni del dispositivo que se va a usar para resolverlo. Son validos
cualquier clase de proceso y cualquier dispositivo (incluyendo un ser humano) capaz de

ejecutarlo.

Fiemglo: algoritmo gara poner en marcha un coche
‘l. poner el coche en punto muerto

«2. pisar el embrague

‘S. llevar la palanca de cambios al punto muerto
‘4. introducir la llave en el contacto

girar la llave hasta el punto de arranque

‘S. soltar la llave

‘7. poner primera

8. pisar el embrague

‘Q. llevar la palanca de cambios a la posición de la primera marcha

‘lo. poner las manos en el volante J

l l . acelerar suavemente al mismo tiempo que se suelta el embrague

Un algoritmo describe un método determinista: ante las mismas entradas se generará
la misma secuencia de acciones, que conducirán al mismo resultado de la misma manera.
Podríamos decir que un algoritmo establece una aplicación entre el espacio de casos solubles
de un problema y el espacio de soluciones del mismo, de tal manera que, a cada caso del

problema le hace corresponder una solución.





 —É t"



Espacio a.

deﬁnición del solucione:
Problem: delPrnhlemI

Ilustración 3 Elementos que interactúan en la solución de problemas

En resumen, las dos caracteristicas esenciales de un algoritmo son: tinitud «siempre
acaba proporcionando una solución o detenninando que no existe ninguna- y el
determinismo —siempre produce los mismos resultados para los mismos datos.

Para poder formular una algoritmo que solucione un problema, éste debe estar
especiﬁcado con claridad; si, por ejemplo, planteamos el enunciado: "calcular la raiz
cuadrada de un número real, x", no podremos encontrar ningún algoritmo que lo satisfaga
dado que la raiz cuadrada de un número real cualquiera tiene, en general, inﬁnitos decimales,
por lo que no es posible calcularla con un número ﬁnito de acciones.

Si restringimos el problema y pedimos, por ejemplo: "calcular la raiz cuadrada
positiva de un número real, x, con una precisión de cuatro decimales", ya será posible
proponer un algoritmo, puesto que hemos introducido una condición (la limitación de la
precisión) que permite alcanzar un resultado con un número ﬁnito de pasos; además se ha

precisado otro matiz, que estaba ambiguo, al indicar que queremos la raíz positiva.





 3 u,“ :

u t"

v
No obstante, no todas las soluciones que propongamos constituirán un algoritmo, Por

ejemplo:



l elegir un número, y, y calcular y?’ ‘

si |yz  < 5 * l0'5 la solución es y, terminar; si no repetir desde el paso l



zm}
do de elección de los sucesivos valores de

//" 7

no es un algoritmo, ya que no se establece el m
y, lo que impide garantizar que el proceso tennina. Podemos utilizar otro método; el‘ siguiente

es conocido como método delNewton-Raphsonzl

l ísleay=xl2ii Q I‘

4. Á _ ¿,1 _., /, 1,,’ , ,4 _,»



calcular yz
h si |y2 - x | <5 * l0'5 la solución es y, terminar; si no hacer el paso 4
recalcular y como «x/y) + yﬂiïty repetir desde el paso 2
./Í/ » . «, Ju}.

Este método produce una solución adecuada siempre que el número x sea positivo
dado que, para cualquier y, la raiz cuadrada de x está comprendida entre ¿gy e i, si y es mayor
que x/y, o entre y y x/y, si y es menor que x/y. La fórmula de recálculo de y —((x/y) + y)/2—
hace que el valor de y converja al valor de la raiz cuadrada de x.

Cuando x es negativo se repiten indeﬁnidamente los pasos 2 al 4, lo que muestra que
esto en realidad es un semialgorítmo, ya que hay estados iniciales para los que no termina ni

hallando una solución, ni concluyendo que la misma no existe. Podemos añadir un paso

previo:

1 si x < 0, no hay solución, terminar

2 sea y = x/Z

3 calcular yz

4 si if - x | < 5 * 10's la solución es y, terminar; si no, hacer el paso 4
5 recalcular y como ((x/y) + y)/2 y repetir desde el paso 2

y tendriamos un algoritmo escrito en un lenguaje adecuado para un procesador humano con

unas mínimas nociones de matemáticas. Si el procesador previsto es un ordenador habria que

6

ﬁ? ,24’  V 4 _ ¿//- l, ‘ //r7¡’l

rcescribirlo en un lenguaje de programación, donde tendría un aspecto similar al que se

muestra en la siguiente pagina, escrito en pseudolenguaje.

algoritmo Raízcuadrada
variables reales X, Y, Z
escribir "Desea Calcular la raíz cuadrada de:
leer X ‘
si X > 0 entonces ' V.  N. h?‘
‘l e x / 2 i ‘ ,r 4; 9
Z e y a y , ,« ,
mientras abs(X - z) >= 0.00005 hace: - h,  , r
‘lv (Kx/Y) +3!) /2
z e ‘l * Y
fin mientras
escribir "La raíz cuadrada es: ", Y M. ,—, .. al . 5.a, ,
si no ïxvïzw n. u. n‘. . ¿t
escribir "no existe una raíz cuadrada real de", x '
tin ei
parar
Ein algoritmo




Todo programa informático es como mínimo un semialgoritmo; gn programa que
siempre termina es un algoritmo. y un algoritmo es correcto si hace lo que se supone que
debe hacer, es decir si cuando se le proporcionan datos adecuados proporciona resultados
correctos según la especiﬁcación del problema para el que ha sido diseñado. Para resolver un
mismo problema pueden existir varios algoritmos diferentes; la elección de uno u otro
dependerá de su eﬁciencia en términos de tiempo y recursos que consuma.

[.21 algorítmica, como disciplina que se ocupa del estudio de los algoritmos y de las
metodologías para desarrollarlos comprende tres facetas‘ cómo construir algoritmos (diseño),

cómo determinar si un algoritmo es correcto (víerjﬁcación) y como medir la eﬁciencia de los

algoritmos (análisis).

Variables, constantes y expresiones.

Variables.

Cuando se escribe un algoritmo se utilizan símbolos para representar los elementos de
información que intervienen en el proceso especm por él. Esto es similar a lo que se
hace al describir una función matemática, por ejemplo, en:

f(x,y) = 3x2 + 5y



x e y son variables, simbolos que se utilizan como comodines para poder expresar la fonna

general de la función. Los valores concretos de f se obtienen dando valores a x e y:

ttl,1)= a
f(l,2)= ¡3
r(1,3) = 18
r(2,1)=17
r(2,2)=22
r(2,3)=27

Sin embargo, mientras una función matemática expresa una correspondencia entre dos
conjuntos de valores (o de un conjunto consigo mismo), un programa informático describe un
proceso de transformación de información; esto signiﬁca que los elementos de infonnación
representados por las variables pueden cambiar a lo largo del proceso, pasando a representar
un valor distinto del original. Por ejemplo, en el algoritmo RaízCuadrada, que usa tres
variables —X, Y, Z—, las variables Y y Z empiezan teniendo un valor dependiente de lo que
valga X y luego van cambiando a lo largo del proceso; supongamos que X toma inicialmente

el valor 9. La siguiente tabla muestra la evolución de los valores de las variables implicadas

en el proceso mientras el mismo se ejecuta.

Iteración X Y Z

0 9,0 4,5 20.25

l 9,0 3,25 10,5625
2 ' 9,0 3,0096 l 5 9,057785
3 9,0 3,000015 9,000092
4 9,0 3,0 9,0

La tabla muestra la traza de la ejecución del algoritmo RaizCuadrada. La traza

flm Ii‘ Íﬁ
visua a__la evolucion del estado de un proceso —entendido como el conjunto de valores de

las variables implicadas- a medida que se ejecuta el algoritmo que lo dirige, a panir de unas



entradas iniciales dadas. Se entiende por iteración ccglagia de l
8

as veces que se repite un

.ngnnnnnnnnnnnnnnndQ0ﬂﬁnﬁfihflﬂﬁhﬁﬂﬂﬂﬁﬁﬁﬁFÜQWÜÍÏÜPÑFPPPPÍ

bucle. Puede ser una herramienta útil en la localización de errores en un algoritmo, aunque en
ningún caso sirve para probar su correcto funcionamiento, ya que este sólo queda probado
para las entradas utilizadas.
Otra diferencia formal entre las variables usadas en matemáticas y las de un algoritmo"
informático es que para las primeras suele usarse una letra como identiﬁcador, mientras que
r las segundas suíelen tener unrnorïltíreí más largo. que se recomienda sea signiﬁcativo, y que
en la mayoría de los lenguajes se forma como una sola palabra empezando con una letra y
continuando con una combinación de letras, números y unos pocos caracteres especiales.
Además, las variables de un programa no son sólo un simbolo abstracto, identiﬁcan la
porción del hardware del ordenador utilizada para representar el valor de la información
simbolizada por la variable. El dispositivo hardware implicado es la QCJIGLÍB, un conjunto
de circuitos organizados desde el punto de vista lógico como una secuencia de celdas

direccionables individualmente. El valor de una variable se almacena utilizando una o más



“‘ . celdas consecutivas, y es accedido a partir de la geccióg de la primera Auna dirección es



una combinación de impulsos electricos capaz de "activar" la respuesta de una celda

individual. El espa (numero de celdas) utilizado por una variable es ﬁmción del tipo de



información que represente. Como el número de celdas de memoria es necesariamente ﬁnito,
el volumen total de infonnación que puede manejar un programa es limitado, lo que hace
necesario un uso racional de la memoria que evite ocupación innecesaria de espacio mediante

una adecuada deﬁnición y estructuración de los datos.

Declaración de variables.
Las variables utilizadas por un algoritmo deben declararse antes de su empleo. Una
declaración especiﬁca cuántas variables van a usarse. cómo se llaman y de que tipo es la

información que simbolizan.

variables reales X, Y, Z
enteras I, J

La declaración cumple un doble propósito: para el lector, informa de los elementos
simbólicos que va a utilizar el algoritmo; para el ordenador, determina cuánta memoria

necesitará el algoritmo para ejecutarse y cómo debe organizarse la misma.

Operacion es elementales.

Las variables son los envases para la materia prima con la que trabajan los algoritmos
informáticos. La acción descrita por un algoritmo gira en tomo ala atribución y modiﬁcación
de valores a las variables. Existen operaciones para incorporar información al proceso en
curso; esta infonnación es tomada "del exterior" y almacenada en una variable. De la misma
manera existen operaciones para enviar "al exterior" la infonnación resultante del proceso.
Estas operaciones se conocen como operaciones de entrada/salida.

algoritmo Raízcuadrada

escribir "Desea Calcular la raíz cuadrada de: "
leer X
si

escribir "La raíz cuadrada es: ", Y
si no

escribir "no existe una raiz cuadrada real de", X
Ein ai
parar
fin algoritmo

La operación que permite cambiar el valor de las variables cuando sea preciso a lo
largo del proceso se conoce como asignación y en pseudolenguaje suele simbolizarse con
una ﬂecha. En la asignación intervienen dos elementos: una variable a la que se le va a dar un
nuevo valor, y un valor que se le va a dar a la variable. Caso de utilizarse una ﬂecha como
símbolo de asignación ésta señalará desde el valor (normalmente situado a la derecha) hacia

la variable (normalmente situada a la izquierda).

algoritmo Raízcuadrada
si...
Y**X/2
Z<’Y*Y
mientras .
Y+l(X/Y)+Y)/2
Z**Y*‘l
fínmiantraa
ﬁin si
parar
tin algoritmo

C unstantes.

No toda la información que se utiliza en un algoritmo necesita almacenarse en
variables; en la implementación del método de Newtonjiaphson hemos empleado los
valores 0.00005 y 2 como constantes numéricas y los valores "Desea calcular la raiz cuadrada
de: ", "La raíz cuadrada es: " y "no existe una raíz cuadrada real de" como mensajes.
Representan valores literales que el algoritmo emplea en los puntos donde aparecen.

Existen ocasiones en las que conviene utilizar constantes simbólicas en vez de
literales. Por ejemplo, si en un algoritmo necesitamos utilizar el número n podemos

asimilarlo al valor 31416 y utilizarlo cuantas veces haga falta:

algoritmo Redondo
vnriable real Radio

escribir "Deme el radio: "

leer Radio

escribir "Círculo: ", 3.1416*Radio*Radio

escribir "Circunferencia: ", 2*3.l416*Radio

escribir "Volumen esférico: ", (4/3)*3Jálñﬂïadicﬂïadiwﬂïadío

para:
fin algoritmo

Sin embargo, si decidimos en otro momento modiﬁcar la precisión del método
utilizando como valor de n 1141592653590 tendriamos que cambiar el valor literal en todos
los sitios donde aparezca, cosa que no tendriamos que hacer si simplemente pudiéramos
deﬁnir un simbolo con ese valor y utilizar ese simbolo donde hiciese falta, de forma que para

cambiarla precisión del algoritmo sólo sería necesariocambiar la deﬁnición del símbolo.

algoritmo Redondo
constante real p 3.14159265359
Variable real Radio

algoritmo Redondo
cen-tanta real pi=3.1416
variable real Radio

escribir "Deme el radio: " escribir "Deme el radio: "

leer Radio leer Radio

escribir "Círculo: ", escribir "Círculo: ",
piﬂladicﬂíadío piﬁïadioﬂïadio

escribir "circunferencia: ", escribir "circunferencia: ",
2"pi*Radio 2*pi*Radio

escribir "Volumen esférico: ", escribir "Volumen esférico: ",
(4/3) ‘piﬂïadioﬂïadioﬂladio (4/3) svpiwxadionzadio-xadio

para: parar

fin algoritmo Ein algoritmo

Una constante simbólica es formalmente como una variable con la restricción de que
no se puede cambiar su valor —por tanto no aparecerá nunca en una operación de entrada, ni

como destino de una asignación.

Expresiones.

Una expresión es un conjunto de operandos ligados emite’ si por ¡operadores que
representa un gg Un operando puede ser un valor, una constante simbólica, una variable o
una función. El valor de la expresión se calcula como el resultado de aplicar los operadores
sobre los operandos en el orden adecuado. Una expresión se dice que es del tipo del valor que
devuelve. Los operadores aplicables dependen del tipo de los operandos

x +3/ l 8

El orden de gadigción dependeícïaí reglas deprecedencia entre los operadores —

un producto o una división habitualmente se deben evaluar antes que una suma o una resta.

Los operadores de irguï precedencia seeyalúanísegnin las reglas de asociatividad del

lenguagnognalmente dgigguierdajgereeha (un ejemplo de operador con asocíatividad de
derecha a izquierda es la exponenciaeión: x"3”2 s x”(3”2)). El orden de evaluación puede

modiﬁcarse mediante el uso de paréntesis:
(x +3)/l s

Tipos de datos.

El tipo es una de las caracteristicas más relevantes de los datos. Es fácilmente
constatable que en el mundo real existen diversas clases de información, tanto por su formato
(numérica, textual, gráﬂcaw), como por su signiﬁcado (volúmenes, masas, velocidades,
sueldos, notas...) En programación, el tipo está relacionado con la clase de infonnación que
se quiere manejar y determina una representación, un rango de valores —que depende de la
representación- y un conjunto de operaciones aplicables a esos valores. Aunque estas tres
características son especiﬁcas de cada tipo, es normal en la mayoría de los lenguajes que se
pennita algún grado de compatibilidad entre algunos tipos concretos: Un tipo, TI, es

compatible con otro, T2, si en cualquier lugar de un programa donde se espera que aparezca

l2

LDHIQQQQGQHGQIIﬁQmQnQlQa-nnn-nonnonnnn-nq-mnninnnnnnn
n...

un valor de tipo T2 se puede usar en su lugar uno de tipo T1; para ello el lenguaje debe
disponer de alguna regla de conversión automática que haga corresponder valores de tipo T1
a valores de tipo T2. Dos tipos son equivalentes cuando son mutuamente compatibles.

La ﬂexibilidad de los lengiajes de programación modemos pasa por ofrecer un
conjunto pequeño de tipos primitivos muy básicos junto con potentes mecanismos para que el
programador pueda deﬁnir nuevos tipos a partir de ellos y de los ya deﬁnidos. Normalmente
existe un conjunto de tipos no primitivos ya predeﬁnidos, por ser de amplia aplicación. Por
tanto, se puede establecer la distinción entre tipos predeﬁnidos —que pueden ser primitivos o
derivados— y tipos deﬁnidos por el programador —que siempre son derivados.

Además, los tipos pueden dividirse en simples y estructurados. Un tipo simple
representa una entidad individual, con un valor indivisible. Un tipo estructurado representa
una clase de entidad que está compuesta de partes identiﬁcables separadamente. En cada caso
se pueden establecer otras clasiﬁcaciones y subdívisiones, por ejemplo, entre los tipos
simples se puede distinguir entre ordinales o discretos y no ordinales. De los que se
presentan a continuación, son ordinales los tipo entero, carácter y, generalmente el lógico,

siendo no ordinal el real.

Tipos de datos primitivos.

Los tipos primitivos son tipos, generalmente simples, que no basan su representación
en ningún otro tipo, siendo normalmente provistos por el hardware. Se pueden enmarcar en
tres categorías: numéricos, lógicos y caracteres.

Debido a las fuertes diferencias en cuanto a su representación óptima en un ordenador,
los tipos numéricos se dividen en reales y enteros; ambos representan un subconjunto ﬁnito
de valores de sus correspondientes modelos matemáticos. En nuestros algoritmos llamaremos
real al tipo que representará números reales, y entero al que representará números enteros. En
los lenguajes de programación se suele tener la posibilidad de optimizar el gasto de memoria
distinguiendo, en función de las necesidades de representación. diversas "longitudes" de tipo
(enteros largos, nonnales, cortos...) lo que implica distintos rangos de valores. Los tipos
numéricos admiten:

- Los operadores aritméticos básicos: +. -. “, /.

- Los operadores relacionales: <, >, I, ,_, L, —aunque, por cuestiones de representación

13

que no vienen al caso, no suele tener mucho sentido comparar si dos números reales

son iguales o no.

- Diversas funciones matemáticas de uso común (Abs, Sen, Cos, Tag,...).

Habitualmente (salvo lenguajes con un tipado muy fuerte) los tipos enteros son
compatibles con los reales, es decir, en cualquier expresión podremos usar un valor entero
donde se espera un valor real. Lo contrario no es cierto, ya que un real puede ser convertido a
mas de un entero, con lo que dicha conversión no puede ser automática. En nuestro

pseudolengu ‘ utilizaremgslas función de conversión: ParteEntera, gue devuelve el valor



emszcaﬂsumeseonsïisnte a, ¡3,Pﬁﬂ3..°'!F°,T,a 69,91 nílmefo real PN 916m9“

ParteBntera(5.75) 5, ParteEnterat-Lﬂl) : -3

Los tipos lógicos son aquellos que representan dos valores (verdadero, falso), y
admiten como operaciones, al menos, la negación lógica, la disyunción lógica y la conjunción

lógica, cuyos signiﬁcados se muestran en la tabla.



 ) onjunc On logica (y A) V elisa
Falso Falso Falso Falso Falso Falso Falso Verdadero
Falso Verdadero Verdadero Falso Verdadero Falso Verdadero Falso
Verdadero Falso Verdadero Verdadero Falso Falso

Verdadero Verdadero Verdadero Verdadero Verdadero Verdadero

La importancia de los tipos lógicos reside en que se usan para controlar la ejecución
de los algoritmos, como veremos más adelante. Llamaremos Iégígjl tipo logico que
waregrgsïn asesina vseuddenzuaïe-

Los tipos carácter sirven para representar caracteres —el diccionario de la Real
Academia deﬁne carácter como "signo de escritura o de imprenta"—, incluyendo
generalmente todas las letras mayúsculas y minúsculas, los digitos del '0' al '9‘, signos de
puntuación, simbolos arítmeticos y otros símbolos especiales, dependiendo del alfabeto
utilizado —el más habitual es el American standard Qode for information Jnterchange (código

ASCII). gas únicas gpeﬁxLicme pggg; ¿entreácaracteres individualesjon las relacionales,



comparaciones entre caracteres basadas en el orden implícito ——4segu¿n ' ¡‘Le

l4

confrontación- dado por la codiﬁcación binaria del alfabeto. En nuestro pseudolenguaje
llamamos carácter al tipo que representa caracteres. Los literales de tipo carácter los

representaremos entre comillas simples: ‘A’, 'a'.

Estructuras algorítmícas de control.

Un proceso se realiza ejecutando una secuencia de

instrucciones, una detrás de otra, al dictado de un algoritmo; pero si



el orden de ejecución tuviese que corresponderse directamente con

el orden en que están escritas las sentencias del algoritmo, no  l

habría posibilidad de escribir algoritmos generales, que fuesen  l

capaces de indicar reacciones diferentes ante la variación de los



datos que confonnan el caso del problema que se este’ tratando en



cada ejecución —vimos como el algoritmo RaízCuadrada hace
cosas diferentes según X sea menor que cero o no, y como, en el segundo caso, el número de
veces que se repite el cálculo de Y y de Z depende del valor de X.

Por tanto, a la hora de escribir un algoritmo necesitamos, además de la facilidad para
escribir una serie de instrucciones con ‘estructura secuencial, otras para poder indicar
variaciones en el ﬂujo de instrucciones que deben ejecutarse, en ñinción de alguna condición
eyaluable.

Bñhm y Jacopini’ demostraron en los años 60 que para escribir cualquier algoritmo
son suﬁcientes, además de la estmctura secuencial básica, una estructura de selección entre
dos posibles ﬂujos de ejecución, y una estructura que permita controlar la repetición de un
conjunto de acciones. .

Dijkstra, uno de los padres de la programación estructurada’, propuso el uso de tres
estructuras del tipo de las enumeradas, caracterizadas por tener un único punto de entrada y
un único punto de salida, lo que permite anidarlas y concatenarlas sin problemas.

Los lenguajes de programación deben ofrecer sentencias de control que permitan

‘Bóhm 8. Jacopini: "Flow diagrama, Turing machines, and languages with only two formation rules".
CACM V9 #5 pp.336_371 (May '66).

’Dijks1ra: "Goto considered harrnful". CACM V11 #3 pp.147_148 (March '68) | Dijkstra: ‘Notes on
structured programming". pp17_19 in Dahl. Dijkstra 8. Hoare: Structured programming Academic
Press 1972.

l5

implementar versiones básicas de las estructuras de selección y repetición —la estructura
secuencial se da por supuesta-g pero la mayoria de los lenguajes no se limitan a ofrecer las
versiones básicas, sino que incluyen variaciones convenientes para facilitar la escritura y la
legihilidad de los programas. El denominador común de todas las variaciones es que siempre
se puede conseguir el mismo efecto usando las versiones básicas. Las versiones más

habituales son las que se muestran en la siguiente tabla.

Estructuras de control

Básica No básica
selección Estructura de selección lógica entre Estructura de selección múltiple
dos altemativas. (proceso por casos)
Estructura repetitiva con una Estructura repetitiva con una
Repeﬁción condición lógica preevaluada. condición lógica postevaluaïla.

Estructura repetitiva controlada por
contador.



Estructuras de selección.

La es_tructura de selección básica es una que permite elegir entre dos posibles
altemativas para el ﬂujo de ejecución en función de la evaluación de una condición de tipo

lógico. Su expresión sintáctica en cl pseudolenguaje que utilizamos ya la hemos visto cn el




algoritmo RaizCuadrada:
si <condición> entoncas Algoritmo
<accíón> RaízCuadrada
si no . . .
<acción si X > o entonces
alternativa> . . .
Ein si si no
o bien, si la acción alternativa es - - -
Ein si
no hacer nada: pu“
  fin hlsoritﬂn

<acción>
fin si



Muchos lenguajes ofrecen además una estructura de selgión múltiple, que

denominaremos de proceso por casos, cuyo efecto se puede conseguir anidando varias

16

C

/

estructuras de selección básicas, aunque el efecto sería un algoritmo con más código y más

diﬁcil de entender.



“gún <9XPreSiÓn> hice! donde cada alternativa tiene una de las siguientes
<alternativa> bmas
<alternativa> l '
. 1 (1)
a1ternatíva> i <etiqueta> <acción>
en ocre caso i (2)
<acción> <etiqueta>. .<etiqueta> <acción>
tin según (3)
<etiqueta>, <etiqueta>, . .. <acción>



La expresión, generalmente, debe producir como resultado un valor ordinal, según el
cual se ejecutará la acción correspondiente a la altemativa que lo tenga como etiqueta. Si el
valor de la expresión no coincide con ninguna etiqueta, se ejecutará la acción englubada por
la cláusula en atru caso, si la hay. Todas los posibles valores de la expresión deben estar en

una y sólo en una d; 18,5 altemativas.

algoritmo Calculadora
variables entera Operación
reales Opl, Op2, Res

leer Operación
leer OpLOpZ
según Operación hace:

1: Res <— Op1+0p2

2: Res v Op1_Op2

3: Res e Op1*Op2 ¿t

4: Res r Opl/opz y /
un según ‘i /
escribir Res , .
parar ‘t’ /
tin algoritmo {Calculadora} \\ /

Estructuras de repetición. / i

La estructura de repetición propuesta por _Dijkstría_ permitía realizan una



,ML
evaluar una condición y,_en función de la misma, ejecutar otra acción y repetir el proceso
desde la primera. No obstante, son pocos los lenguajes que implementan tal tipo de
estructura, y la que se entiende como estmctura de control de repetición básica es la
estructura preevaluada —la cgndición se evalúa antes de ejecutar la acción— que muestra la
ﬁgura de la segunda celda de la siguiente tabla, y qu ya hemos utilizado también en el

l . W
algoritmo RaízCuadrada. “ ‘ u" Mi“
V i



fa

mientras <eondici6n> hace:
<acción>
Ein mientras:

algoritmo Raízcuadrada

mientras abS1X-Z)>:0.00005 hace:
Y*((X/Y) +YJ /2
z « y w y
sin mientras



Repetición de Dijkstra Repcüción preevaluada

Es imponante que la condición de control este’ en coordinación con el cuerpo del
bucle. en el sentido de que las acciones de aquél estén encaminadas a hacer que la condición
deje de cumplirse, de manera que la ejecución de la estructura repetitiva pueda terminar. En
el caso del ejemplo, podemos observar cómo la sucesión de valores de Z es decreciente a
partir de la segunda iteración, mientras que X se mantiene estable, por lo que la diferencia en
valor absoluto X-Z converge a cero, llegando por tanto en algún momento a ser menor que
0.00005, que es el objetivo de precisión marcado por la condición. Si este tipo de

coordinación no se produce correctamente, podría ocurririgue, para determinados casos del

problema, una vez que laeiicucion alg_



ritmo alcance la estructura repetitiva, _no la
abandone nunca, produciéndose lo que se conoce como Álgucle inﬁnitg, que es contrario a la

propia defmición de algoritmo.

repetir
acción
hasta que condición



acción
mientras no condición hacer
acción
Ein mientras



Repetición postevaluada

También es frecuente la aparición de una estructura de control postcvaluada —bucle
en que la condición se evalúa después de ejecutar la acción» que produce la ejecución de la

acción controlada una o más veces, mientras que la estmctura repetitiva básica ejecuta la

IB

acción cero o más veces. Esta estructura es perfectamente implementable con un bucle
preevaluado, repitiendo la acción e invirtiendo la condición.

Otra forma de repetición la proporcionan los but-les controladas por contador, que se
pueden emplear cuando el numero de iteraciones a realizar ya se conoce en el momento de
iniciar cl proceso repetitivo. Si es ese el caso, no hace falta plantearse una condición lógica
que nos diga cuándo se puede tenninar la ejecución del bucle; en su lugar, puede utilizarse
algún mecanismo que simplemente "cuente" las iteraciones realizadas, y detenga el bucle
cuando se ha alcanzado el número deseado. Tomemos como ejemplo el siguiente algoritmo
que sirve para multiplicar dos números naturales mediante sumas sucesivas:
algoritmo Multiplica

variables naturales Multiplicando, Multíplicador,
Producto, Contador

escribir "Multiplicandcïm"
leer Multiplicando
escribir "Multiplicadorz"
leer Multiplicador

Producto F O‘
para Contador desde 1 hasta Multiplicador hace:
Producto * Producto o Multiplicando
Ein para

escribir "el producto es: ", Producto

parar
Ein algoritmo

La forma general de un bucle controlado por contador involucra:

- una variable de tipo ordinal que actúa de contador,

- la especiﬁcación de un valor inicial para empezar el conteo,

- la especiﬁcación del valor ﬁnal que debe alcanzarse antes de terminar, y

- el "paso" o incremento que suﬁirá la variable controladora tras cada ejecución del
bucle.

El paso por defecto es 1, suponiendo que el valor ﬁnal es mayor que el inicial; si es al
contrario, se deberá especiﬁcar un paso negativo (-1). También se pueden especiﬁcar pasos
distintos de l, aunque si un lenguaje sólo permite pasos iguales a la unidad ello no supone
ningún problema, dado que el paso deseado se puede calcular como una función del valor de

la variable contadora.

Í para <contador> desde <valor inicia1> hasta <valor fina1> [paso <paso>]

n hacer
¿ unggn

En ningún caso se debe intentar modiﬁca: explícitamente la variable Contadora en el

cuerpo del bucle, ya que, de poder hacerse, ello podría desbaratar el afecta de conteo, con

resultados posiblemente inesperados.

Z0

m.n.nnnnnmanana;nan¡ganannannmnnnnnnnnnnnnnnniinnnvllﬂﬁﬁ
A .‘ l

Elementos básicos de programación (2).



Ristras de caracteres. y / w u v l



ejemplo, dado el alfabeto {x,y,z), son rístras "x", "xy“, "xxyyz", "zyxx", Una ristrapuede

no contener ningún carácter, dicha ristra se representa por jj" y se llama ristra nula o vacía.

Aquí se usará el símbolo @ para ﬁcï el carácterrespacio, cuando sea signiﬁcativo a
efectos docentes. Ha de notarse que la ristra "@" contiene el carácter espacio y no debe

confundirse con la rislra vacia ("").
A la hora de declarar variables se pueden distinguir tres clases de ristras de caracteres:



(l) de tamaño tﬁgga) de tam limitado (3) de tamaño dinámico. Las variables ristra de
‘a , L Y  ¡1
tamaño ﬁjo se declaran como ristraﬁgﬂqmaño], y el valor que contienen siempre tiene la

longitud deﬁnida, que se completa con espacios, caso de asignarse un valor con menos

caracteres. Las variables rístra de tamaño limitado se declaran como ristraﬂamaña] y su
contenido podrá ser una ristra de cualquier longitud comprendida entre 0 y Tamaño. Las
variables ristra de tamaño dinámico se declaran simplemente como ristrra y pueden albergar

ristras de cualquier longitud.



A los valores de tipo ristra le son É ¿lomasírelacionales basadas en la
ya mencionada sícpencia de confrontación del código, que generalmente se dispone, de tal
forma que, en lo que se reﬁere a los caracteres alfabéticos, semantiene la ordenación
alfabética natural, siempre que sean todos mayúsculas o minúsculas, así las siguientes

comparaciones serían ciertas:

‘WSÏÏDRES,’ < “mA u’ o L z l 3,1, zz’... u  a 4 y
“JOSÉ” < “JOSELEÏ

TEDRO" 2 "ÁÏNToNIoz

‘¿ﬁlntonitf < ‘álitonioí...

Además de estas operaciones, el tipo ristra dispone de otras especíﬁcas que se
enumeran a continuación:
- Cálculo de la longitud. La longitud es una propiedad de las ristras que se deﬁne

como el numero de caracteres que las forman. En nuestro lenguaje algorítmico



" llamamos lon() a la operación que aplicada sobre una ristra produce un valor entero

que representa su longitud, asi: lon(“Canarias”) es 8 y lon(“ULPGC") es 5.



I" Naturalmente, no es demasiado útil emplear la operación lon() sobre valores literales,
sino más bien sobre variables de tipo ristra (esta misma aﬁrmación es aplicable a la
mayoría de las operaciones); así, si A es una variable de tipo ristra, lon(A) será igual a
la longitud de la ristra contenida en A en el momento de aplicar la operación lon(). La

lgngïuggie _l_a r' (nula es 0.



- Concatenación. Es la gig‘); ge_qos sulgristras para fonnar una mayor por simple
 yuxtaposicion. Para expresar algorítmicamente la concatenación empleamos el
/ símbolo +; de este modo la expresión: “Las” + “@Palmas”, producirá la rístra
“Las@Palmas”. La ristra’ nula actúa corno elemento neutro para la operación de

concatenación, es decir, “” + X = X + “" = X, siendo X una ristra cualquiera.
- Eagizzgiojﬁderun} ísuhristra. Consiste en averiguar en qué posición se halla una
\ ¿uyrjstra dentro de* una” ristra dada; por ejemplo, en la ristra

“Las@Palmas@de@Gran@Canaria", encontramos la subristra “Palmas” comenzando



/ " ' ¡’Í k en la posición S. La localización de subristras se implementa como Estas), siendo R
v, 14 la ristra, S la subristra a buscar y pos(R,S) la posición en R del primer carácter de la

7 primera aparicion de izquierda a derecha de la subristra S, si se encuentra, o cero en

caso de que S no sea una subristra de R.

- QQpjaAde una subristra. Se trata de, dﬁqyna ristra, obtener otra tomando un trozo
‘V de ella. Se ha de especiﬁcar la ristra fuente, la posición de comienzo de la subristra a

a1 tomar y el tamaño de la misma. Aplicamos esta operación con el f_v¿1n¿to_sub(R,P,T),
de forma que sub("l.as@Palmas@G.C.”,6,5) produce la ristra “almas“. En el caso de
¿Legercer parámeuo se omita, (¿mi mayor que lon(R) fP + 1, la rí_str_a resultante se
formará tomando los caracteres deílidesde l’ hasta el ﬁnal: sub(“Las@lÏa_lmas”,5,9) =

y’ sub(“Las@Palmas”,5) = “Palmas”. Otras situaciones, como: P s 0, P >‘7lon(R), T s



0,... producen la ristra nula.

22






Entre el tipo carácter y el tipo ristra consjderaremos que existe compatibilidad, lo que
permite, por ejemplo, concatenar un carácter a una ristra o localizar un carácter individual

como subristra dentro de una ristra o asignar un mrácter a una ristra.

ÏÉEEÉEEESY ",0 °"1¡"='°S-

Se deﬁne un tipo ordinal como gLél en que es posible establecer una aplicación
biyectiva entre los valores del tipo y un subconjunto ﬁnito de los números naturales de forma
que se establece el orden entre sus elementos. Lo que signiﬁca esto es que hay un valor que
c4 primero y cada valor del tipo tiene un sucesor, que es único —naturalmente, puesto que
el rango de valores del tipo tiene que ser ﬁnito, existe un valor que es el último y no tiene
sucesor. Si Y es sucesor de X, entonces decimos que X esípredecesor de Y; como el primer
valor no es sucesor de nadie, no tiene predecesor.

De los tipos primitivos, se consideran ordinales los t_ip_os enteros y el tipo carácter; a
veces, también se considera ordinal el tipo lógico, mediante el artiﬁcio de considerar el valor
falsa como primer valor y el verdadera como su sucesor, o viceversa. Los tipos reales no
pueden ser ordinales, ya que entre cada pareja de reales existen inﬁnitos reales, con lo que no
es posible establecer la aplicación con los naturales que pennita encontrar el sucesor de un
real dado.

Aunque todos los tipos ordinales poseen un orden entre sus elementos, no debe
confundirse que un tipo sea ordinal ¡cg que exista un orden entre sus valores: en los reales
son perfectamente aplicables los operadores relacionales —salvo quizás la igualdad, por
razones de representación. Se puede saber cuando un real es menor que otro. lo que no se
sabe es que real sigue a uno dado.

Para los tipos ordinales se deﬁnen operaciones especiﬁcas que dan acceso a la
correspondencia con los naturales, tales como:

Wpﬂipgordinal). Devuelve el primer valor de un tipo ordinal.

, v lÉltimo(Tipo_Ordinal). Devuelve el último valor de un tipo ordinal.
l k, , 0rden(Valor_Ordinal). Devuelve el valor natural correspondiente a un valor ordinal.

«—‘ Valor(Tipo_Ordinal,Valor_Natural). Devuelve el valor que corresponde en un tipo



Su9esor(Valor_0rdina1). Devuelve el valor sucesor de uno dado, excepto para el
ultimo.
PredecesorWalor_Ordinal). Devuelve el valor predecesor de uno dado, excepto para

el primero.

Ínalesﬁdefinrig por el programador.



“¿S d "f!

Uno de los mecanismos más sencillos para pennitir al programador deﬁnir nuevos
tipos a partir de los predeﬁnidos es la posibilidad de deﬁnición de nuevos tipos ordinales. La
deﬁnición de nuevos tipos ordinales puede hacerse por acotación ¡dí un subLngo deglores
de un tipo ordinal ya deﬁnido, o por enumeración exhaustiva y ordenada de todos los valores

del nuevo tipo. En consecuencia, hablaremos de tipos subranga y tipos enumerados.



tipo Byte es entero o. .255 fin tipo /«/ ' ""

tipo Natural es entero O..Ü1timo(entero) fin tipo‘
tipo Positivo es entero lnﬁltimcﬂentero) fin tipo

tipo Negativo es entero Primercuentero) ..-1 Ein tipo w
tipo Días es .5 ¿wm cv -  ‘ N"

lunes, martes, miércoles, jueves, viernes, sábado, domingo
fin tipo

tipo DíasLaborables es Días lunes. .Viernes Ein tipo

A los tipos subrango se les pueden aplicar las operaciones del tipo base de donde se

ha tomado el rango; a losenumeradgs sólo les son aplicables las operaciones generales_de los

tipos ordinales.

Zipos de datos estructurados.’

Una «¿Quail ¿eg qtipoestructurado, es un objeto de datos que está compuesto



de otros objetos de datos, llamados componentes o átomos, que pueden ser a su vez simples o

estructurados.

Como mecanismos básicos para construir estructuras de datos suelen distinguirse; uno
para crear estrucluras homogénea: y otro para crear es/ructuras heterogéneax.

Una estructura homogénea es la que está formada por componentes que son todos
dAel mismo tipo, mientras que una estructura heterogénea está formada por componentes
que pueden ser de tipos diferentes. Las estructuras heterogéneas sirven para IÏEÜSCÏIIKT

entidades complejas ;por ejemplo los datos contenidos en la ﬁcha de un alumno, tales como

24

nombre, dirección, teléfono, fecha de nacimiento,...— mientras que las estructuras
homogéneas sirven más bien para representar colecciones de elementos —por ejemplo la lista
de los alumnos matriculados en una asignatura. El modo de tratar cada tipo de estructura es

muy diferente.

n zw v» « >  “ r, "ﬂ/zmcmﬁ; ¡»y v-,y,¿,1 , , a



a APN/v» ,»_:,;/,,z, v/'Ju,«»v¿ jr: :. 114g ¿ibm-sm

Estructuras heteroééhens.“ ' ﬂmynﬂ ¿f V”?

El mecanismo disponible habitualmente en los lenguajes de programación para formar

estructuras heterogéneas —comúrunente conocidas por la denominación inglesa de_record—

pennite agrupar conjuntos de datosdiversos que ‘se referencian como una entidad única. Por

ejemplo:

i tipo Persona es estructura

campos risera‘ Nombre, PrimefApellido, segundonpenido
campo tiatral9l NIF
Ein tipo w y s , ——





Los c_omponentes de la estructura reciben el nombre de canje los campos pueden



ser de tipos de datos diferentes. Se puedfeﬂacceder a cada campo por separadoto maneja: la

estructura como un todo. Por ejemplo, si declaramos las siguientes variables de tipo Persona:

variables Persona Personal, Personaz

podemos tratarlas como un todo:

Personal F Per50na2

o acceder a un campo individual:

PersonaLNombre "' "Juan"

Para acgder a un campo individual se pone el nombre de la variable seguido de un
punto (.) y el nombre de_l_carnpo. Con los campos se puede realizar cualquier operación
acorde con su tipo; con la Etructura completa sólo se pueden realizar, en principio,
asignaciones y comparaciones de igualdad/desigualdad.

Una e_st_ructura Leterogéneapuede, en general, contener campos de cualquier tipo,

incluso de un tipo estructurado.

25



M’! r’
K
tipo Empleado u astructuru
campo Paqui 51d’ n,
campo Entero Arïuguedad
campo real Salario
un tipo



Naturalmente, esto hay que tenerlo en cu la L la hora d_e>aíceeder ¿ﬁuníeampd

individual usando la notación de punto.

variable Empleado Empleadol

Empleadolidentidadﬂombre » "Juan"
, Á J

Estïcturas homogéneas.

Una estructura homngénea lisina —lo que en inglés se conoce como array- es un

conjunto qjgensiqnado de elementos del mismo tipo. Con dimensionado queremos decir que
los elementos se hallan alineados según una o más dimensiones, donde alineado signiﬁca que
están dispuestos en "hilera", de fonna que uno es el primero y todo elemento que no sea el
primero "sigue" a otro. Esto pennile designar paga elemento individual ¿gún su posición

mediante un conjuntg de indices (uno por cada dimensión).
l M‘ /
m!" lg,» ‘i ‘l

w} Elïlíﬁﬁlllíﬁl «e
. ‘ b ‘¿:1

mmiﬁnmn
[LH [L2 2,31 Bxﬂ y '
EJULZJ l
luwulwzly L








‘ Ilustnción 4 Organización en l y 2 dimensiones

Una estructura homogénea se carzicteriza por:

- su 513353 de dimensiones,
- el número máximo de elementos en cada dimensión,
- el gigoz-pgjinal, como requiere el efgcto d_e qlineación- y rgngp de variación de los

indices en cada dimensión y

- el tipq de los elementos que contiene.

26

De acuerdo con lo anterior consideraremos sjpgácticamentfe válidas las siguientes





deﬁniciones de tipo. 7,”, /   ¡_ ¡ﬂ! ¿[W ¿F 4 ¡ “¡(4 V)
11) cipo Vector es estructura enteroll. .100] Ein tipa “o /// ‘ , l/í‘

(2) tipo Matriz es estructura rea1[1..100,1.‘90] Ein tipo .3 x 7,, ,

(3) tipo VHorasExtra es estructura

real [Pfimero(DíasLaborab1es) . .Ü1timo(DíasLahorab1es) 1
Ein tipo
(4) tipo TFrecLetra es estructura entero['A' . . 'Z'] tin tipo

En (l) se deﬁne una estructura homogénea de elementos enteros dispuestos en una
dimensión e indizados de l a l00. En (2) una estructura de elementos reales, organizados en
dos dimensiones, la primera con índices de 1 a 100, y la segunda de l a 50. Enr3 también se
deﬁne una estructura de componentes reales. pero es monodimensional, y sus índices se
mueven en todo el rango de valores del tipo DiasLaborables —que será ordinal. Por último,
en (4) se deﬁne una estructura de enteros cuyo rango de índices está formado por las letras
mayúsculas de la ‘A’ a la 'Z' tomadas en su orden,

También es frecuente deﬁnir estrgtuiïtonpgéneas especiﬁcando, no el rango de

variación de los índices, sino el número de elementos en cada dimensión:

tipo Vector es estructura enterollDül Ein tipo
tipo Matriz es estructura real[100,50] un tipo

Esto sólo se puede hacer si existe un convenio que deﬁna cual, y de que tipo, es el
glor de comienzo de los rangos. Si acordamos que los rangos por defecto empiezan en l, lo
anterior es equivalente a los casos l y 2 del primer ejemplo.

Tampoco resultan extrañas —aunque quizás poco convenientes a veees— las
declaraciones de variables usando estructuras homogéneas "anónimas“, dfeﬁnidas en la propia
declaración. En el siguiente ejemplo se declaran dos variables enteras (m), y una tercera

(Vea) que es un vector de 10 elementos enteros, con índices de l a 10:

variables enteras i, j, Vec[1..10]

Es importante señalar que las constantes usadas en la deﬁnicion para especiﬁcar el
numergde componentes y rango de indización expresan el número máximo de componentes
que va a tener la estructura’ a efectos de reserva de memoria) Si en el tipo Vector se hace una
reserva de espacio para 100 elementos enteros —es así en ambas modalidades de

declaración—, los algoritmos que utilicen variables de tipo Vector podrán tratar colecciones

27

de hasta l00 elementos, pero no es necesario obligar a que siempre tenga que haber

exactamente l00. Es habitual asociar a cada variable dimensionada una variable ordinal por

cada dimensión que se use para saber hasta qué indice se havllenado la variable en esa

dimensión.
I ,- / y
vazxames Vectorlv“ WWW.‘ ’/"""¿;;r_r,-\
"ww-x natural Nummementos .s—

leer Num-Elementos

Zur/tc; 3/

(NumElementos tendrá que ser menor que 10o)

pax-Ji desde 1 hasta NumElementos hacer

leer kvli]
tin para

(se rellenan los primeros Nummementos de v)

Una altemativa interesante es "encapsular" en una estructura heterogénea el vector

junto con la variable gue indica la porción que se está usando —se ha cambiado el tipo de la

variable Numalementos para ajustarla a lo que es posible segin el rango deﬁnido para el tipo

Vector:

tipa Indicevector es entero 074100 fin tipo

tipo VectorEncapsulado es estructura

campo Vector Datos
campo Indicevector NumElementos
fin tipo

En principio, el tipo de_los componentes de un conjunto dimensionado puede ser

cualquiera ——está limitado en algunos lenguaies—, inclusqotro conjunto gmensionado:

tipo Fila es estructura reallso] Ein tipo
tipo VecVec ee estructura Fí1a[100] fin tipo se



{Mi i/¿"íim r’
fu

El resultado escomo una estructura multidimensional. Aunque la diferencia parezca

una cuestión trivial de sintaxis, sirve para ilustrar como una misma realidad puede admitir

diferentes interpretaciones y tratamientos.

variable Macri z M

para i desde 1 hasta 10o hacer
pura j desde 1 hasta 5o hace:
M[í,j] * Ü
tin para
fin para

variable VecVec M

para i desde 1 hasta 10D hace:
pare j desde 1 hasta 5o hace:
Mii] [j] * 0
Ein para
ﬁn para

Los ejemplos también ilustran cómo las sentencias repetitivas, y en particular la

controlada por contador, están íntimamente ligadas al tratamiento de conjuntos

28

‘¿ﬂ ¡,{( «¡.4 c, g





1: V ¿
"; (mu/a l
l

(Lirnensionados. Es lógico que si se tiene una colección de elementos del mismo tipo la
mayoría de las operaciones a realizar con él consistan en repetir un mismo tratamiento para
cada uno de los elementos de la colección. Dadas las características de la estructura, el acceso
a todos y cada uno de los elementos implica oyjener cada una de las posibles combinaciones
de valores de los índices, esto se consigue anidando un bucle por cada dimensión que haga

ge una variable del tipo ordinal adecuado recorre el rango _de valores del índice de esa

Énensión.

subprogramas;

¡Concepto de subprograma.
Supongamos que queremos hacer un programa para calcular el factorial de un
número. El factorial se puede deﬁnir como:
n! = 1
n! = n'(n-1)'..."1
(producto de todos los naturales de l a n)

sin=0
sin>0

Un algoritmo que implemente esta regla es bastante sencillo, consiste básicamente en

una estructura repetitiva que acumule las sucesivas multíplicaciones.
/ ¡{,1 x ' 1 ¡a \

algoricm factorial
variables naturales n,

guay y, ‘lswk
f,
wz/uz!» A; .

escribir "déme un valor natural: “
leer n

,x¡f,‘_/¡I,4 m:



¿,1 ¿M1 z- \



f 1 —- («wz-wn npzw/fv/w/
para i. donde n hasta éñyaso -1

t e f ú i " “
fin para

hace:
2 v



———/ 1/ 1- qu‘ MJ!"
u!’ (4 ¡r u. n’ .,

escribir "el factorial es: ", f

para:
Ein algoritmo

1;!"

4,;



29 ‘

¿,_.__,.

4'.- 3
1.104: lo

Realmente simple, pero pongámonos en el caso hipotético de que el procesador
disponible no tenga deﬁnido el operador de multiplicación, aunque si el de suma. Tenemos

un algoritmo para multiplicar mediante sumas, podemos adaptarlo para incluirlo en el cálculo

del factorial: , ,4 M W’
I?“

algoritmo factorial 1/ (

vnzinbleunaturales n, f, ,
Multiplicando, Multiplicador, Producto, contador





escribir "déme un valor natural: .,
leer n "



"M. ¡www  w



‘¡hasta 2 paso -1 hace:
Multiplícarído e f r— W" h“
Multiplicador e i n- —

u 4V t.- m/v w:



w v  —.-« .4 w I r.



Producto «(o w í , «rw. « y
para Contador desde 1 hasta Multiplicador hace: ——r
Producto e Producto + Multiplícando

Ein para

E e Producto
Ein para

escribir "el factorial es: ", E

para:
fin algoritmo

Claro que ahora, el algoritmo ya no parece tan sencillo; y la situación podria

empeorar. Imaginemos que lo que queremos es calcular ‘un número comhinatorio:

m m!
n n!(m-n)!

Lo que necesitamos es un mecanismo que permita mantener algoritmos separados
para resolver problemas diferentes, pero que al mismo tiempo posibilite que, si como parte de
la acción de un algoritmo se precisa resolver un problema con entidad propia, aquél pueda
"subeontratarlo" con otro que se dedique exclusivamente a la resolución de dicho problema
proporcionando los resultados para que el primero pueda continuar. Este mecanismo son los
xubpragramas. Un pr_ogi¿a_ma queda organizado como un comunto de subprogramas, uno de
loscuales contiene el algoritmo principal, con la lógica general de resolución del problema,

que controla la ejecución del resto de los subprogramas —se ocupan de la resolución de

partes concretas de aquel.
Un programa se ejecuta a petición de un usuario, el cual debe conocer los datos que el

programa precisa y será quien supervise los resultados. lJn Subprograma se ejecuta a petición

3D

l r
M/"a-z >/>x'



mnnnnn-nnnnnnnnnnnnnnn Ï
nnnnennnnnnnnnnnnnnnll¡QEQEQQRQ!

de otro algoritmo llamador —puede ser directamente un programa u otro subprograma—
que, al igual que el usuario ﬁnal, debe proporcionar al subprograma llamada los datos que
precise y recibir del mismo los resultados que genere; como esta comunicación entre
llamador y llamado no puede establecerse a través de los canales habituales de entrada/salida
—dado que no tienen "existencia ﬁsica" y por tanto no pueden usar un teclado o ver una
pantalla—, se_ establece a través de las llamadas [mas de pqrámerrgg Los parámetros
representan los datos que se intercambian entre el Subprograma llamado y el que lo llama;
pueden ser de _e_m‘_r:q_da, de salida o de entrada/salida, según el sentido en que se realice la
transferencia de información; un subprograma pued_e4tgn_m' además variables locales que
utiliza inítemamente, pero no están implicadas en la comunicación entre un subprograma y su
llamador. Eventualmente, un subkïograrnaïpuede tener acceso ¿{variables globales, deﬁnidas
en alguna zona de acceso común, fuera del Subprograma, pero ello no es muy adecuado,

porque supone una forma de comunicación no explicita, no ya entre un subprograma y su

llamador, sino incluso entre subprogramas aparentemente independientes.

Bgediruientas y funciones.
Se distinguen dos clases de subprogramas: los Eqpedimientos y las funciones. Los
Eyeedimientos‘ responden al concepto de acción algorítmiea como “transformación de
estados”; en este caso, se pasa de un estado representado por el conjunto de valores iniciales
de los parámetros de entrada y entrada/salida a un nuevo estado representado por los nuevos
gres de los parámetrosde entrada/salida y _síal@a_._ Las Eiqgrgí‘ se inspiran en las
homónimas matemáticas, las cuales establecen una relación entre valores de un dominio y
valores de un contradominio o rango, de manera que a gagvalgjel domirtigle corresponde
uno y sólo uno delgsntradomínio; la diferencia entre las ﬁmciones matemáticas y las
informáticas estriba en que las segundas se implementan como una secuencia de sentencias
que pueden hacer más cosas —dibujar algo en pantalla, modiﬁcar variables globales,
almacenar información en un dispositivo,...—, que no forman parte del resultado que
devuelve al ﬁnalizar —una función informática sin esta clase de efecros laterales es

conceptualmente lo mismo que una función matemática.

31



Función Función informática s‘, ¡

 ¡ ‘¿y
matemática equivalente r’ ﬂ (¡M ‘il: ’
ﬁx) :x2 función entera ¿(xr

variable entrada entera x
devolver x*x
fin función

Cuando escribimos un Subprograma gn su cabecpra esgeoíﬁcamos de qué glass de
Subprograma se trata, le damos un nombre y le aﬂuntamg; una lisg ge parámetrug/fofrfagcs
que describe los(datos que el Subprograma intercambia con quien lo llama.)

pzocadimiente Multiplicar(multiplicando,Multiplicadorproducto) ,  _
í variables ‘<" "” ’ ’ ú " ""
entrada naturales Multiplicando, Multíplicador

su} natura1 Producto
Quad atura1 contador
PIOÓHCLO F 0

para contador donde 1 aaata Multiplicador hncer
Producto «v Producto + Multiplicando
ﬂn para

retorna: v-— 1: wav ﬁ n 4 > u_ g,
fin procedimiento



o bien, implementando una función

/-* función natural Multiplicación(Multiplicar-nde,Multiplicadcr)

r
1 variables
2 entrada naturales Multiplicando, multiplicador
locales naturales Producto, Contador
Producto 4- 0
 para contador desde 1 naata Mu1t1p1icador hacer
V Producto e Producto + Multiplicando
(in para

devolver Producto
Ein función

32

u
G
É
ü
E



IPWFE P/IFIIIÜJOMEQP?



HÍPÜÜÍ’





Si comparamos estos dos subprogramas con el algoritmo de multiplicación que

habiamos desarrollado previamente observamos las sigiientes diferencias:

- La utilización dc las palabras procedimiento o función para indicar la clase de
Subprograma.

La aparición de las listas de parámetros formales y la desaparición de las operaciones
de lectura y escritura, ya que la comunicación se realiza con otro algoritmo a través de
las listas de parametros (ello no signiﬁca que en un Subprograma no puedan hacerse

este tipo de operaciones).

- La desaparición de la instmcción parar y su sustitución por otras que dan idea de que

el proceso continúa en otro sitio y no termina con la ﬁnalización del Subprograma.

Si comparjinos entre si ambos subprogramas vemos que:

- La fgición tiene gpdrámetro menos que el procedimiento, ya que al igual que en las
matemáticas, la propia función representa uniyalor (el resultado de su ejecución),

cuyo tipo se declara en la cabecera.

- La sintaxis dela sentencia que termina la ejecución del subprograma es diferente ya

que en la ﬁmcion sedebe indicar el valor resultanteje su aplicación.

Cuando un aigoiitmo necesite hacer uso de un Subprograma disponible, deberá
escribirse una jgtrfncpi n de llamada, en la cual se debe gpgzjﬁgar _el nombre del
ﬁaprggrariia que se requiere, junto con una listadegqrárriegas reales, que son las( variables
o valores del algoritmo llamador que se corresponden en esa llamada con los parámetros
formales especificados en la deﬁnición del Subprograma) La gorgspondencia entre la lista de
pírgirrietrosreales y la lista de parametros formales es, normalmente, posiciona], es decir, el
primer parámetro real sustituye cn la ejecución al primer parámetro formal, el segundo al
segundo y así con todos; ello implica que las listas de parámetros reales y fomiales deben
gcgicidir en el número de parámetros y que los que ocupan iguales posiciones iran de ser
gompatibles. A los ¿gérmenes formales de’ salida o entrada/salida sólo les pueden
corresponder parámetros reales que sean variables, mientras que a los de entrada les puede

corresponder cualquier expresión de un tipo adecuado, dado que desde el punto de vista del
33



subprograma son sólo valores que usa y(no necesita ningún área de memoria para depositar
un resultado como ocurre con los de salida.)

Cuando en la ejecución de un algoritmo se alcanza una instrucción de llamada a un
subprograma, se pasa a ejecutar éste, quedando suspendido el llamador hasta que el
subprograma ﬁnalice, momento en que se continuará con la siguiente instrucción. La
ejecución de una instrucción de llamada a un Subprograma es un proceso complejo ya que
implica guardar el estado actual del llamador, preparar las variables del Subprograma, si no
son estáticas‘ y los mecanismos de acceso a entomos no locales, si los hay, transferir los
parámetros reales a los formales y dar el control al Subprograma, asegurando que al ﬁnalizar
podrá devolverlo al punto adecuado del llamador. De modo similar, cuando un subprograma
ﬁnaliza hay que recuperar el estado del llamador, transferir, dependiendo de los mecanismos
de paso de parámetros, los resultados, dejar libre la memoria utilizada por las variables no
estáticas del subprograma y devolver el control al llamador en el punto adecuado para
continuar su ejecución.

Una diferencia importante entre las llamadas {procedimientos _y las llamadas a
funciones es que las primeras ctn_ns_ti_tuyen una sentencia más de un algoritmo; las lLrnadas a
Ïiones ¿beben formar parte de una expresión, ya que se debe recoger el valor resultante de
la función, que no queda asociado a ningún parámetro real. Vemos a continuación dos
versiones del algoritmo de cálculo del factorial, según la operación de multiplicación se halle

implementado como un procedimiento o como una función:

algoritmo Factorial
vnriahlasnaturalea n, f, i

escribir "déme un valor natural: "

leer n

f := 1

para i desde n naacn 2 paso -1 hacer

Multiplícarifjj) (Llamada a1 procedimiento Multiplicar)

ﬂnipnza

escribir "el factorial es: ", f

para:

sin algoritmo

‘una variable estática es aqueua que se ublCa deforma ﬁja en memoria ames ds wnenzsl ta eteeucsen dei programa y
permanece ahí hasta que la misma ﬁnaliza La mayoria de ¡es lenguajes usan las denominadas “variables de pila‘. que ocupan
¡a memoria cuando el euuprogtama en que esten ueeiarauas se va a ejecutar y la desocupan cuando tenntna su ejecución‘
ello tiene, entre mms, ¡a ventaja de permitir el uso del mismo espacio de memef por diferentes subprogramas. pero pagando
el coste de los mecanismos de ubicación y desubicsción
34

 nn¡amnmnnnnnanmnanannnnnnnnnnn¡manana-anna

algoritmo Factoríal
variableanaturales n, f, i

escribir "déme un Valor natural: "
leer n

f z: l

pan i desde n hasta 2 puc -1 hace:

ïlïultiplicaciórﬂﬁi) (Llamada a la función Multiplicación)

fin para "

escribir "el factorial es: ", Í
parar

fin ¡lgoritmo

Vemos que en ambas versiones los nrïbres de los m gs reales no coinciden con
los de los Eramitïrgnales declarados en las respectivas implementaciones del
Subprograma Multiplica. No obstante, tgmgpco supondría ningún pgslema guggllaimggeg
igual, en cualquier caso representan variables diferentes de subprogramas diferentes, por lo

menos hasta que la llamada las relaciona.

Tópicos avanzados en relación con los subprogramas.

Mecnnfíslï d asordeipnrámetros.



Cuando se llama a un subprograma, debe transferirse información entre los
parámetros reales y los fonnales. En la práctica, existerLdos modos de hacer este tipo de

transferencia: mediante la cogía del valor de u_n parámetros en el otro, o mediante la

transmisión de la referencia (dirección) del parámetro.



La grimeraolgón signiﬁca que el Earámetm formal > ¡son realmente variables
gstirtas. Es un mecanismo corriente en el Basjodeiygrámetros de entrada/comúnmente
llamado paso por valor —en el momento de producirse la llamada, el valor del parámetro real
se copia en el parámetro formal, y se trabaja con éste. Algunos lenguajes implementan
también mediante copia, en este caso llamada paso por resultado, losgámetrgs de salida —
cuando el Subprograma va a retomar se copia el valor del parámetro formal, con quién se ha
estado trabajando, en el parámetro real—, y los gïámetrosnde entrada/salida, lo que
constituye el pgsgpor yglorgresultado.

La segunda opción consiste en dar al subprograma la dirección del parámetro real,
para que lo use directamente en vez del formal. Setrabajaenel espacio de almacenamiento

Llparametro real —el parámetro formal actúa como un simple aIias—, lo que hace este
35

n n n d)

mecanismo poco adecuado para el paso dgparametros de entrada ——a menos que exista algún



mecanismo adicional que impida que se modiﬁque, lo que podríamos llamar paso por
referencia constante. El mecanismo de paso por referencia se usa mucho con los parametros

de salida y entrada/salida. Al no tener que realizarse copias de valores, el paso de parámetros

¡son

por referencia puede resultar más eﬁciente, especialmente cuando se trate de tipos

estructurados de gran tamaño. Sin embargo pueden surgir problemas si un mismo parámetro



real se hace corresponder a dos parámetros formales de salida o entrada/salida diferentes, lo

¿a que puede dar lugar a resultados no controlados (dependientes de la interpretación):

algoritmo Uno procedimiento Dos(X,Y)
variable: salida UnTipo x; y



¿e m, A)

sin algoritmo \ y <- 4
— x e y + x |???

 procedimiento

n n



C
C
G
G
í

Es verdad que también cuando se devuelven parámetros por resultado pueden ocurrir



ambigüedades si un mismo parámetro real se pasa a dos parámetros formales diferentes, pero

no mientras se ejecuta el Subprograma, y en realidad para que el resultado este’ determinado lo



único que hace falta saber es en que orden se realizan las copias de los resultados. Por otra



. parte, habria que plantearse si tiene algún sentido ofrecer un mismo recipiente para obtener

d 1 . . . . .
Pa, dos cosas diferentes, incluso aunque sea sintácticamente legal en un lenguaje concreto.

sobrecarga tlreroperaﬂtres.

í
i
I
d
í
G

En ocasiones es necesariod sarrollar subprogramas que igiplementan. para algún tipo



de datos, generalmente deﬁnido por el usuario, operaciones cuyo signiﬁcado es muyísililar
a_|_d¿algún operador del lenguaje aplicado entre tipos predetinidos; operaciones para las que
incluso puede ser habitual, fuera del mundo de la informática, emplear el mismo simbolo. Por
ejemplo, si A y B son números enteros, es habitual en matemáticas expresar la suma de
ambos como "A + B". Del mismo modo si M y N son matrices de enteros, es habitual en
matemáticas simbolizar la suma de ambas como "M + N". En casi cualquier lenguaje de
programación, la suma de enteros —un tipo primitivo- se realiza con el operador "+"; pero
si el lenguaje no está especíﬁcamente orientado a calculo matricial, no es probable que se

pueda aplicar el operador "+“ para sumar vectores —tipo deﬁnido por el programador. En su
36

lugar el programador podrá desarrollar un procedimiento —que tendría los vectores a sumar
como parámetro de entrada y el resultado como parámetro de salída- o, una ﬁmción en la
que el resultado sería la suma de sus parámetros.

Sin embargo, estaria muy bien que el lenguaje permitiera ampliar el signiﬁcado del
operador "+" para que cuando se encuentra entre vectores realice la suma de vectores, pero
sin que deje de realizar la suma de enteros cuando se encuentra entre enteros. Esto es lo que
se llama sobrecargar el operador. En realidad, casi todos los lenguaje tienen algunos de sus
operadores sobrecargados para varios tipos —"+" sirve para sumar enteros, pero también para
sumar reales, y, en algunos lenguajes, pam la concatenación de ristms, que es una operación
con un claro signiﬁcado aditivo——, de lo que se trata es de que el usuario pudiera añadir sus
propios signiﬁcados —procurando que no diﬁeran en exceso de los signiﬁcados originales
del operador. puesto que ello podría crear confusión.

Ello no tiene que ser muy complicado si pensamos que, operacionalmente, un
operador es básicamente una función con l, 2 o 3 parámetros, aunque se use con una sintaxis
diferente. De esta manera, la sojgrejarga de un operador podria hacerse de un _m_odo parecidog

¿Llaginición de una ﬁmción.



tipo Vector es eetruotun enteroll 11cc] fin tipo —u- 26/»
tipo Indicevector en entero o. .10 fin tipo __ Q _
tipo Vectorliïncapsulado es estructura

campo Vector Datos

campo Indicevector NumElementos
Ein tipa

función Vectorlïncapsulado "w (v1,v2>
variables entrada Vectorlïncapsulado V1, V2
locnlee veccorEncapsuladc sum
IndiceVector í

Sumaﬂumﬂlementos * Vlﬂunﬂlementoa
pan i desde l hasta sumenNumElementos hace):

Sumajatos [i] ‘r VJHDECOSÍÁ] + V2.Datos[i]
¡ln para

devolver Suma
(in función

Debe tenerse en cuenta que, cuando hablamos de sobrecarga de operadores, hablamos
de dar nuevos signiﬁcados a los operadores existentes, pero sinyvariar elznúrnero’ de sus
parámetros, y s_in_"inventar" operadores nuevos —salvo en lenguajes muy especíﬁcos, no se

puede tomar cualquier simbolo y decir que se va a emplear como operador.

37

sobrecarga de nombres de subprogramas.

Los mismos argumentos expuestos parajustificar la sobrecarga de operadores ;usar
el símbolo más adecuado para expresar una operación— pueden aplicarse a la elección de los
nombres de los subprogramas. Si un mismo algoritmo necesita hacer uso de un subprograma
para buscar un elemento en un vector de enteros y para buscar la n-ésíma aparición de una
subristra en una ristra ¿por que’ no pueden llamarse "buscar" ambos subprogramas? Si ese es

el nombre que mejor expresa lo que hacen, bien podría dársele a ambos y di¿





guirlos por el



tipo y n’mero de sus parámetros opor el tipo de su resultado si son funciones. Hacer esto,

que algunos lenguajes admiten incluso antes que la sobrecarga de operadores, es lo que se
conoce como sobrecargar el nombre de un subprograma.

Considéresc a modo de ejemplo estos dos procedimientos, el primero sirve para
ordenar un vector de números reales, mientras que el segundo realiza la ordenación de un

vector de ristras de caracteres.

procedimiento Ordenar (V, n)
Vaziableaentzadalsalida real Vll. ,100]
entrada natural n .__ 41v a > _ , r , , ,., cu, 4. ,, ,.
locales naturales i, j, k y
real e a ma, r 4‘ , u »,.,



para i desde 1 hasta n-l hacer p, «¡Num - ‘y; 4.. , l’, , V,
k ‘ í Ame.  / '

para j desde 1+1 hasta n hacer
u vlj] < vu] entoncas k e j un si
sin para

si k > i entonces

e * Vlí]
Vli] * Vlk]
Vlk] * e
Ein si
fin para
retornar

un procedimiento

38

 9npnppnennonpnmr¡»mwcwmarrones:

procedimiento Ordenar (V, n)
varinbleuentrada/aalida ristra V[1. . 100]
entrada natural n
locales naturales i, j, k
rístra e

para i desde 1 hasta 11-1 hacaz
k «e i

para j desde 1+1 hasta n hace:
si V[j] < Vlí] entonces k k j fin si
fin para

a1 k > i entonces
e * Vli]
Vlii r Vlk]
vlkl F e
Ein si
fin para

ZGCOÉHH!‘
fin procedimiento

Algoritmos genéricos.

Tomando como ejemplo los procedimientos del párrafo anterior, podemos observar
que el primero es un procedimiento para ordenar numérícamente entre sí los n primeros
valores de un vector de reales y el segundo sirve para ordenar alfabéticamente los n primeros
elementos de un vector de ristras. A pesar de que el tipo de los datos sobre el que actúan es
diferente, resulta evidente que ambos procedimientos siguen el mismo algoritmo. Un
algoritmo de ordenación lo único que necesita es que el conjunto a ordenar esté formado por
elementos ordenables, es decir que su tipo pennita determinar si un elemento es menor,
mayor o igual que otro. Podemos encontrar muchos otros casos de algoritmos que podrian
aplicarse en distintas situaciones, sólo con un pequeño retoque en la deﬁnición de los
elementos sobre los que actúan. Por ejemplo, si retomamos la suma de vectores utilizada
previamente para explicar la sobrecarga de operadores, podemos darnos cuenta que el
algoritmo seria el mismo entre elementos de tipo entero, real, complejo o racional; lo único
que hace falta es que el tipo en cuestión tenga deﬁnida la operación de suma. En casos como
éste, seria muy útil poder escribir algoritmos genéricos, en los que se indicara los elementos

gue habria que Líoncretarrpara aplicarlos en distintas situaciones.

39

/



giran-lxs». Mm_gL(X,)/_—T>  Gcüiun‘



ssnn r: » y » W """"*’
\_ r un tipo
“ Menor(T,T) una operación relacional definida sobre T {A ’” ‘¿te /
Rango un subrango ordinal wm n.» w mu:

,.
sumo».



procedimiento Ordenar (6,11).
variablesentradn/sslidu T vlRango]
entrada Rango n

locales Rango 1, j, k

wm h’ T e
l ‘"0 mp7,;
para i desde leie-iotkango) hasta Predecesorkx) hacer
k <e í

para j desde sucesor i) hasta n hacer
si MenofrlvljLvlﬁi) entonces k e j fin si
un para r 5 ¿"17  ' '
si k > í iñtbnhes
e k Vlí]
vii] v Vlk] Í’ A  A,” , ‘¡pg/Wow - .— vww
V[k] v e ‘
Ein si
tin para



0/1



IG COÏDEI
fin procedimiento

En este ejemplo, se usa la eláusula sea antepuesta al’ procedimiento Ordenar para
¡Pdiür l°5 element“ d‘: ‘QÉHWÉÏI ¿‘SQÉÍTEÉSÍEÉÉÜJÏÍÉÏÏÏÉ y que 5° Ïmdría" 935311“? 93-”
distintas apjí_c¿a_ oi —En este caso, el algoritmo de ordenación es el mismo aunque cambie
el tipo de los datos a ordenar (T), la operación con la que se averigua que un valor es menor
que otro (Menor), y el rango de los índices del vector (Rango). Si queremos ordenar un vector
de enteros de rango entero de 0 a 100, un vector de reales de rango carácter de ‘A’ a 'Z‘, o un
vector de ristras de rango natural de l a lO, sólo tendremos que cambiar las apariciones de los
elementos enumerados en la cláusula sea. De hecho, hay lenguajes de programación en los
que dichos cambios pueden hacerse de manera automática o semiautomática; pero aunque no
ﬁiese así, los algoritmos genéricos tienen un papel que jugar en la transmisión de soluciones

con un amplio espectro de aplicación.

40

Esquemas algorítmicos

Problemas de secuencias.

El tipo de problemas más frecuente con el que podemos enﬁentamos implica la



’ manipulación de una secuencia de valores de algún tipo (realizar el desarrollo en serie de una
función, poner las notas a los alumnos de una lista, calcular la raíz cuadrada de un número

.. i real por el método de Newtonjlaphson, facturar a una lista de clientes,...). Esta manipulación



puede requerir la generación de la secuencia o el recorrido de una secuencia almacenada en
t alguna estructura de datos, sin que ello implique ninguna diferencia sustancial en los
f esquemas algorítmicos a aplicar. En vista de ello, parece adecuado estudiar dichos esquemas,
k J ilustrando este estudio con ejemplos de su aplicación a problemas diversos.
A? Podemos entender una secuencia como un conjunto de elementos que se acceden uno
a uno, empezando por un elemento inicial, al cual le sigue otro, y a éste otro, y así

sucesivamente hasta llegar al último —la secuencia debe ser ﬁnita. Un simil muy utilizado




para explicar esta forma de actuar consiste en decir que los elementos se ponen en ﬁla y se

‘ los hace ir pasando por delante de una ventana cuyo tamaño sólo permite ver un elemento



Í cada vez. En un momento dado, hay un subconjunto de elementos que ya han pasado, uno y



’ ‘i sólo uno que es el actual —vísible en este momento— y otro subconjunto que está por venir.



- s,s,...s,,¡ ,s,.,...s,,

Pasado Actual Pendxente

De esta manera el problema de tratar un conjunto de elementos se divide en dos
subproblemas mucho mas sencillos: que’ hacer con el elemento "actual" y (una vez hecho)

cómo "avanzar" en la secuencia para "ver" el siguiente elemento. Las acciones para resolver



¡J i ambos subproblemas se repiten hasta alcanzar el último elemento de la secuencia. ¿Cómo
y / saber que ha pasado el último elemento? Depende de las caracteristicas de la secuencia:

l l‘ , . , . ,
u“ , ¿dpodriamos hablar de secuencias marcadas y de secuencias numeradas. En las segundas, se
r v‘



' x

. - Í . . .
conoce a priori el numero de elementos y para saber que se han tratado todos sólo hace falta
contar; en las primeras, sin embargo, el número de elementos es desconocido a priori y el

ﬁnal se determina por una marca o valor especial que sigue al último elemento o está



asociada a él.

41

Esquemas de generación y recorrido.

, Según lo descrito, el acceso secuencial a un conjunto de elementos conlleva una
inicialización que nos sitúe en el primer elemento, un avance que nos dé acceso al siguiente y
o r c  » L i una evaluación que nos pennita saber cuándo hemos llegado al ﬁnal de la secuencia, ta] como

Se muestra en el siguiente esquema:



iniciar
mientras no ﬁin hace:
avanzar
Ein mientras

i‘ Secuencia aleatoria. o
El esquema de generación secuencial más simple ocurre cuando cada elemento de la

» ' ' ' ‘L secuencia es absolutamente independiente de factores asociados a la secuencia —su valor no



7 .
al, K se ve inﬂuenciado, ni por otros elementos de la secuencia, ni por su posición en la misma. Un

l ik ejemplo podria ser el siguiente trozo de algoritmo que va leyendo una serie de números hasta



‘que el usuario teclea un cero:

leer x W Iniciar E leer x
mientras x # O hace: ‘C Ein E lx = D)
leer x IV Avanzar s leer x

Ein mientras

z
"I" t El principal problema es que si los sucesivos valores son realmente aleatorios, no hay



nada que garantice que va a llegar a cumplirse la condición de ﬁnalización de la secuencia.



n. . r. mu.

j > Secuencia en que cada elemento depende del anterior.

K Cuando la secuencia no es aleatoria, el valor de cada elemento se halla en relación con

l .
i’ ' su posición en la secuencia. De las posibles dependencias, podemos considerar la más simple:




 aquella en la que cada elemento evoluciona a partir del que le precede. Es requisito
K indispensable que exista un valor inicial independiente a partir del que se desarrolla el resto:
S¡::u
Si = F(Sl-|)

42

ïjhonnmmmmnmnnn...nganan--------------------------

El esquema para obtener este efecto implica la inicialízación de la variable que
representa el elemento actual de la secuencia con el valor inicial y un bucle para su
actualización según la función de dependencia, la cual se supone que debe conducir al
cumplimiento de la propiedad de ﬁnalización:

¿"L a
mientras no Fin(x) hace:

x e F‘(x)
Ein mientras

Siguiendo este esquema, el siguiente trozo de algoritmo "desgranzﬂ la secuencia de
los M primeros números naturales:
n e o
mientras n < M hace:

n “ n + 1
fin mientras

El ejemplo se puede generalizar para cualquier secuencia de un tipo ordinal:

n e 0K
mientras n S B hacer

n e Sucesorm)
ﬁin mientras

Secuencias controladas por otras secuencias.

Los esquemas de conteo, como los de los ejemplos anteriores son muy útiles en el
control de la creación y recorrido de secuencias, hasta tal punto, que se incorporan como una

sentencia de control especíﬁca, la repetitiva controlada por contador:

n? a 5;. n desde oz hasta La hace:

mienttn n s B hace: .- -
_ _ _ fin para

n k Sucesorln)
Ein mientrnn

Una forma de ejercer este control puede ser "forzar" la tenninación de una secuencia
tras un número detemtinado de iteraeiones, si no se han alcanzado antes otras condiciones de

ﬁnalización:
43

leer x
n v 1
mientras lx s o) y (n < 10o) hace:
leer x
n «e n + 1
ﬁin mientras

De hecho, pueden llegar a sustituir completamente a otras condiciones de ﬁnalización,
como en los siguientes ejemplos —se convierte en una secuencia numerada en vez de

marcada:

algoritmo Multiplica algoritmo factorial
vnrisblas naturales M1, M2, p, c variables naturales n, r, 1

escribir "Multiplicandoz" escribir "déme un valor natural: "

leer M1 leer n

escribir "Multiplicador=" f z: 1

leer M2 pura i desde n hasta 2 pase -1 hace:
P ‘r O f 4* f * i

para C desde 1 hasta M2 hacer Ein para

P ‘r P + M1 escribir "el factorial es: ", f

fin para para:

escribir "el producto es: ", P fin algoritmo

parar
f in nluoti cmo

También se pueden usar algoritmos de conteo para generar secuencias cuyos
elementos dependen de su posición. El siguiente algoritmo genera y escribe los cuadrados de

los primeros n números naturales:

algoritmo Cuadrados
variables naturales i, n, C
escribir "déme un valor natural: "
leer n
para i desde 1 hasta n hace:

c r í * i

escribir c
fin para
para:
un algoritmo

Generalizando el concepto de posición, podemos hablar de secuencias que se generan

bajo el control de otras, como en el siguiente esquema:

x e a Iniciar controladora
mientras no Fin(x) hace: mientras no Fin hace:

y e G(x) Obtener controlada

x <- mx) Avanzar controladora
un migntrgg fin mientras

44

Aﬂﬁ-IQQQIQQQDQJQQQIQ.-.nan.nnnnqnnnnnonnAgQQQQAQQQQQI

Que se use una sentencia de control "mientras", como en este esquema, o una
sentencia "para“, como en los ejemplos anteriores, depende de si la secuencia de control

responde, o no, a un algoritmo de conteo.

Esquemas de recorrido.

Cuando la ﬁmción generatriz de una secuencia consista en acceder a un componente
de una estructura en la que se hallan almacenados los elementos que la forman —como en el
siguiente trozo de algoritmo, donde la variable x toma sucesivamente los valores guardados
en un vector— parece más propio hablar de algoritmo de recorrido que de algoritmo de
generación, aunque es una distinción puramente nominal:

¿QA i donde 1 hasta n hace:

x * Vli]
Ein para

Esquemas de tratamiento.

Sabemos como generar o recorrer una secuencia de elementos; pero ¿para que’?, lo
normal es que queramos hacer algo con los elementos obtenidos. Probablemente pretendemos
aplicar algún tratamiento a cada uno de los elementos de la secuencia o, al menos, a algunos

de ellos.

Tratamiento de todos los elementos.

Empecemos por el caso más sencillo: aplicar un tratamiento a todos los elementos de

una secuencia. Si suponemos que una secuencia autogenerada responde al esquema general:

iniciar
mientras no fin hlcar
avanzar
Ein mientras

45

resulta obvio que el tratamiento de cada elemento debe realizarse al principio del bucle, justo
antes de avanzar, con lo que obtenemos un primer esquema general de tratamiento:

iniciar
mientras no fin hace!‘
tratar
avanzar
Ein mientras



que es precisamente lo que se hace en los siguientes algoritmos que escriben los n primeros

números positivos:

procedimiento Escribem)

variables entrada natural N
local natural i

para i desde 1 hasta N hace:

procedimiento Escribem)
variables entrada natural N

local natural i
i « 1 (Iniciar)

mientras i s N hacer escribir i
escribir i {Tratar} fin mientras
i e i + 1 (Avanzar) 1930133!

Ein mientras fin procedimiento

ZGÉOIDII
tin procedimiento

Si la secuencia generada o recorrida lo es bajo el control de otra, el tratamiento se
puede hacer, preferentemente, en cuanto se pueda obtener el elemento, si bien podria diferirse

hasta después de avanzar la secuencia de control:

xkor x<-a

mientras no Fin(xl hacer mientras no Fin(x) hace:
y °' Glx) Y “ Glx)
Tratauy) x k Flx)
x ‘ F(x) Tratarw)

fin mientras Ein mientras

Lo vemos en el siguiente ejemplo que escribe los n primeros elementos de un vector:

procedimiento EscribeVÜLN) procedimiento BscribeV(V,N)
variables entrada natural V[50] ,N variables entrada natural V[50] ,N
local naturales x, i local naturales x, i

i e 1 para i desde 1 hasta N hacer
mientras i s N hacer x := Vli]
x .. vri] escribir Vli]
fin mientras

escribir x
i e i + l
Ein mientras
retornar
iin procedimiento (l) (2)

IGCOÍDBX‘
fin procedimiento

46

Pï°°°dimï°nt° Escïïbwivr“) (Las dos primeras versiones
variables entznda natura]. V[S0].N son la misma en Cuanto a

local natural x, i , . . .
esquema, s1 blen, cambia el tipo de

i « 1
sentencia de control utilizada)

mientras i s N hace:
x e V[i]
i « i + 1
escribir x
Ein maneras
retornar
un procedimiento (3)

Este ejemplo tiene la particularidad de que si existiese la garantia de que N es mayor o
igual a uno, se podria pensar en la generación de la secuencia de pares (i,V[i]), en vez de, en
el recorrido de la secuencia de valores de V[i] bajo el control de la secuencia de valores de i,

con lo que la solución podria eneqiarse en el primer esquema de tratamiento:

procedimiento EscribeV(V,N)
variables entrada natural VISO] ,N
local natural X, i

i e 1 ‘¡Iniciar

x * V[i]

mientras i s n hace:
escribir x _ u-Tratar
í e i + 1 "¡Avanzar
x * V[i]

Ein mientras

retornar

E in procedimiento

Es posible encajar cualquier secuencia en este esquema si es legal obtener el primer
elemento sin haber evaluado la condición de ﬁnalización (de ahi la exigencia de que N sea

mayor que cero en el ejemplo):

x k u Dlniciar
y e GKK)

mientras no Fin(xl hace!
Tratarly)

x k F(x) ‘Avanzar
Y * Glx)
Ein mientras

47

Tratamiento de todos los elementos que cumplen una propiedad.
Si lo que queremos es tratar sólo los elementos de la secuencia que cumplan una

detenninada propiedad, basta con encapsular el tratamiento en una estructura altemativa:

iniciar x

mientras no fimx) hacer
s1 P(x) entonces tratara) fin s1
avanzarlx)

Ein mientras

Esto es lo que hace el siguiente algoritmo diseñado para escribir los números primos

comprendidos entre l y N:

procedimiento EscribePrimosﬂi) función lógica Primo(p)
variables entrada natural N variables entrada natural p
local natural i local natural d
i k 1 s1 (p s 2) y (p mod 2 : 0) entonces
mientras i 5 N hacer devolver falso
si Primoti) entonces s1 no
escribir i d v 3
“n B¿ mientras (d < p) y (p mod d r
iki+l omnes: d+d+2
tin "dancing Ein mientras
retoma: si d < p entonces
fin procedimiento “°"°1"“ E31“
s1 no
devolver verdadero
Ein si
Ein si
Ein función

El siguiente algoritmo determina el valor máximo de los elementos de un vector —se
supone que, por lo menos, hay un elemento. En este caso se tratan aquellos elementos que
sean más grandes que el mayor encontrado hasta el momento, y el tratamiento consiste en

guardarlos en una variable que representa el mayor valor encontrado.

función real Máximo(V,N)
variables entrada natura]. N

real V[50]
locales natural i
real Max
Max e V[1]
i 4* 2

mientras i s N hace:
si V[1] > Max entonces
Max k Vli]
fin ¡i
4B

¡ﬂuﬁﬁﬁﬁﬁﬂﬂﬂﬂﬁﬁﬂﬂﬁﬁﬂﬁﬂﬂﬂﬁﬂ
nnnnnnnnnnnnnnnnnanl!¡QQID!
Qﬂll

i «e i o 1
fin mientras
devolver Max
Ein función

Tratamiento del último elemento de una secuencia.

Si la propiedad que hace que un elemento sea tratado es ser el último, el bucle de
recorrido tiene que limitarse a avanzar hasta que se consiga acceder a dicho elemento,
momento en el que se realizaría el tratamiento, ya fuera de la estructura repetitiva: esto es lo

que ocurre, por ejemplo, en el algoritmo que escribe el factorial de un número:

algoritmo factorial
variable: naturales n, f, i
escribir "déme un valor natural: "
leer n
f e’ 1
pan 1 desde n hasta 2 puso »1 hacer
E 4’ f * i
un para
escribir "el factorial es: ", f
pue:
un algoritmo

Tratamiento del primer elemento que cumple una propiedad (esquema de
busqueda).

Supongamos que lo que queremos es tratar el primer elemento dc una secuencia que
cumple una detenninada propiedad, si es que hay alguno. Necesitamos un esquema de
recorrido modiﬁcado con una condición adicional para detenemos si se encuentra el elemento
y, una vez producida la detención, evaluar si ésta se ha debido a que se ha encontrado un
elemento con las caracteristicas buscadas —en cuyo caso hay que tratarlo—- o a que se ha

acabado la secuencia. El resultado es lo que se conoce como esquema de búsqueda:

<Inicialízaciones>
mientras <no se alcance el fin de la secuencia a explorar> y
<no se halla encontrado un elemento que cumpla la propiedad> hacer
<Avanzar, accediendo al siguiente elemento>
Ein mientras
al. <se ha encontrado un elemento que cumpla la propiedatb entonces
¿lociones a tomar cuando se halla el elemento buscado>
si no
<Acciones a tomar cuando no se halla el elemento buscado>
Ein ni

49

La función lógica para determinar si un número es, o no, primo que hemos visto,
responde a un esquema de búsqueda: un número no es primo si es divisible por cualquier otro
mayor que uno —y menor que élA, por tanto, lo que se hace es buscar si es divisible por
algún número de la secuencia comprendida entre 2 y el predecesor del número que se está
evaluando —lo que equivale a que el resto de la división sea cero. Como la mitad de los
números de esa secuencia son pares, se extrae la comprobación de si es divisible por 2, y lo
que queda es una búsqueda en la secuencia de impares resultante. El bucle de búsqueda está
controlado por una doble condición: "no ﬁn" (d < p) y "no encontrado" (p mod d a 0), lo que

obliga a comprobar luego cuál ha sido la condición de salida.

función lógica Primolpl
vaziablesentrada natural p
local natural d
a1 (p » 2) Y (p mod 2 i D) entonces
devolver falso

a1 no
d * 3
miantras (d < p) y (p mod d e mhacer
d * d + 2

Ein mientras
si a < p entonces
devolver falso
si no
devolver verdadero
Ein al
Ein ui
tin función

Combinación de esquemas.

En resumen, si los elementos de un problema se pueden identiﬁcar como una
secuencia —cosa que ocurre con la mayoria de los problemas que pretendamos resolver con
un ordenador de arquitectura "tradicional", dado que esta consiste básicamente en un
procesador secuencial—, se resuelve mediante una de las múltiples variaciones de un
esquema básico de generacion/recenido-tratamiento (lo llamaremos esquema de recorrido). de
entre las que destaca el que hemos denominado esquema de búsqueda, sobre el que, a su vez,
se podrian plantear variaciones. Las diversas variantes tienen que ver, sobre todo, con el tipo
de secuencia —conteada, marcada, con marca despues de o en el último elemento, etc.— que
mejor se pueda identiﬁcar en un problema concreto. Todo esto lo hemos visto para problemas
relativamente simples; pero lo interesante es que cualquier problema, sea cual sea su nivel de

complejidad, puede desglosarse en una composición de problemas más simples, con lo que,

50


Ijnrrttrttrnrmntrrooorrprrmvtvnnovnervl

en última instancia, podria resolverse combinando variantes de los dos esquemas básicos
nominados (recorrido y búsqueda). La composición de dos esquemas sólo puede ser de dos
maneras: secuencial o anidada. En el primer caso, un esquema sigue al otro, en el segundo,
uno está embebido dentro del otro —puede realizar la función de avanzar, tratar, evaluar las
condiciones de ﬁnalización, etc. La composición de múltiples esquemas no es más que la

extensión de lo anterior. Los siguientes ejemplos ilustran algunas posibilidades.

Ejemplo: algoritmo de ordenación por selección.

El metodo de ordenación por selección de una secuencia consiste en recorrerla
parándose en cada posición para elegir el elemento de la secuencia que debe ocupar esa
posición para que resulte ordenada. La búsqueda del elemento candidato debe efectuarse
siempre recorriendo la subsecuencia que empieza a partir de la posición actual, ya que, las
posiciones anteriores ya habrán sido ocupadas por los elementos adecuados cuando se pasó
por ellas. Cuando se encuentra el candidato adecuado, simplemente se intercambia con el

elemento que ocupa la posi ión actual:

3599237154 <> ogsszequ ca 0139287554 d) 012237554 w
0123387561 :> 0123457559 :9 012345199 =:> ouussgs co
01234557Q e) 0123456789

El siguiente algoritmo aplica el método a la ordenación de un vector de números

enteros:

procedimiento ordenselecciónﬂhNEleml

variables
entrada entero NElem {N° de elementos del vector)
entrada/salida entera V[50] {Vector a ordenar}

locales enteras ActuaLAux,Poscandídatcncomodín
{Recorrido del vector} ,
para Actual donde l hasta NEIem __ 1 hace:

(Búsqueda del mínimo a partir de la posición actual)

Poscandidato " Actual

para Aux desde Actual + 1 halta NElem hace:

si V[Aux] < vlPoscandidatol entonces
Poscandídato ‘> Aux
Ein ai
Ein para
{Una vez localizado el elemento que debe ir en 1a posición actual
se intercambia con el que 1a ocupa }

Comodín r vlActuall

Vmctual] h vlPoscandidato]

Vllïoscandidato] t’ Comodín
ﬁn para
retornar
un procedimiento {Ordenselección}

5|

Podemos observar el anidamiento de los dos esquemas de recorrido. El esquema
extemo recorre las distintas posiciones del vector para situar en ella el valor más adecuado;
éste se localiza aplicando el esquema intemn al subvector comprendido entre la posición

actual y el ﬁnal.

Ejemplo: esquema de melcla.

supuestas dos secuencias ordenadas, se pueden juntar en una tercera secuencia
también ordenada. Una forma de hacerlo es recorrer las dos secuencias originales, copiar en
cada iteración el elemento menor —«ie entre los "actuales" de ambas— a la nueva secuencia
y avanzar sólo en la secuencia cuyo elemento se ha copiado. Cuando una de las dos
secuencias se acabe, basta un esquema de recorrido para copiar el resto de la otra.

El siguiente algoritmo aplica el método para mezclar dos vectores de enteros:

procedimiento Mezcla (V1,V2,V3,NurnElem1,NumE1em2)
variables
entrada enteras v1[5o], v2[5o], NumEleml, NumBIemZ
salida entera v3[50]
locales enteras Actua11,Actua12,Actua13
Accuall e 1
Actualz e 1
Actual} e 1
mientras Actuall s NumE1em1 y Actual2 s Nummemz hacer
si v1 [Actuall] < V2[actua12] hacer
v3 [Actual3] e V1 [Actuall]
Actual]. «e Actuall + 1
si no
v3 [Accuala] e V2[ACtual2]
Actual2 v Actualz + 1
Ein si
Actual} e Actual} + 1
ﬁn mientras
s1 Actuall g nuunmem entonces
nientrnn Actuall s NumElernl hace:
V3[Actua13] + v1 [Actuall]
Actuall e Accuall + 1
Actual} e Actua13 + 1
fin mientras
51 no
mientras Actualz s NumEIemZ hacer
v3 [ActuaD] e’ v2 [Accualz]
Actua12 e Actua12 + 1
Actual} <— Actua13 + 1
fin mientras
tin si
IQIDIÏDRZ
un procedimiento

52

ÜVVTTÜIHllllllllnbutubbmtuuH¡HunnunlHTTTI

El primer bucle enmascara un triple recorrido sincronizado. Las condiciones de
contro] se reﬁeren a Vl y V2, pero la última sentencia es claramente un avance en V3; por lo
tanto, estamos ante un esquema de generación de V3 a partir de Vl y V2. La parte de
tratamiento de este esquema conlleva elegir el elemento adecuado y avanzar en Vl o V2,
según de dónde provenga éste. Los dos esquemas de recorrido ﬁnales son excluyentes: sólo
se sale del primer bucle cuando uno de los vectores se acaba y, por tanto, sólo puede haber
uno que tenga elementos pendientes de copiar en el vector de salida. La estructura de

seleccion que los encierra refuerza esta percepción, aunque no es estrictamente necesaria.

Conclusión.

Los dos ejemplos mostrados ilustran las dos fonnas de composición de esquemas
mencionadas previamente —anidada o secuencial. La conclusión del capítulo es que, para
cualquier problema resoluble por un ordenador, existe un algoritmo que no es más que la
composición de un conjunto de esquemas algnritmieos simples. Este algoritmo se puede
encontrar analizando el problema e intentando identiﬁcar los sucesivos esquemas implicados.
en un nivel de complejidad descendente, hasta ser capaz de describir el método de solución

en base a esquemas simples e instrucciones básicas.

53

ü“‘}))ÍÍblIIIIIIDIDDDDDDUDDUDDDIU¡»IIterritorios)»I¡r

Metodologías de diseño de algoritmos

Metodología de diseño descendente.

Estructura delos problemas.

La mayoria de los problemas que resolvemos con un ordenador no tienen una solución
inmediata. Afortunadamente, cuando un problema complejo se examina con detalle suele
mostrarse rápidamente como una combinación de subproblemas más sencillos, aunque no
necesariamente simples. Ello es lo que da validez como metodologia de diseño de algoritmos
a la técnica que se conoce como diseña descendente, y que consiste en dividir un problema
complejo en subproblemas más asequibles, que se resolverán por separado, obteniéndose la
solución del problema global como combinación de las soluciones de sus subproblemas
constituyentes.

En las sucesivas etapas del diseño, cada subproblema es examinado a su vez y
subdividido en subproblemas aún más simples. La subdivisión debe continuar hasta alcanzar
el nivel de problemas “e|ementa|es", entendidos como aquellos que son resolubles
directamente por instrucciones del procesador para el que estamos diseñando el algoritmo;
aunque puede no ser necesario llegar a ese nivel dc simplicidad si previamente nos
encontramos con un subproblema cuya solución ya conocemos; aqui la experiencia del

programador y su capacidad de reconocimiento de patrones frecuentes resulta decisiva.

Desarrollo de un diseño descendente.

Como ejemplo para ilustrar la aplicación de esta metodologia supóngase que se tiene
un vector ordenado de enteros y se desea desarrollar un procedimiento para insertar un valor

de fonna que se mantenga el orden entre los elementos.

Del estudio de lo enunciado puede deducirse un prototipo de interfaz para el

procedimiento:

procadimianto Insertar(V,N,E)
variable entrada/salida entero vt?) /VecCor ordenado de enteros,
natural N [Número de elementos en v.

entrada entero E [Elemento a insertar en v.

55

Se detectan dos aspectos que no están deﬁnidos en el enunciado y que es necesario
aclarar para tener una especiﬁcación correcta del problema que se quiere resolver antes de
seguir adelante —si se parte de una especiﬁcación mal entendida luego se tendrá que
deshacer el trabajo y costará más. cuanto más se haya avanzado-a el primero de estos
aspectos es cuál sera’ el número máximo de elementos del vector —se necesita a la hora de
ÍÏCÜJBÏQÜKÏ’. el segundo es si los elementos del vector son todos distintos o puede haber
repetidos.

La respuesta a la primera pregunta tiene como consecuencia una restricción de las
condiciones en las que funcionara el algoritmo a desarrollar: si, por ejemplo el número
máximo de elementos es 100 y N, la variable que indica el número actual, ya vale l00, no se

puede pretender insertar un nuevo valor.

procedimiento Insertar(\l,N,E)

variable entrada/salida entero V[100] /Vector ordenado de enteros.
natural N ﬂvﬁmero de elementos en V.
entrada entero E [Elemento a insertar en V.

{N debe ser menor que 10o)
{N quedará incrementado en 1,- E quedará incluido en v en la posición
adecuada}

La respuesta a la segunda pregunta también tendrá consecuencias: tanto si es "sí"
(puede haber repetidos) como sí es "no" (son todos distintos) habra’ que tenerlo en cuenta en
el desarrollo posterior; supondremos que la respuesta es "no". Empecemos a plantear este
desarrollo; tenemos que: l) hay que poner un elemento en una posición de un vector y 2)
dicha posición debe conocerse antes de poder poner el elemento en ella; luego lo primero que
debe hacer nuestro procedimiento es: dados el vector y el elemento, encontrar la posición que
debe ocupar el elemento en el vector.

Centrémonos en el problema de localizar la posición de un elemento en un vector;
podemos plantear una función para resolverlo que en principio necesitaria los mismos
parámetros que la inserción:

función natural BuscarPcsicíón (V.N,E)

variable antrndn entero vuoo] [Vector ordenado de enteros.
natural N [Número de elementos en v.
entero E /E1emento cuya posición se busca.

Para desarrollar esta función necesitamos estudiar los posibles casos: el vector puede
estar vacío —N vale cero— o no estarlo. Si está vacio la solución es simple: E deberia ir en la

primera posición.

S6

UEIIIIlllll¡ÏÏH|ll‘l\l\\\|\\Í\ll|lll

función natural BuscarPosicíónﬂhNJs)
variable entrada entero vlloo] {Vector ordenado de enteras.
natural n [Número de elementos en v.
entero E /Elemento cuya posición se busca.
s1 N = o entonces
devolver 1
si no
fin si
fin función {BuscarPosición)

Una solución cuando el vector tiene elementos puede ser ir comparando E con cada
elemento del vector —empezando por el primero— hasta encontrar uno que sea mayor que E
—entendemos que en un vector ordenado un elemento debe ir detras de los que son menores
que él: se puede hacer con un bucle, pero hay que tener en cuenta que E puede ser mayor que
todos los elementos que ya están en V, en cuyo caso se alcanzmla el ﬁnal del vector y habría

que dejar de comparar e indicar que E va en la posición N + 1.

función natural BuscarPosiCiónlVJLE)
vlnzlable entrada entero V[100] [Vector ordenado de enteras,
natural N [Número de elementos en V.
entero E [Elemento cuya posición se busca.
local natural Aux [Variable para recorrer v.

si N = 0 entonces

devolver 1
si. no

Aux ' l

mientras (Aux s N) /\ (V[Aux] < El hace‘:

Aux " Aux + 1

ﬁn mientras

devolver Aux
fin si
un función (BuscarPosición)

Podemos ver que el caso particular de que el vector este’ vacio puede englobarse
fácilmente en el caso general (se inicializa Aux a l, como N vale cero no se entra en el

mientras y se devuelve Aux, que es l); es una fonna de simpliﬁcar el algoritmo.

función natural EuscarPosící6nlV,N,El
variable entrada entero V[100] [Vector ordenado de enteros.
natural N [Número de elementos en V.
entero E [Elemento cuya posición se busca.
local natural Aux [Variable para recorrer V.
Aux ‘r 1
mientras (Aux s N) /\ (V[Aux] < E) hace:
Aux " Aux + 1
fin niantta!
devolver Aux
Ein función (suscarPcsicióx-i}

S7

Resuelto el subproblema dc la búsqueda, de momento tenemos:

procedimiento Insertar(V,N,E)
variable entrada/salida entero VIIÜO] [Vector ordenado de enteros.
natural N [Número de elementos en V.
entrada entero E {Elemento a insertar en V.

(N debe ser menor que 10a}
{N quedará incrementado en 1,- 12 quedará incluido en v en la posición

adecuada)
local natural P [Posición en que se debe insertar E en V.

P - EuscarPosiciónÜlJLE)

En principio hay que insertar E en la posición P, pero debemos recordar que no se
deben insertar elementos repetidos: si V[P] = E no hay que hacer nada puesto que el elemento

ya está en el vector —siempre que P sea menor o igual que N:

procedimiento Insertar (v, N, E)
variable entrada/salida entero vuoo] [vector ordenado de enteros.
natura]. N [Número de elementos en V.
entrada entero E [Elemento a insertar en V.

{N debe ser menor que 10o}
{N quedará incrementado en 1,- E quedará incluido en v en la posición

adecuada}
local natural p [Posición en que se debe insertar a en v.

P ' BuscarPosicíón(V,N,E)
si (t? s N) /\ (V[P] s EH V IP = N+1l ‘entonces
(Hay que insertar, si no, no se hace nada}
fin si
retornar
un procedimiento {Insertar}

Si P es mayor que N o V[P] es distinto de E es necesaria una asignación (V[P] k E),
pero no se puede hacer sin más: si P no es igual a N + l —esto incluye el caso de que V esté
vacio— habrá un elemento en la posición P que no puede perderse: al insertar E en la

posición P el elemento que actualmente la ocupa debe pasar a la P + l, pero entonces el que

ocupa la P + l debe pasar a la P + Z, y así hasta el último. que debe pasa: ala N + l.

5:22 N=s
Pili,” "EME,

' Posición donde debe insertarse E

Para desplazar los elementos desarrollaremos un procedimiento según la siguiente

interfaz:

procedimiento Desp1azar(V,N,P)

variable entrada/salida entero V[100] /VecEor ordenada de enteros.
entrada natural p [Posición a despejar.

natural N [Número de elementos en V.
{N debe ser menor que 100,- 9 debe ser menor o igual que N}

58

El problema se puede resolver mediante un huele que recorra la porción del vector
comprendida entre P y N copiando cada elemento en la posición siguiente; hemos de ﬁjamos
que ese bucle tiene que empezar por el ﬁnal e ir retrocediendo de fonna que lo primero que
se haga sea copiar V[N] en la posición V[N+l], y lo último copiar V[P] en la posición l’ + l;
si el bucle fuese ascendente, sólo se conseguiría copiar V[P] en todas las posiciones hasta el

ﬁnal del vector:
ptocadiniento Desplazarﬂ/JLP)

variable entrada/salida entero vnuu] [Vector ordenado de enteros.
entrada natural p [Posición a despejar.
natural N [Número de elementos en v.
{N debe ser menor que 100;? debe ser menor o igual que n}
local natural Aux [Variable para recorrer V.

para Aux desde N hasta P paso -1 hacer
vlAuxul r vlAux]
fin para
retorna:
fin procedimiento {nesp1azsr}

Nótese que, aunque se especiﬁca que l’ debe ser menor o igual que N —en otro caso
no hay que hacer desplazamíento—, en realidad el algoritmo no falla si no es así —se limita a

no hacer nada. Al incluir el procedimiento Desplazar la inserción quedaría:

procedimiento Insertar(V.N,E)

variable entrada/tanda entero vuoo] (vector ordenado de enteros.
natural N /Número de elementos en v.
entrada entero E {Elemento a insertar en V.

{N debe ser menor que 10o}
(u quedará incrementado en 1,- E quedará incluido en v en la posición

adecuada)
local natural p [Posición en que se debe insertar s en v.

P e BuscarPosicíónWJLE)
si ((13 s N) A (V[P] s 3)) V (P = N41) entonces
{Hay que insertar, si no, no se hace nada}

si P s N entonces [se abre hueco para E.
Desp1azar(V,N,P) '
tin si
V[P] e E [se inserta E en V.
N o N + 1
ﬁin Ii
IBCOÏDI!

fin procedimiento {Insertar}

Lo que obtenemos al aplicar la metodología de diseño descendente es una
descomposición jerárquica de la estructura del problema a resolver en subproblemas más
sencillos en cuya solución nos centramos por separado. En este caso hemos seguido un orden

de resolución "en profundidad" —cada subproblema se resuelve antes de pasar al siguiente»

S9

pero también seria válida una aproximación "a lo ancho" —identiﬁcar todos los

subproblemas de un mismo nivel de complejidad antes de empezar a resolverlos.

Heuristica de anális



Una parte del éxito del diseño descendente depende de la experiencia del
programador, de su capacidad de reconocer patrones frecuentes y de buscar subproblemas de
fonna adecuada. Un método que puede resultar útil es aplicar una heurístiea basada en el
lenguaje natural: sabemos que un verbo representa una acción y que un nombre representa
una entidad (en nuestro caso infonnación) que puede estar cualiﬁcada por adjetivos; asi la
frase: "Insertar un elemento en un vector ordenado" indica una acción ("insertar") que
implica dos entidades ("elemento", que es su objeto y "vector ordenado" que es un
complemento de lugar). Si tratamos de explicar el problema con mayor detalle, podríamos
emplear una frase como: "Buscar la posición adecuada e insertar el elemento en esa
posición"; es una sentencia compuesta en la que podemos identiﬁcar dos acciones: "Buscar" e
"Insenar".

La acción "Buscar" tiene como objeto "la posición adecuada" y como complementos
(implícitos) "del elemento en el vector" podemos desarrollarla como: "Partir de la posición
uno del vector y avanzar a la siguiente mientras queden elementos por examinar y el actual
sea menor que E. Devolver la posición de parada". Encontramos cinco verbos, pero sólo los
tres inﬁnítivos ("partir", "avanzar" y "devolver") denotan acciones primarias; las dos formas
del presente de subjuntivo ("queden" y "sean") establecen condiciones que, al ser evaluadas,
condicionan la acción de "avanzar" (subordinada al "mientras ..."). De las tres acciones
primarias: "Partir ..." se traduce en asignar el valor l a una variable índice, "Avanzar

es devolver el valor de la



consiste en incrementar en l la variable índice y "Devolver
variable índice; todas tienen, por tanto, traducción directa sin necesitar más
descomposiciones. En cuanto a la frase "mientras queden elementos por examinar y el actual
sea menor que E" denota un bucle "mientras" con una condición doble donde: "queden
elementos por examinar" debe entenderse como que "la variable índice sea menor o igual que
el número de elementos en el vector" y: "sea menor que E", tiene un signiﬁcado obvio.

La acción "insertar el elemento en esa posición" depende de si el elemento ya está, o
no. en ella, En la frase "si el elemento no está en la posición determinada" hay que realizar

tres acciones. una de ellas condicional: "s1 la posición está ocupada por otro elemento hay

60

l

que despejar]: y a continuación poner el elemento en su posición e incrementar el contador
de elementos del vector". El elemento "está" en la posición determinada si —siendo P la
posición y E el elemento —, P es menor o igual que el número de elementos y V[P] es ¡gral a
E. La posición "está ocupada" por otro elemento si, siendo falso lo anterior, "la posición es
menor o igual que el número de elementos". Para "despejar" una posición ocupada hay que

"desplazar todos los elementos desde la posición detenninada hasta el ﬁnd una posición a la

derecha" —aunque técnicamente hay que hacerlo "desde el ﬁnal hasta la posición
determinada". Llegados a este punto todas las acciones identiﬁcadas tienen ya traducción

directa en el lenguaje objetivo.

Propiedades del “buen diseño”.

Con la metodologia de diseño descendente cxaminamos un problema
descomponiéndolo en otros más simples atravesando múltiples niveles de abstracción
descendente. Ahora bien, en un nivel de abstracción dado ¿como debemos enfocar la
división? Naturalmente, no hemos de quedamos con lo primero que seamos capaces de
encontrar, sino que hemos de ir buscando que el diseño resultante cumpla la máxima de
“mantener la maxima cohesión y el minimo acoplamiento”. La cohesión y el acoplamiento
son medidas de la bondad del diseño. Si a un nivel detenninado de abstracción la división da
como resultado varios subproblemas de los cuales uno o más podrian dividirse en otros cuyo
nivel de abstracción no fuese signiﬁcativamente menor, entonces la cohesión interna de esos
subproblemas seria baja. Si entre varios subproblemas existe una ﬁierte interrelación, diremos
que el acoplamiento es alto.

Llevado esto al programa resultante, diremos que la cohesión es máxima si cada
módulo que lo constituye —procedimiento, ﬁmción, algoritmo,  resuelve una única tarea,
y que el acoplamiento es minimo si las dependencias mutuas entre módulos es la menor
posible (esto se traduce, por ejemplo, en que en las listas de parámetros no haya información
redundante, o en no usar variables globales).

Si una descomposición está bien hecha es posible cambiar la implementación de un
módulo mientras se mantenga intacta su interfaz. Así, por ejemplo, se podria utilizar el
método de la "búsqueda dicotómim" para realizar lo localización de la posición donde debe

insertarse el elemento, en el proceso de inserción ordenada.

6|

Cuando se hace una búsqueda secuencial en un conjunto de N elementos se empieza
comparando el valor a buscar con el primero del vector, si éste es menor que el que
buscamos. quedan N » l posibles candidams. Si la búsqueda es dicotómica, se empieza
comparando con el elemento que ocupa la posic n central del vector; si no coincide. los
posibles candidatos son N/2 —la mitad superior del vector si el valor es mayor que el central
o la inferior si es menor. La búsqueda continúa comparando con el elemento medio del
subvector correspondiente —cada comparación elimina la mitad de los candidatos
disponibles, mientras que en la búsqueda secuencial cada comparación sólo elimina un

candidato. Al ser las comparaciones mucho más efectivas el método es mucho más rápido.

función natural BuscarPosíción(V,N, E)

variables

entrada entero vuoo] [Vector ordenado de enteros.
natural N [Número de elementos en v.
entero E] /E1emento cuya posición se busca.

locales enteras LInf,LSup [Delimitan el subvector que se está tratando.
entera Medio [Elemento central del subvector considerado.

lógica Encontrado ¡cuando es Verdadera finaliza la búsqueda.

(Inicíalízaciones)

LInf «e 1

LSup -— N

Encontrado <- falso

mientras (Llnf s Lsup) /\ nouancontrado) hacer
{Cuando los límites se cruzan, se acaban los subvectores)
{El tratamiento consiste en examinar el elemento central}
Medio e ParteEnteraHLInf + Lsup) / 2)

si V[Medio] : E entonces
Encontrado ‘r verdadero
fin si

{Se avanza moviendo los límites, para considerar un subveccar más
pequeño}
si V[MediO] < E entonces
LInf k Medio + l
si no
LSup " Medio - 1
fin Si
fin mientras
Si. Encontrado entonces
devolver Medio
si no
devolver LInf
fin si
un función {EuscarPosición}

i I-Iﬁ É _
, 3.45 . :t3<_> _
tam. T oír. Si: z una... x...< al...

28.8 su Suns ,
5 w355»... B.
man img: ü 5mm;
. l: .035. m. n38





n 5 Dcscomposición desccndenw del problema "insertar un elemento cn un vector nrdenadn

2.38 s .125”...
. s z Á z
_ T151 noïas-zé...
_ a
> é «¿.55? ‘
_ s. 55...... ésa... .2 ¿c535 «E. _
E 355mb; gcu 22cm ﬂ 599cc: E ñ \ \ ‘ ‘ESE. E.
_ _ “l N‘ Ï5< .u..< .
‘ Ï‘ 13a.. _WV 7=<_>..>_zwÉ<. 2.3:: . ‘ 1x ‘
52225.72 u n. 3...4 .333: ‘ , W _ A 5.4
.:G.E.>::z....:. \ .
W ‘ , mas Éïiuïmaua :1. l
l N ¿caia s. _ .«.__ES..:.L 5.255s zonas... . 5.833. S!
.95 .88 oc u a coimas! 329.5 «EEB... 9.5:; n. m .352; . .. ES m. E. .._:.E .
l r \ l!‘ l.
55o“. MMO 5 , «musik ‘
35.5o.» 5.:... .323 m. ¡anna
‘ Í ‘ _
89.09.0252, :3 _

.5 3.521» .. n ¡tons “m

1\\ m

s

h

 ÉaaÉ»————————Pa‘

Desarrollo de soluciones recursivas.

Planteamiento.

No es raro encontrar funciones matemáticas cuya deﬁnición se construye empleando

la propia función que se está deﬁniendo:

Factorial
a ) l si n = 0
n :
n’f(n-l) sin 9€ 0
Fibonacci
l si n = 0
f(n) = lsin = l

mu) + f(n»2)\1n >1

Las funciones de este tipo decimos que tienen una deﬁnición recursiva, que expresa
mediante una fórmula de recurrencia una relación entre distintos términos de la funcion.
relación que pennite calcular unos términos a partir de otros. Se trata de una deﬁnición
operacional; si, por ejemplo, queremos calcular el factorial de 4, sabemos que tenemos que
calcular primero el de 3 y luego multiplicar por 4, pero para calcular el de 3 debemos calcular
primero el de 2 y multiplicar por tres, y para el de 2 calcularemos el de l y multiplicaremos
por 2‘ y el de l será el de 0 multiplicado por l. El de cero no depende de otros, y su valor es
l. que multiplicado por l da l, que multiplicado por 2 da 2. que multiplicado por 3 da 6. que
multiplicado por 4 da 24, que es el factorial de 4.

Si analizamos estas funciones desde la perspectiva (del diseño descendente) de
división de un problema en subproblemas más simples Ilegaríamos a la curiosa conclusión de
que se trata de un problema que se subdivide en problemas que son iguales que él, pero

aplicados a una entrada más pequeña.

64

mllllllllIllllntttbtwbbttwwuilninintnn)lsTrrm

l amar.)

l ,_l_
l rimnacata) I rvbonacaa) I

_,l ,> ,, I,
;



Ilnslracíón 6 Ejecución de Fibonacciﬂ)

También observamos que el dominio de estas funciones queda divido en dos
subconjuntos:
- casos que no dependen de otros para su cálculo, que denominaremos conjunto de
casos base (Vease cn la descomposición de la ﬁmción de Fibonacci cómo esos casos

quedan en la "base"; y
- casos que dependen de otros según lo establecido por la expresión de la recurrencia.

Toda deﬁnición recursiva bien formulada debe tener al menos un caso base, y la
recurrencia debe ser de tal naturaleza que su descomposición acabe conduciendo
necesariamente a alguno(s) de los casos base.

Los problemas con estas características no son exclusivos del campo de las funciones
matemáticas; por el contrario los podemos encontrar en muchas otras situaciones. Tomemos
como ejemplo el famoso enigma de las "Torres de Hanoi". Sin entrar en la leyenda, se trata
de resolver un problema en el que tenemos tres varillas en una de las cuales hay inicialmente
varios discos de distinto tamaño ordenados de mayor a menor. El juego consiste en trasladar
todos los discos a otra de las varillas, con la única restricción de que nunca se puede poner un

disco mayor sobre uno menor. Para conseguirlo hemos de ayudamos con la tercera varilla.

Í ' ' Il

srruAcIbN INICIAL SITUACION FINAL

Ilustración 7 Tona de Hanoi

65

Yendo, como siempre, por partes, podemos damos cuenta de que lo primero que
tenemos que consegrir es pasar el disco mayor desde el fondo de la varilla origen al fondo de
la varilla destino. lo cua] sería una cuestión trivial si ese ﬁrese el tínico disco que hay: como
normalmente no es así, hemos de resolver antes el problema de “quitar de en medio“ los
discos superiores, cosa que sólo podemos hacer llevándolos a la varilla intermedia.

La diﬁcultad estriba en que para apartar los discos superiores a la varilla auxiliar han de
respetarse las normas del juego, con lo que nos encontramos con el mismo problema que al
principio, sólo que con un disco menos y con las varillas auxiliar y destino intercambiadas. El
mismo problema que habrá que resolver una vez que el disco mayor haya ocupado su lugar
para pasar los restantes discos a la varilla destino. convirtiéndose ahora la inicial en intermedia.

En resumen, el problema se resuelve:

Si hay un sólo disco, pasándolo directamente a la varilla ﬁna].

Si hay N discos (N > l):
pasando N — l discos de la varilla inicial a la auxiliar, respetando las reglas del
juego
pasando un disco de la varilla inicial a la ﬁnal

pasando N — l discos de la varilla auxiliar a la ﬁnal, respetando las reglas del

juego

Podemos ver que este algoritmo sigue exactamente las mismas pautas que las
deﬁniciones de funciones matemáticas recursivas: existe un caso base y una recurrencia para el

resto de los casos planteada de forma que conduce al caso base preestablecido.



Cómo formular un algoritmo para un problema recursí

Una vez que el análisis nos ha conducido a una deﬁnicion recursiva de un problema, la
mejor táctica es la simplicidad: trasladar la deﬁnición del problema al algoritmo manteniéndola
en toda la medida que pennita la sintaxis del lenguaje utilizado. En nuestro caso eso signiﬁca
que tendremos un procedimiento o una función, cuya estructura general típica vendrá dada por
una estructura altemativa que separará los casos base de los casos generales recursivos. La
resolución de los casos recursivos implicará la aparición de llamadas al mismo Subprograma.

con nuevos parámetros.

66

función natural Factoríalm)
variable entrada natural N
local natural Resultado

a1 N < 2 entonces

Resultado <- l
si no

Resultado <- (N ‘r Factoría]. (N—1))
fin si
devolver Resultado
fin función {Factorial}

función natural FíbonaCci(N)
‘inﬂable entrada natural N
local natural Resultado
si N < 2 entonces
Resultado k l
a1 no
Resultado °
{in si
devolver Resultado
ﬁn función [Fibonacci]

(Fibonacci(N-1l"FibonaCCi(N»2)l

tipo Varillas es entero 1. .3 Ein tipo

procedimiento Hanoi (NumDis , VI , VF, VAux)
Variables antradn Positivo NumDis
Varillas vI, VF, VAux
si NumDis : 1 entonces
PasarUnDiscoWLVF)
ni no
Hanoi (NumDis—1,VI,VAux,VF)
Hanoi(1,VI,VF)
Hanoi (NuInDis-1,VAux,VF,VIl
fin si
retornar
nn procedimiento {Hanoi}

En estos tres algoritmos, que resuelven los problemas planteados previamente podemos

observar:

l. Que los tres tienen, como se había indicado, la misma estructura, basada en una
sentencia altemativa que diferencia el caso o casos base del problema, del caso general.

2. Que los tres empiezan resolviendo lo más fácil, los casas que corresponden a las

condiciones de base.

3. Que el caso general se descompone en varios casos más sencillos del mismo problema
y de una parte ——normalment.e-— no recuxsiva, que se componen entre sl para dar la
solución. Tanto la solución del caso base, como las panes no recursivas del caso general

pueden incluir las estructuras no recursivas que sean oportunas, dc acuerdo a su

{Llamada recursiva

(Llamada recursiva

¡Llamadas recursivas

complejidad, aunque esto no se vc en los ejemplos, dada su sencillez.

67

4. Que, en última instancia, la correcta solución del caso general depende de la correcta
solución del caso base, así como de la correcta formulación de la relación —
recurrencia— entre sucesivas instancias del problema Igual que en la inducción
matemática, podemos aﬁrmar que. si el problema está bien resuelto para el caso base y,
en el supuesto de estar bien resuelto para un problema de tamaño N, lo estará para un

problema de tamaño N+1, entonces está bien resuelto para todos los casos.

Cómo funciona la recursividad.

La forma más fácil de describir una llamada recursiva es decir que se trata de una
llamada "al mismo Subprograma", pero, ¿qué signiﬁca esto? No debemos olvidar que un
subpmgrama es un algoritmo y que la ejecución de un algoritmo da lugar a un proceso que se
desarrolla gobemado por ese algoritmo, en el sentido de que el procesador va siguiendo las
instrucciones escritas en el algoritmo para realizar las acciones del proceso. Cuando se produce
una llamada a un subprograma el proceso en curso queda momentáneamente suspendido, a la
espera de los resultados de un nuevo proceso independiente que es desencadenado por la
llamada. y controlado por el algoritmo del Subprograma. Esto sigue siendo cierto cuando se
trata de una llamada recursiva. Si se está ejecutando el algoritmo de cálculo de la función de
Fibonacci para el valor 4, cuando se encuentre la llamada a Fibonacci(3) se detendrá el proceso
en curso, se iniciará un proceso aparte que seguirá iguales reglas, y cuando éste tennine se
reanudará el proceso inicial en el punto donde se había parado. Si se encadenan varias llamadas
rccursivas —Fibonacci(3) llama a su vez a Fibonaccí(2), y esta a Fibonacci(l)— coexistiran
varios procesos, que responderán a idéntico algoritmo, pero que se encontrarán en diferentes
grados de ejecución. Se trata del "mismo Subprograma“ en la misma medida en que se puede
decir que dos cocineros cocinan la misma receta, estando uno en Bilbao y otro en Barcelona. y
cada uno con una copia de aquélla. De igual fonna, cada proceso está siguiendo en realidad su
propia copia del Subprograma.

En terminos técnicos, a cada proceso en ejecución le corresponde un registro de
acüvac/ón. que guarda información acerca de su estado —variables locales, dirección de retomo
cuando termine, parámetros, etc. En la mayoría de los lenguajes de programación, la ejecución
de un programa comienza cargando en memoria el registro de activación correspondiente a su
algoritmo principal. Si se produce una llamada a un subprograma, se traduce en la carga de un

registro de activación para cl proceso representado por ese Subprograma, en una dirección

68

UbillllllblllDDlI!lIDDDDlDDDDD¡lIlIDIIIIDIlliilllllllll‘!

inmediammente superior a las ocupadas por el registro del proceso principal. Si un
subpmgrama llama a otro (o a si mismo), se pone un nuevo registro de activación por encima
del suyo. De esta manera es como si los registros de activación se fuesen "apilando" en
memoria, de forma que el proceso activo es siempre aquél cuyo registro de activación se halla
en la "cima" de la "pila“, estando los demás activos. pero suspendidos. Cuando un proceso
acaba; se elimina su registro de activación, reanudándose la ejecución del que se encuentra
debajo de él, que ﬁJe quien lo llamó. La siguiente tabla muestra la evolución de procesos
dcscncadenados cuando un algoritmo principal se carga e invoca a] subprogmma que evalúa la
función de Fibonacci para el valor 3. El proceso activo en cada instante (Ti) es el que aparece

sombreado.

Flhoﬂ) Fih0(0)

Fiho(2) amm nus-xa) F|bo(2 ¡‘mom Fiba(|)

Flbo(3) ﬁboííi) FIbo(3) Fibo(3) F006) Filxxï!) HMC!) Fibc(3) Fibo(3)

Princ. Pnnc Princ Princ. Princ. Princ. Pnnc. Pnnc. PTÍHC. Princ. Princ.

T0 Tl T2 T3 T4 T5 T6 T7 T8 T9 T10 Tll Tl2

69

üvsTlTrTïñr InnnuruiuuttiunrrunnuunTrTrn-a

Ficheros

Concepto de ﬁchero.

Los algoritmos informáticos manipulan infonnación que es representada mediante
variables y constantes; hasta ahora no nos hemos ocupado de dos aspectos de la información
que, sin embargo, pueden ser muy relevantes: la caducidad y el volumen. Las variables tienen
una duración —conocida como "tiempo de vida”— limitada al período de ejecución del
bloque en que estan declaradas, pero determinadas informaciones pueden tener vigencia
mucho después de que acabe la ejecución del programa que las elabora por primera vez; por
ejemplo: si una gran empresa tiene que introducir las listas de empleados, clientes,
proveedores. articulos, etc., cada vez que arranca su programa dc gestión, no le quedará
tiempo para los negocios —y no se soluciona arrancando el programa de gestión sólo una vez
y dejándolo luego en ejecución pennanente con los ordenadores siempre encendidos: siempre
puede haber un corte de luz. Además, la cantidad de información que se puede almacenar en
variables en memoria RAM es muy limitado frente a las necesidades de algunas aplicaciones
—pensemos en el volumen de la información tributaria almacenada por el ministerio de
hacienda- debido a que la relación coste/almacenamiento de este tipo de dispositivos es
relativamente alta. Son necesarios dispositivos que pennitan {almacenar con un coste
razonable grandes volúmenes de información de forma pennanente y de tal manera que
pueda ser utilizada por diferentes programas o por un mismo programa en diferentes
ejecuciones; dispositivos de este tipo son los discos magnéticos, cintas, discos ópticos, etc..
—en todos estos dispositivos la información se organiza fumando unidades con nombre
propio llamadas ﬁcheros. La información en los ficheros se estructura en componentes o
registras que pueden ser accedidos individualmente —por "accedidos" entendemos que la
información de un componente de un ﬁchero puede copiarse a una variable (operación de
entrada) en memoria principal donde pueda ser manipulada o que el valor de una variable
pueda copiarse en una componente de un ﬁchero (operación de salida) para su
almacenamiento permanente. La información de un ﬁchero debe poder descomponerse en
unidades más pequeñas puesto que por vocación un ﬁchero tiende a representar volúmenes de

infonnación demasiado grandes como para poder cargarse completos en memoria principal.

7|

Clases de ﬁcheros.

Los ﬁcheros se pueden diferenciar según: (l) la forma en que se estructura la
infonnacion que almacenan, (2) el modo en que se puede acceder a esa información y (3) su
periodo de existencia.

Cuando hablamos de la estructura de un ﬁchero hemos de distinguir entre la estructura
lógica, que se reﬁere a como el programa “ve" el ﬁchero como un conjunto de componentes,
y la estructura ﬁsica, que alude a cómo la información se organiza en el dispositivo de
almacenamiento. Desde este punto de vista. un ﬁchero es una secuencia de bytes
posiblemente organizada en unidades superiores en función del tipo de dispositivo en que se
almacene. Desde el punto de vista lógico se distinguen poríuíestructura tres clases de
ﬁcheros: (l) ﬁcheros de componentes uniformes. (2) ﬁcheros de componentes m: uniformes y
(3) ﬁcheros de terra: En cualquier caso, puede entenderse como una secuencia marcada de

‘ datoskdue en última instancia se reduce a una secuencia marcada de bytes. La marca de ﬁn de
ﬁchero la abreviamos aquí con su acrónimo en ingles <EOF> —End Of File.

El programa interpreta la secuencia de bytes subyacente para acomodarla a los
distintos tipos de datos que para él conforman la estructura del ﬁchero.

Unfïitírggnifzïrne es una secuencia marcada de elementos que son todos del mismo

tipo, y, por tanto, ocupan el mismo número de bytes en el dispositivo de almacenamiento.

l,,,i {Mi i i V’ EOF

Ilustración 8 Estructura de un ﬁchero uniforme

Un ﬁchero nu uniforme se interpreta como una secuencia marcada de elementos que

pueden ser de distintos tipos, ocupando por tanto, cantidades distintas de espacio ﬁsico.

Ilustración 9 Estructura de un ﬁchero no uniforme

Los fïgﬁergzg de texto son una secuencia estructurada de caracteres; la estructuración
se consigue mediante marcas que son combinaciones especiﬁcas de caracteres que se
interpretan como: ﬁn de línea <EOL>, ﬁn de página <EOF> yﬁn de ﬁchero <EOF>. La

interpretacion del contenido de un ﬁchero de texto, resulta más complicada que en los otros:

72

MXÏÏIIIIJLJIII'll|Illlul-lobltlelctlallolillllIIIIIItII|J|IIFTUFÉ

aunque se encuentre organizado en lineas, éstas no son necesariamente el componente básico
de acceso. y aunque las lineas sean secuencias de caracteres, el tipo de datos al que se va a
acceder no tiene que ser interpretado obligatoriamente como ristra de caracteres:
Supongamos que en una linea de un ﬁchero aparece la secuencia "3524283 3.14". Podría
leerse en una variable de tipo ristra que respetase dicha secuencia, o en dos variables de tipo
real, interpretando la secuencia de caracteres como los números reales que representan —en
este caso, el espacio se interpretaría como delimitador de los números—, incluso podría
interpretarse como cuatro valores enteros.

7 " — WT

EOL i’ EOLE



Illlstrución ID Estructura dc un ﬁchero de texto

Los modos de acceso se diferencian por lo que se hace y por cómo se hace. I_.o único
que se puede hacer con la información almacenada en un ﬁchero son operaciones de entrada
—lecturas— para copiar componentes del ﬁchero a variables del programa y operaciones de
salida —escrituras— para copiar variables del programa en componentes del ﬁchero. En
unos casos se puede acceder ajualqíuierAcomponente en cualquier momento —acceso
d¡recIo—— y en otros para acceder a una componente se debe haber íí-Lïeﬁldﬂ antes a las que
ocupan posiciones previas en el ﬁchero wccesa secuencia]. Cuando un ﬁchero se trata en
modo secuencial es normal que sólo se hagan operaciones’ de entrada u operaciones de salida,
pero no ambas, mientras que cuando se trata en modo directo es habitual que se puedan
mezclar ambas operaciones. También es normal que los ﬁcheros de componentes unifonnes
puedan tratarse en modo directo 4a] ser todos los componentes del mismo tamaño es fácil
calcular la posición ﬁsica de uno determinado— mientras que los ﬁcheros de texto siempre
tienen que tratarse en modo secuencial —los componentes son lineas de tamaño variable
determinado por las marcas de ﬁn de linea, con lo que resulta muy diﬁcil conocer de manera
eﬁciente donde empieza cada unai; por razones similares los ﬁcheros de componentes no
homogéneas son más adecuados para un tratamiento secuencial, a menos que tengan una
estructura conocida con exactitud por algún medio.

La cuestión de la persistencia —período de existencia— de los ﬁcheros parece
contradictoria con la justiﬁcacion expuesta anterionnente —los ﬁcheros sirven para guardar
infonnación de foma pennanente—; sin embargo, existen aplicaciones en que una

infonnación que solo se requiere durante la ejecución del programa se guarda en un ﬁchero
73

temporal —por su volumen o por otras razones- que el propio programa destruye cuando

deja de necesitarlos.

Protocolo de transferencia de información programa/ﬁchero.

Para un programa, una variable es una entidad de su propiedad, que crea, destruye y
manipula a su antojo; sin embargo, un ﬁchero es una entidad ajena, con existencia propia y
situada en "el exterior" —los discos y demás dispositivos mencionados son unidades de
almacenamiento extemo—, que contiene una infonnacíón que el programa no puede
manipular directamente —tiene que hacerlo a través de transacciones con sus variables. Un
programa que pretenda almacenar o manipular información en un ﬁchero debe seguir un
estricto protocolo de comunicación con el Sistema de Gestión de Ficheros —la parte del
sistema operativo de un ordenador encargada de controlar todo lo relativo al almacenamiento

de información en dispositivos extemos.



Programa Sistema dc ﬁcheros
Ïl ’}” " . ﬁdtrolli h ‘n
V‘
ww n-Ïs; r. mu.)

Pmgmm Sistemade ﬁc ¡bs
rn " r ‘ 316m —



  Ni‘ Abrir

‘t
(‘un -v« ll.rlr‘x¡





Programa
vi c ' "c '
v2

Vln-¡Sﬂsnoi-Je; ﬁ. al CGÏÏÏZ

Ilustración Il Protocolo de transferencia dc información entre un programa y un ﬁchero

Para poder iniciar la transferencia de infonnación se necesita en primer lugar declarar
una variable que, para el programa, representará al ﬁchero; cuando se necesite una operación
que haga referencia a un ﬁchero disponible en algún dispositivo extemo —ﬁchero ﬂsico- se

empleará la variable que lo representa ——conocida como ﬁchero lógico.

74

En la declaración el programa especíﬁca como va a interpretar la información

contenida en el ﬁchero que se asocia con la variable; se contemplan tres posibilidades:

variable Fichero Nombrevariable [componentes no uniformes
variable Fichero<TipoCamponente> Nombrevariable [componentes uniformes
variable FicheroTexto Nombrevariable Michero de texto

Una vez se ha declarado una variable ﬁchero el primer paso es la apertura, que
comprende dos aspectos: l) establecer la relación entre la variable ﬁchero y el ﬁchero ﬁsico
que se pretende manipular por su intermediación —igual que una variable entera puede
representar diferentes valores enteros en momentos diferentes, una variable ﬁchero puede
representar diferentes ﬁcheros ﬁsicos— y 2) poner en marcha los rrïismos necesarios
para la transferencia efectiva de la infonnación para lo cual el programa deberá e_s_¿eeiﬁca.r el
sentido aplicado al ﬂujo de la infomtación —desde el ﬁchero haciavel programa. desde el

programa hacia el ﬁchero o en ambos sentidos. Este proceso lo lleva a cabo la operación

lógica Abrir que puede tomas las siguientes conﬁguraciones:

1.- AbtirlF, NombreF, Lectura)
2.- AbrirÍF, NombreF, Escritura)
3m Abrírﬁ‘, Nombrel’, Lectura/Escritura)

F es la variable controladora —tambie’n llamada “ﬁchero lógico”—, NombreF es una ristra
conteniendo el nombre de] ﬁchero ﬁsico que se pretende abrir —debe existir—, Lectura,
Escritura y Lectura/Escritura son palabras reservadas que actúan como indicadores del
sentido de transferencia de la información.

Para los ficheros de texto y los de componentes no uniformes el modo de apertura
sólo puede ser Eectiira o lïseritura, y se aiﬂgïﬂ los componentes de forma sejuﬁencialibos
ﬁcheros de componentes uniformes admiten, además, el modo Lectura/Escritura y el acceso
directo a sus componentes.

En nuestro pseudolenguaje, la operación Abrir es una función lógica que, además de
asociar la variable F con el ﬁchero cuyo nombre indica NombreF y dejarlo listo para ser
utilizado, devuelve un valor verdadero si la apertura tiene éxito y falso en caso contrario —
por ejemplo si el ﬁchero ﬁsico no existe. Un ffhero ﬁsico se puede crear con la (¿Eración
lógica CrearFicheroQVombref) que devuelve verdadero si lo crea y falso si no puede crearlo
:3; ejemplo si ya existe un ﬁchero con ese nombre. En muchos lenguajes, las operaciones
de apertura y creación son procedimientos, y señalan el fracaso mediante una excepción.

La siguiente fase es la de transferencia de información, que se realiza mediante

operaciones de entrada/salida según el ﬂujo sea desde el ﬁchero al programa o viceversa.
75



Habitualmente, las operaciones de entrada/salida con ﬁcheros son similares a las que se

utilizan con la pantalla y e] teclado, con la salvedad de que hay que especiﬁcar la variable
ﬁchero a la que se reﬁere la operación como primer parámetro de la misma.

Leertn , Varl)

Escribir ( F2 , Var2)
Memoria RAM Fichero Memoria RAM Fichero
Pro a Pro

Bntïer de cscmur Buffer de lectura



Ilustración ll Flujo de la información a través de buffers

Finalmente, cuando el programa haya completado el trabajo para el que necesitaba la
información del ﬁchero, debe solicitar el cierre de la comunicacion mediante otra operación
especíﬁca; de no hacerlo asi, podrían producirse pérdidas de información por el canal abieno.
Ello puede pasar, fundamentalmente, cuando el trasvase de información va desde el programa
hacia el ﬁchero y se debe a que, para minimizar el alto coste en tiempo de acceso a los
dispositivos de almacenamiento, las operaciones de lectura y escritura no se realizan
directamente con el ﬁchero. sino que se habilitan unas áreas en memoria denominadas
bufferr. de tal manera que, cuando el programa solicita un dato del ﬁchero, no sólo se
transﬁere a memoria el dato solicitado, sino un bloque mayor que se guarda en un buﬂer de
lectura en la suposición de que probablemente el programa pedirá a continuación e] siguiente
elemento; si esto es asi, en las siguientes peticiones del programa no se accederá a memoria
externa. siempre que Ia información solicitada se encuentre en el buﬂer. De modo
equivalente, cuando cl programalrealiza una operación de escritura, esta no ocurre realmente
en el ﬁchero, sino que la información se va acumulando en un bujïer de escritura que es
transferido al ﬁchero cuando se llena. La operación de cierre garantiza que la información
que quede en el buﬂer de escritura cuando se termina de trabajar con el ﬁchero sea.
efectivamente, incorporada a éste; si el programa termina bruscamente sin cenar los ﬁcheros
en los que ha escrito, la ínfon-nación que quede en los bujferx se perderá. E] intercambio de
información entre el ﬁchero y el algoritmo queda ﬁnalizado mediante la operación

cerrancerrar (F)4

íf/—

76

Cuando se manejan ﬁcheros con tipo, las variables que se usen para intercambiar
información con e] ﬁchero deberán ser compatibles con el tipo del que se han declarado los
componentes del mismo.

En todo ﬁchero supondremos la existencia de un indicador de posición (LPM) que
señala a un componente del ﬁchero. Al abrir el ﬁchero el IPos apunta al primer componente;
al efectuar una operación de lectura o escritura. se lee o escribe un registro empezando en la
posición indicada por el IPos y este avanza en proporción a la información leida o escrita,

quedando listo para que se lea o escriba el siguiente registro.

lPos —>



<EOF> IPoS -—> <EOF>



Final de fichero = Falso

Ilustración 13 indicador de posición (lPos) y marca de ﬁn de ﬁchero (EOF)

Operaciones auxi gres.

Para que la gestión de la información almacenada en ﬁcheros sea correcta es necesario
que se proporcionen operaciones de control que pennitan conocer cosas como: el tamaño de
un ﬁchero, si se ha alcanzado el ﬁnal de una linea o el ﬁnal del ﬁchero, etc, y actuar en

consecuencia.

Si un ﬁchero se recorre secuencialmente, es fundamental detectar cuando se alcanza e!

ﬁnal del mismo, para conseguirlo disponemos de una función lógica FinFicherafF)

77

Para calcular el tamaño de un ﬁchero usamos la función Ïimañaﬂ’), que dïuelve su
taLño en bytes para los ﬁcheros no uniformes y para los uniformes su tamaño en número de
componentes de ese tipo —su tamaño en bytes será este número multiplicado por lo que
ocupa un componente de ese tipo. Para conocer lo que ocupa una componente de un tipo
dado usaremos la función: Tamaño(UnTipa). g

La operación que permite situar el [Pos en una pgsíﬂfïl’ cuailouiera del ﬁchero
pennitiendo el acceso directo es I_rA(F,Pm), que coloca el indicador del posición del ﬁchero
F en la posición Pos. Los valores que puede toma: Pos están comprendidos entre l y
Tamañoﬂv‘) + l. Cuando el IPos se sitúa en esta última posición sólo se puede‘ hacer un
acceso de escritura.

La función Posiciónﬂ") devuelve un valor entero indicando la posición actual del
Ifos. en bytes o registros. según sea el ﬁchero. -7

Renambrarf/Vqmbfe Vigo, NambreNueva), donde NombreViejo y NombreNuevo son
ristras conteniendo, respectivamente, el viejo y el nuevo nombre que se quiere dar al ﬁchero,
es una función logica que devuelve verdadero sí el cambio de nombre se realiza con éxito ——
no puede hacerse si ya existe un ﬁchero con el nombre nuevo.

El procedimiento EIiminarﬂVombrgFic-hero). elimina el ﬁchero ﬁsico cuyo nombre

viene dado en la ristra NombreFichero.

Operaciones especiﬁcas de ﬁcheros de texto.
La operación LeerLíneaﬂïl/ar) lee una linea de un ﬁchero de texto y deja el ¡pax

preparado para leerla siguiente.

La operación EscribirLíneaW, Var) escribe una linea en un ﬁchero de texto y avanza



el Ipos .

La función FiíLíneaﬂï) devuelve verdadero cuando se ha alcanzado una marca
<EOI) y falso, en casoïoírario. Sirve para saber si se ha alcanzado el ﬁnal de la misma
cuando se trate una linea parcialmente.

El procedimiento SídtarLineqF) mueve el IPus del ﬁchero F detrás del próximo
<EOI> , o sea, saltar a la siguiente línea del ﬁchero. Sirve para desechar el resto de una linea
que se ha leido en parte.

El procedimiento NuevaLinea(F) escribe un salto de linea (<EOL>) en el ﬁchero F

dando comienzo a una nueva linea,

78

Ejemplos
E] siguiente algoritmo muestm los pasos más comunes a la hora de trabajar con un
ﬁchero, en este caso tipo texto. Este ejemplo copia el contenido de un ﬁchero de texto,

NUmIQEnIrada, sobre otro ﬁchero, NomlïSalida.

algoritmo copiargichero
variable FicheroTexto Fich_Entrada, Pich_Sa1ida
ristra Línea, NomF‘_Entrada. nomxgsanda

escribir 'Deme el nombre del fichero a copiar"
leer Nomlïﬁzntrada
escribir "Dame el nombre del fichero destino‘
leer NomF_Sa1ida

si Abtir(Fich_Entrada, NomF‘_Entrada, Lectura) entonces

si CrearFiChero(Nom1-'_Salida) /\
Abrir(FiCh_Sa11da, NomF_Sa1ída, Escritura) entonces

mientras no FinFiCherQKFiChÁIZ-Zntrada) hace:
LeerLínea < Fichjintrada, Línea)
EscrihirLínea(Fích_Sa1ída,Línea)

Ein mientras

Cerrar (Fichjntrada)
Cerrar(Fich_sa1ida)
si no
escribir "No se puede Crear el fichero de salida"
Cerrar lFichjlntrada)
fin al
si no
escribir "No se puede abrir el fichero de entrada
ﬁin a1
parir
fin algoritmo (Copiar_Fíchero)

El siguiente algoritmo recorre un ﬁchero de entrada que contiene un texto en el que
las palabras están separadas por un único espacio, no hay espacios al principio ni al ﬁnal de
cada línea y no hay palabras nartidas entre líneas, y calcula la frecuencia (absoluta) de
aparición de cada palabra, escribiendo en un ﬁchero con tipo las palabras diferentes y su

frecuencia.

tipo TRegFreC ea estructura {Registros del fichero resultante)
campo rístra Palabra
campo entero Frecuencia
ﬁin tipo (TRegFrec)

algoritmo FrecuenciaPalabra

variables fichercTexto FEntrada
fichera<TRegFrec> Fsalida
ristra Línea, NomFEntrada, NomFSalida

79

escribir "nombre del fichero a tratar: "
leer NomFEntrada

escribir "nombre del fichero resultante: "
leer NomFSalida

si abrir(FencradamIomFEntrada,Lectura) entonces {Abrir Ficheros}
si abrir(Fsa1ida,NomFSa1ida,Crear) entonces

mientras {no Finﬂ-‘Entradan hace: {Procesar c1 texto)
1eer(FEntrada,Línea)
SaltarLínea (FEntrada)
Procesarnínea(Líneamsalida)

Ein mientras {Procesar el texto}

cerrarmsanda) {Cerrar ficheros)
un si
cerrar (FI-Entrada)
fin si
parar

un algoritmn (Frecuenciavalabza)

procedimiento ProcesarLínea (Línea, Fsalida)
variables entrada ristra Línea
entrada/salida fichero<TRegFrec> Fsalida
lccales TRegFrec RcgFrecJzegFrecL
entera i

miantraa lHayPalabraMLíneaH hacer {procesar línea}
{Se obtiene una palabra}
RegFrezxPalabra 4— Tomarprimpauninea)
RegFreoFrecuencia <- o

í <- 1 {Buscar la palabra}
lrAtFsalidi-Ll)
mientras (i S TamañcHFSalidaH A
(RegFrecL.Pa1abra a: Regnemvalabra) hace:

leerwsalidamegFrecLl

i <- 1+1
Ein mientras

si (í > TamañtMFSalidaH entonces

RegFrecL <- RegFrec
Ein si

{Escribir la palabra con su frecuencia en el fichero de salida}
RegFrecLFrecuencia <— RegFrecL.Frecuencia+1
IrA(F‘Sa1ída,i)
escribir(FsalidenRegFrecL)
un niantrnu {Procesar línea}

retornar
un procedimiento {ProcesarLínea}

función lógica HayPaIahraSKLÍneEJ
variable entrada ristra Línea
davolver (Lonmínea) > 0)

fin función (Hay/Palabras)

80

función ristra Tomarprimpalmínea)
variable entrada/salida ristra Línea
local nstra Palabra
natural PosEsp

PosEsp 4— Pos (Línea, " ") ;

a1 PosEsp > 0 entonces
Palabra e sub(Línea,1,FosEsp — 1)
Línea <- sub(Línea,PosEsp + 1)
a1 no
Palabra 4— Línea
Línea «- --"
fin si
devolver Palabra
fin función {TomarPrimPal}

Obviamente, éste es un algaritmo muy lento, por el gran número de accesos a
ﬁcheros. Si se hubiesen calculado las frecuencias sobre un vector sería mucho más rápido.

pero estaría limitada a priori en cuanto al número de palabras diferentes que podria procesar.

¡‘I

El tructuras de datos dinámicas.

Memoria dinámica.

Planteamiento.

Hasta ahora no hemos visto la memoria como un recurso escaso y en consecuencia no
hemos tomado ninguna precaución especial respecto a su utilización por parte de nuestros
programas: simplemente declaramos todas lu variables que nos hagan falta; si la necesidad
puede variar para distintas instancias del problema, se supone el peor caso y se hacen
declaraciones acordes. Ya hemos aprendido. sin embargo, que el espacio de almacenamiento
es un bien limitado, y hemos introducido un nuevo elemento —los ﬁcheros— para disponer
de almacenamiento más barato y duradero. Sin embargo, lalemïia central sigue siendo el
área de trabajo del procesador infonnático y todo lo que ha de ser procesado ha de estar en, o
pasar por, ella —persiste el problema de¿arla_ geﬁlammás o})_ti_n1igeui_a posible. Esta
optimización pasa por que el programa tenga la opción de (¿agar memoria de fonna no
estática, tomandola cuando le haga falta y liberándola para otros usos cuando deje de
Eesitarla. La mayoria de los lenguajes modemos hacen esto de forma automática a nivel de

subprogramas: delimitan una zona de la memoria. que llaman pila de ejecución, en la que se

ubican, entre otras cosas, las variables declaradas de un Subprograma en e] momento en que
éste se va a ejecutar (proceso conocido como elaborar las declaraciones). Cuando el
subprograma termina su ejecución. sus variables son sacadas de la pila de ejecución,
quedando el espacio que ocupaban disponible para nuevos usos. En cada momento se
encuentran en la pila de ejecución las variables de todos los subprogramas activos, en orden
de más recientemente llamado a menos recientemente llamado.

El conocimiento de cada problema por parte del programador podria permitir u_n uso

aún É dinámico de la memoria, creando y destruyenglo yariables justo en el ‘momento en

que sea necesario, sin que las mismas tengan que estar determinadas a priori ní aparecer en

ninguna declaración.

Para poder hacer este uso dinámico de la memoria es p_reci_so que elsisterna en que se



vaya a ejecutar nuestro programa dispgn de gilgfyrmecanisrngﬁggegontrolela memoria.
delímitando una zona especíﬁca para este ﬁn, conocida como memoria dinámica o ”heap”. y

83

distribuyendola en respuesta a peticiones de los programas formuladas en tiempo de
ejecución mediante sentencias del lenguaje de programación que se esté usando. Un

mecanismo de esta clase lo denominaremos en adelante Módulodí Gestióníde Memoria

denes: (l) para solicitar la





Dinámica y lfiaﬁjproporcionar al menos (iii
aïción de un lﬂícrque de memoria —crear una variable dinámica—— y (2) para indicar que
un bloque de memoria deja de ser necesario y liberarlo —eliminando una variable dinámica.
A la hora de crear variables dinámicamente se plantea un problema: ¿cómo las
referenciamos? Las variables estáticas y de pila tienen un nombre que se ies da en el
momento de declararlas y por medio del cual podemos referimos a ellas en cualquier punto
del programa. Con las dinámicas podría pensarse en alguna forma de darles un nombre en el
momento en que se solicitan al MGMD, pero es técnicamente diﬁcil, y lo que nos
encontramos en los lenguajes de programación usuales es que el MGMD se limita a
proporcionar como respuesta a la petición de un bloque de memoria la dirección ﬁsica de uno
utilizable —aunque no parezca evidente, esta es una solución mucho más ﬂexible en casos en
que las necesidades de memoria puedan variar mucho. Como consecuencia aparece una
nueva Qasteïdatorque los programas deben ser capaces de manejar, el tipo "(Hi1 _de
memoria". con operaciones especiﬁcas. Vamos a llamar puntero a este nuevo tipo, y
siguiendo la norma de los lenguajes con tipado fuerte emplearemos la notación

puntem<trpo> para declarar variables cuyo onten" ¡sean diregg nes _de_ memoria, así



tendremos: h‘ ._

variables _ i
puntero<rea1> a (dirección de una variable real)
puntero<ristra> b (dirección de una Variable rístra)
puntero<entero> c (dirección de una variable entera)
puntero<puntero<rea1>> pp {dirección de una dirección de una variable

real)

Aunque todos los punteros son iguales en cuanto direcciones de memoria, el que al
declarar una variable puntero haya que especiﬁcar a qué se quiere que apunte permite un
mejor control de la actividad del programador y. por tanto, una cierta seguridad en las
acciones ejecutadas. Sin embargo. a veces es necesario hacer “operaciones peligrosas", la
posibilidad de que un mismo puntero pueda referenciar objetos de tipos diferentes en
momentos diferentes es, con frecuencia, útil en programación de sistemas. Eventualmente,
puede ser útil en ciertos entornos usar punteros para apuntar a variables estáticas ——tambie'n
tienen una dirección-z aunque no sc podrian usar para crearlas o destruirlas, y es una

B4

práctica peligrosa —se crea un alias de la variable estática que puede permitir modiﬁcaciones









encubiertas.

‘Ï Ju LasPal " '23  7
a ¿m? rene’  m; '>'>lh¿",, Laïﬂm” wwhvzs‘
a Pedro tialda: 23 ¡

É ‘n? 77? " ' 7'77 l

É m _  j

5 W, y%í>carp; Galdar _ m’ W '37};
._- , , ,

a ,_

p; 0000F_E3ft' n — —

é ooo 1343 — ——— ) _, N" _,,

g pooorroo¡ —r — ———>lM!"Ïl T515“, ,___ M22,
í

E

2

4

a

.5 .

__. _,

Memoria no dinámica Memoria dinámica

Ilustración u Ejemplo a: uso dinámico a: la memoria

Nuestros programas podrán tener yaríables de t_ipo pungo —declaradas o



dinámieas— que se utilizaran para guardar las reccíones de otras variables ——generalmente

dinámicas— ¿"servirán como mïejismos de ¿eeeso a eggs últimas. Supongamos por

ejemplo que necesitamos implementar una lista de alumnos, prevista para contener un

máximo de 600 alumnos y que esté basada en el tipo:

tipo Tnlumno en estructura
campo ristral6ül Nombre
campo ristrallüü] Dirección
campo caracter Sexo '
campo entero Edad

fin eipo (TAlumno)

Este registro puede ocupar unos l65 bytes. En caso de utilizar memoria estática

necesitaríamos un vector dimensionado para contener 600 de estos registros:

variable TAlumno LiStaAIurnnOSHOÜI

«rr to

lo cual implica una reserva de memoria de 99000 bytes (96,68 Kbytes). Sin embargo, si
declaramos un vector de punteros a registros de alumnos, y suponiendo que un puntero ocupa

4 bytes —tamaño habitual—, sólo estaríamos ocupando pennanentemente durante la

85

u
ejecución del subprograma que contuviese esta declaración 2.400 bytes (aproximadamente Z
Kbytes), mas 165 por el número real de alumnos que se este’ manejando. Bastaria con que
faltara alrededor del 2,5% de los alumnos previstos para que el uso de variables dinámicas

empezase a resultar rentable.

tipo PuntAlumno es puntero<TAlumno> Ein tipo

variable PuntAlumno ListaAlumnos [s o o]

Creación y eliminación de variables dinámicas.

Sea T un tipo cualquiera y Q una variable de tipo puntero<T>; el MGMÜ permite
considerar como primitivas las acciones de creación y de eliminación de las variables
dinámicas de tipo T. lg forma general de la acción de creación implica una indicación al
MGMD de que se necesita un bloque de un tamaño determinado y la respuesta de éste dando
Laﬂeocion de un bloque libreﬁdel tamaño especificado. si existe. En nuestra notación se
expresa COÏTIÜI T

o « Tomarmoque (T) mu‘,

lo que signiﬁca una petición para que el MGMD busque un hueco en la memoria capaz de
albergar una variable de tipo T y devuelva su dirección, la cual se asignará a Q. E_n caso de
que no exista ningún hueco capaz de albergar valores de tipo T. el MGMD devolverá un
valor que identiﬁcaremos como NULO. Qyalor NULQes _un valor especial que se emplea
siegprïiueﬁllalqueindicargue una variablepuntergno apunta a ningunrbltgue. En adelante
usaremos TomarBloque en nuestros ejemplos suponiendo que siempre hay memoria dinámica
disponible —a ﬁn de no complicar la estructura de los algoritmos. Los casos de fracaso
requieren el tratamiento de excepciones de ejecución que dependen de la naturaleza de la
aplicación y exceden nuestros objetivos actuales.

Con el ﬁn de evitar, en lo posible, agotar el espacio disponible, el programa debe
devolver sistemáticamente a la memoria dinámica disponible los objetos que ya no necesita;

laacción de "re_lirninación” de larvariable ¡jinámica referenciada por el puntero Q se expresa

como:

Liberada)

86

VEn la ejecución de la acción LÍberQrLQ, el MGMDguprime el objggogguntado poLQ
y reincorpora el espacio que ocupaba al pool de espacio disponible. me que Libegﬂlnq
¡sfïtaallaïle Q; sólo se utiliza para saber que’ bloque de memoria hay que liberar, pero
Q sigue manteniendo su valor aunque éste sea ahora la dirección de un bloque cuya
utilización sería un error; ej conveniLIteNULO a gdespLésdeAlilí el espacio que

referencia; aunque como veremos ello no soluciona todos los problemas.

Acceso "grijlwles É?‘.EE"°_¡“S¡E_R‘I'EP‘°V°S-

Preguntabamos anterionnente cómo podiamos referenciar las variables dinámicas que
creásemos, y en lugar de responder a esa cuestión hemos introducido un nuevo tipo de
variables; ahora tenemos la variable dinámica más otra que contiene su dirección; ¿cómo
podemos usar esa dirección para tener acceso a la variable dinámica? La notación que vamos
a emplear deriva de la representación gráﬁca usual para expresar la relación entre una
variable puntero y aquella a la que direcciones, representación que se maniﬁesta mediante una
ﬂecha. De esta manera, siendo Q una variable puntero, cuando en nuestro programa
escribamos Q nos estaremos reﬁriendo a dicha variable, pero si escribimrig a. nos
estaremos refugio a "lo que está detrás de la ﬂecha", es decir, a la variable apuntadaJJoLQ.
gesta variable fuese de un tipo compuesto de campos, nos refeririamos a cada campo como
gaNambreCam a, y si fuese unwvectgr, indicaríamos el i_esimo elemento como Qjﬁ]. La

operación consistente en acceder a la variable rerferenciadapor un puntero recibe el nombre

de dereﬁancitïiég.



Memoria
dinámica

Ilustración l5 Puntero y variable apuntada

Problemas al usar punteros.

Los punteros permiten un uso muy eﬁciente de la memoria en ciertas situaciones, pero
han de usarse con cuidado porque también plantean problemas:

l. la necesidad de estar segu_r0s de que el puntero_ grïiene una dirección válida —el

intento de dereferenciación o liberación de una dirección no válida podria causar un
error de acceso,

87

lo

el peligro de la creación de elias si sepsiggní a dos punteros diferentes la misma

dirección,

3. la combinación de los dos anteriores si una variable dinámica referenciada por dos
punteros es liberada usando uno de ellos —accesos posteriores con el segundo
puntero resultarían en un error—,

4. la posibilidad de dejen variables dinámicas 'nacces'bles si están referenciadas por un

único puntero y se cambia el valor de éste y

5, la inoperanciage los mecan’ mos d t s de entrada con



las yvarigsjes dinámicas cuanglrïícﬁeisepasg por parámetros es un puntero —e'ste

estaría protegido, pero no la variable a la que apunta.

A continuación se desarrolla un ejemplo que ilustra algunas de estas situaciones.
Supónganse que P, Q y R son punteros a enteros y que I y J son enteros; al elaborar la
declaración de las variables se crean cinco variables estáticas de dos tipos diferentes con

valores indeﬁnidos y ninguna variable dinámica.

variables ï 3
entera I l l
puntero<entero> P, Q P‘
entera J Q
puntero<entero> R
J l
R
Memnria
dinámica

Instrucciones como las siguientes, provocan un error de acceso:

P” *‘ 3
Liberar 1Q)

El siguiente bloque de instrucciones sí sería válido. y dejaría deﬁnidas todas las variables,

además de crear tres dinámicas:

I e 3
p k TomarBloquehentero) l 3 , i
Q ' Tomaraloquuentero) P ' >l 3 l i
J e 5 Q: >4 5 ‘
R e TomarBloquelentero) J 5
p > e I l
o > e J R y >l 7 l
R'> a 7 i ,
Memoria
dinámica

88

La siguiente sentencia crea un alias al mismo tiempo que deja inaccesible una variable

dinámica:

0*?



si ahom se libera la variable referenciada por P, Q se convierte en lo que se conoce como un

"puntero salvaje" ——contiene una dirección inválida por referenciar un bloque ya liberado.

Liberarl?)
P *’ NULO



Estructuras encadenadas. . ' v .  _ l

Concepto de ubicación encadenada.

Considérese una lista ordenada de nombres como la siguiente: ("AgustínÏ "Ana".
"Emesto", "Juan", "Plácido"); podría implementarse fácilmente mediante un vector de ristras,
pero supóngase que en esa lista las altas y las bajas, ocurren con una gran frecuencia; una
gran variabilidad se traduciría en un alto coste para mantener el orden de la lista. A modo de
ejemplo, se muestra como evoluciona el vector al introducir la secuencia de nombres anterior.
Las inserciones de "Ana", "Emesto“ y "Agustín" provocan desplazamientos de los elementos
ya insertados con el ﬁn de mantener el orden adecuado —de la misma manera, si se extrajese
un elemento que no fuese el último seria necesario desplazar los posteriores a ﬁn de rellenar

el hueco ocasionado.
89

Insertar: Insertar: Insertar: Insertar: Insertar:






"Juan" "Ana" "Plácido" "Ernesto" "Agustín"
Posición

Juan Ana ,_ _ Ana Ana ¡Agustin

_Ji_1an V Juan Ernesto p Ana
l E9 ‘M39 , , ‘Ernesto

Plácido Juan

Plácido

1
2
3
4
5
6
7
B



Ilustración I6 Secuencia de inserciones en un vector

La razón de este coste es que el orden lógico —en este caso alfabéticc- de la lista se
ha hecho coincidir con el orden ﬁsico de la ubicación contigua de los elementos del vector. Si
uLi-"Lelerimiïe, Ja lista PUÚÏCFFÏJEQPÉÑSÉJ“,“"3,¡'ldÏ°‘!9¡ó'Ï‘ É°_@LÏ,°_5°_&‘F_“ÉEE’?
tïsiínfnte su sucescggnjlícÉn lógico establecido, este no tendría que insertarse en una
posición contigua. Podemos modiﬁcar los elementos del vector dc fonna que en vez de ser
ristras. sean de un tipo estructurado con dos campos. uno ristra que contiene el nombre y otro
entero que indica en que’ posición del vector se encuentra el siguiente elemento en orden
lógico. A esto se le llama encadenar los elementos de la lista, y permite que las inserciones y
extracciones se efectúen sin desplazamiento de información; ¿orcojtra las húguedﬁ (¿i131
qiïqlïrïs —— en el vector podía emplearse, por ejemplo, un algoritmo
dicotómico- y además se necesitarïgspacpio para almacenar los mismos datos al tener
que contabilizar los campos de encadenamiento.

Como los elementos pueden hallarse ﬁsicamente en cualquier posición. se hace
necesaria una variable entera que indique dónde se encuentra el "primero" —a partir del cual
se puede recorrer toda la lista. El principio de la lista en la ﬁgura se ha simbolizado por "E".
Se ha puesto un 0 en el campo de encadenamiento del último elemento —que al ﬁnal ocupa

ﬁsicamente la 3“ posición- para indicar que detras de él no viene ningún otro —el valor



cero. al no corresponder a ninguna posi n válida del vector se ha utilizado aquí como marca

de ﬁn de la secuencia de encadenamientos.

90

D:
Insertar: Insertar: Insertar: Insertar: ‘ Insertar:
“Juan" "Ana" “P1áCid0" "En-testo“ "Agustín"
u







V 0 ‘Juan W 3

1_ Ana _ 4
m” _ Pﬁcido 0__
‘Ermua . 1

Agustín, 2

R indica la primera posición (lógica) de la lista

Ilustración 17 Inserción cn una lista eneadenada en un Vector

Situaciones especiales.

Hay algunas cuestiones que deben tenerse en cuenta: (l) la politica que se ha seguido
en la ﬁgura ha sido la de partir de un espacio de almacenamiento inicialmente vacío, y
comenzar a insertar nombres a medida que van llegando; en cada ocasión se modiﬁcan dos
encadenamientos —el del elemento recién insenado y el de su predecesor- con el ﬁn de
mantener el orden lógico, si se continúa insertando, el cuarto elemento a partir de la situación
actual —suponiendo que no se hubiesen producido extracciones— no encontraría espacio
disponible —una situación como esta, en la que se necesita gggiiïggndggg} se ha

agotado el espacio de almacenamiento, Ïfonoce como situación de “sobrecarga
(overﬂow)—; (2) podría ocurrir la situación inversa si iniciamos una secuencia continua de
extracciones  cuando I¿¡_li_sta guedase vacía se intentagennagr una extracción nos
encontraríamos ante una situación ‘de Ïbajo mínimo” (underﬂow)— y (3) el aprovechamiento
del espacio liberado por las extracciones; en el ejemplo de la ﬁgura —en el que sólo se han
hecho inserciones- el espacio vacío permanece agrupado y localizado al ﬁnal de la zona de
almacenamiento reservada, sin embargo, si se extrajese un elemento —por ejemplo Ana- de
la lista, se observa claramente en la siguiente ﬁgura que ello daria lugar a un hueco libre que
ya no estaría agrupado con el resto. Si no se implementa algún mecanismo para poder
reutilizar estos espacios liberados, el resultado serían situaciones de falsa sobrecarga —hay

espacio para nuevas inserciones pero éstas no podrían efectuarse.

9|

L3.’

onstazuuumm-



Ilustración IS Hueco al libera un elemento

Para aprovechar esos espacios no cabe plantearse el compactar la lista cada vez que se
realice una extracción —se estaría en la misma situación que cuando el almacenamiento era
secuencial , con continuos y costosos desplazamientos. Una primera solución es ggigcar de

alguna m (los huecgs libgrgtjps en el momentg de la extracción Lrecun-ir luego



periódicamente, o cuando el grado de fragmentación se estime suﬁcientemente alto, a un
pmcedímlento de firecoleccicln _de ntlesgerdíciosf (ggrlgqgeﬂcollection) que realice la
mencionada compactación. Otra solución muy efectiva es aplicar el concepto de

cncadengrnientoggglïénggjpgcïg li_bre, fumando de esta manera una Iisla encadenada de

espacm libre — la extracción de un elemento de una lista se traduce en una inserción

simultánea en la lista de espacio disponible.

“E”

EJE ta;



Aﬁsáaﬂaïrﬁ‘ Dnxsdaeaawﬂ“

Ilustración l? Lista encadenada de huecos libres

92

Representación delistas encadenndas.

En los ejemplos anteriores se han implementado las listas encadenadas en un espacio
de almacenamiento que era en esencia un vector: es sólo una de las posibles formas de
implementar una lista encadenada: podemo co ïuirie tructuras encadenadas utilizando

como base cualquier forma de almacenamiento que pennita guardar múltiples elementos

777” l

lógica a los datos almacenados en un ﬁchero o estructuras encadenadas en memoria

indi



duales y rreferenc



' dep dentemente —usarlas para dotar de estructuración

dinámica. La utilización de encadenamientos es apropiada para estructuras de datos ¡gue
tierïtyltáogïado de variación —son muy dinámieas—; los mecanismos de la ubicac n
dinámica permiten ajustar la ocupación de memoria a las necesidades existentes en cada
momento de la ejecución de un programa con lo que resultan apropiados para implementar
escrucmms encadenadas —al contrario que la representación en vectores, no requiere reserva

de memoria.

Algoritmos de manipulación de listas encadenadas.

A continuación se presentan varios algoritmos básicos de manipulación de listas
simplemente encadenadas implementadas en memoria dinámica —con otras
implementaciones los algoritmos no varían esencialmente más que en lo relacionado con los

es bas en la



mecanismos especíﬁcos de representación»; podemos identiﬁcar dos a ﬂ _ 7
manipulación delstas Qüﬂadﬂsi   un elemento —añadir un nodo- o (2)
extraer un elergitg —-eliminar un nodo—; ambas acciones se pueden realizar en tres lugares
en una lista: (l) al principio. (2) al ﬁnal o (3) enmedio. En todos los casos se supone que la
variable puntero que se va a utilizar para mantener el acceso al primer elemento de la lista se
inicializa con el valor NULO antes de empezar a usarla. Las estructuras de datos utilizadas se
deﬁnen de la siguiente manera:

en Talamanca un tipo asignable
tipo Nodo al estructura
campo TElemento Info
campo PLista Siguiente
un tipa
tipo PLIsta es puneero<Nodo> fin tipo

93

Iírlserciícírral Principio de una lista encadenada.
Es el caso más simple, ya que basta con crear un nodo con la infonnaeión requerida y
copiar en su campo de encadenamíento el valor del puntero que da acceso a la lista,

cambiando éste a continuación para que apunte al nuevo nodo.

procedimiento Insertarnelancemﬂ)
[Se inserta el Valor de v al principio de 1a lista apuntada por L.
[L debe tener una dirección Válida, o el Valor NTJLO (lista vacía) .
vatiablenentradn/anlida PLÍSCB L
entrada Tipovalor v
locales PLista Nuevo

Nuevo e romarmoquemodo) [Se coma, un bloque, se pone s1 Valor
NuevoaInEo « v [y se hace que indique como sucesor a1
Nuevoasiguience v 1. /que actualmente sea el primero. E1 puntero
L « Nuevo Ide acceso cambia para señalar a]. nuevo
retornar

un procedimiento

Tal como ilustra la ﬁgura. la inserción de un elemento al principio de una lista

encadenada se hace en tres pasos.

Ll; ">59? *"' >ñÏLl 7" >l0°Í>ll



Nuevo  " >L

L l 559M '9,°°°Ï >°°°lÏ
__, 2
Nuevo l —— > ooo ‘ '
L  ylwüf "W300,," W100i l
Nuevo JÏ esÍsíu y 3

Ilustración 20 Inserción z] principio dc una lista encadenada

En el primer paso. se reserva espacio para un nuevo nodo, recogiendo su dirección en
la variable local Nuevo y rellenando su campo de información con el valor a insertar. A
continuación hay que encadenax el nuevo nodo con el resto de la lista; para ello, primero se
copia en su campo de encadenamiento el valor de la varible L —el puntero de acceso a la
lista—. con lo que el nuevo nodo está señalando como su sucesor al primero de la lista.
Finalmente, hay que hacer que el nuevo nodo se convierta en el primero de la lista. lo que se

consigue asignando a L el valor de Nuevo.
94

Inserción gl ﬁnal de una li}? encadenada.
En este caso el problema reside en encontrar el ﬁnal de la lista para insertar un nuevo

nodo a continuación.

procedimiento InsertarDetrás (LV)
[se inserta el valor de V a1 final de la lista apuntada por L.
[L debe tener una dirección Válida, o el Valor NULL) (lista vacía).
variables entrada/salida PLista L
entrada Tipovalor V
locales PLísta Nuevo

B1 (L = MILO) entonces [Insertar al final es lo mismo que
Insercerneinneemw) [insertar a1 principio de la sublísta
si no Hvacía) que sigue al última nodo,
xnsereernecrán(Lasiguieneev) [y lo mismo que insertar al principio,
fín al [Si 1a lista está Vacía.
retornar

f in procedimi ente

Con está solución, insertar al ﬁnal de una lista encadenada se transfonna en ínsenar al
principio de la lista —vacía— que sigue al último nodo. Aunque es una solución fácil, puede
resulmr costosa si las inserciones al ﬁnal son muy frecuentes. En este caso, sería adecuada

mantener un puntero que señale siempre al último nodo de la lista, lo cual facilitiraría

enormemente la inserción.

procedimiento InsertarDetrás_2 (Prim,U1t,V)
[Se inserta el valor de v al final de 1a lista apuntada por Print.
{Prím debe tener una dirección Válida, o e1 valor me (lista vacía).
[me apunta al último nodo de la lista apuntada por Prim.
/s1 Prim es mms, v1: es NULG
vatiahlenantrnda/aalida PLista Pxirn, un:

antrnda Tipovalcr v

1een1en PLisca Nuevo

si (Prim : NULO) entonces
1nsercarnelantetvrim,v) [E1 primer y último nodo serán el misma
v1: e Prim

si no
InsertaxDelante(U1t*Siguiente,V) [Prim no ee Ve afectado

m: k Ulcüsiguience
Ein si

retorna:
E in proc edimiento

95

Inserción ordenada

Para ilustrar la inserción en cualquier lugar de la lista se presenta un procedimiento
que inserta un elemento en su lugar según un orden ascendente Aexige que el tipo de la
información de la lista, TElemento, sea ordenable, que se interpreta en este caso como
admitir el operador "s". Hay que suponer que la lista está ordenada y de lo que se trata es de

hacer una inserción sin que deje de estarlo.

procedimiento Insertarlïnorden (L, v)
¡se inserta el Valor V en su posición ordenada en la lista apuntada por L
¡L debe tener una dirección válida, o el valor Num (lista Vacía).
[si L no es NULO, los nodos encadenados deben estar ordenados entre sí
[según el valor de sus campos Info, en orden ascendente.
variableuentrada/aalidn PLista L

entrada Tipovalor v

locales PLista Nuevo

a1 1L : MILO) o ¡v s LaInto) entonces [si es menor que s1 primero,
Insercarnelancunv) ¡v Va al principio de 1a lista
si no jsino, irá donde le corresponda,
InsertarEnOrden(L"Siguíente,V) [en la sublista que Sigue
fin si [al primero.
IECOZBG!

ﬁin procedimiento

Si el valor a insenar es menor que el primero de la lista, se utiliza InsertarDelante, si
es mayor que todos los que contiene la lista. lnsertarEnOrden funciona exactamente igual que
InsenarDetrás; pero tiene la posibilidad de dejar de hacer llamadas reeursivas en cuanto
encuentre un nodo con una información igual o mayor que la que se quiere insertar, con lo
que se consigue la inserción enmedio como inserción en el principio de la sublista en la que

todos los valores son iguales o mayores que el dado.

Extracción al principio.

En el caso de la extracción, vuelve a ocurrir que el caso más simple es la extracción
del primer elemento de una lista: l) Se reserva la dirección del nodo a eliminar en una
variable auxiliar local, 2) se asigna al puntero que indica el principio de la lista la dirección
del siguiente nodo —si no hay más quedará con el valor NULO— y 3) se libera el nodo que
ocupaba la primera posición utilizando la variable auxiliar en la que se había guardado su

dirección —todo esto siempre que la lista no este’ vacía de entrada.

96

procedimiento ExtraerDelante (L)
‘Extras el primer nado de la lista apuntada por 1..
/L debe tener una dirección válida, o el valor MILO [lista vacía).
varinblesentrada/anlida PLista L
locales PLista Aux

a1 L % NULO entonces /s1‘ 1a lista no está vacía, se extras el primer
Aux k L. [nodo tras haber hecho avanzar L al segundo.
L v Lásiguience [L quedará con el valor MILO si sólo hay un nado.
Líberarﬂkux)

ﬁin si

IBCOXEÁ!

Ein procedimiento

LT W’ ‘N500 "* >'°°° >9<2E
1
Aux h —



\
x

L1’ I 000i ——>> 90o] ) ﬁoío’;
T 2
Aux ‘ V7"
L v" — r—— >gT »ﬁooow
A 3
Aux  "”'

Ilustración 2| Extracción al principia de una lista encadenada



Extras n al ﬁnal.

La exxracción del último nodo de una lista —que tenga algún nodo- de divide en dos
casos: l) que sólo haya un nodo en la ¡ista pasada —se extrae- a 2) que haya más —se
extrae recursivannente e] último del resto de la lista. A] contrario que en la inserción, tener un
puntero al ﬁnal de la lista no solucliona nada en una lista simplemente encadenada puesto que

hay que modiﬁcar el enlace Siguiente del penúltimo nodo al ¡ransfonnarse en último.

procedimiente Extraernecrás (L)

jﬂxczae el último nodo de 1a lista apuntada por L.

[L debe tener una dirección válida, o el Valor num (lista vacía).
variableaantrada/salida PLista L

n y. s Num entonces [Si la lista no está vacía se puede extraer.
¡x rnsiguience = NULO entcncan
LíberaﬁL) [Si es el última se extrae.
L ‘ NULL)

97

s1 no
ExtraerDetrás(Lesíguiente) [Si no se avanza recursivaments

ﬁn si
fin si
retornar
Sin procedimiento

Extracción ordenada.

La extraccion ordenada es la única que sigue necesitando el valor a extraer —es una
operación que depende del valor, no de la posición. El siguiente algoritmo elimina de una
lista la primera ocurrencia de un nodo cuyo campo de información tenga el valor

especiﬁcado.

procedimiento ExtraerEn0rden(L,V)
¡se extrae el primer V510; de v de la lista apuntada por L
(L debe tener una dirección Válida, o el valor NULO (lista Vacía).
[Si L no es NULO, los nodos encadenados deben estar ordenados entre sí
[según el valor de sus campos Info, en orden ascendente.
vatlablesenttadn/Belida FLista L

entrada TipoValor v

locales FLísta Nuevo
si (L r NULO) entonces

a1 (v = Lamfo) entonces /v se ha encontrado y se extrae.
ExtraerDelante (L , V)
ui no
si (v > innato) entonces ¡v puede estar más adelante, se avanza.
ExtraerEnorden (LﬁS iguiente , v)
un si
fin si [La primera ocurrencia de V (ya) no está
/en 1a lista.
fin a1
retornar

fin procedimiento

Variaciones de listas encadenadas.

El concepto de ubicación encadenada es muy potente, y permite crear toda clase de
estructuras, libres de las limitaciones de la ubicación contigua. Algunas se enumeran a
continuación a modo de ejemplo.

Listas circulares. Se hace que el último elemento de la lista apunte, con su campo de
encadenamiento, al primero. De esta manera, cualquier nodo es siempre accesible desde
cualquier otro, y el puntero de acceso no está obligado a quedarse ﬁjo en un nodo
detennínado; el inconveniente es que hay que tener cuidado de no entrar en un bucle inﬁnito
cuando se intente recorrer la lista. En ocasiones. la lista circular se monta con un nodo
especial —a veces conocido como cabeza- que actúa como sucesor del último y predecesor

98

TnTntttIl¡unnnuuuuuuntu¡|1¡

N

del primero, y existe incluso cuando la lista está vacía, apuntandose a si mismo, de fonna que

simpliﬁca los algoritmos de manipulación, al eliminar algunos casos particulares.

‘J




73°“
 r>Ï>9°
>lj>i99
ML >v9° e
3 n00

Ilustración 21 Lista circular

Lista doblemente encadenada. Cada nodo tiene dos enlaces, uno que señala, como
en las listas simplemente encadenadas, a su sucesor, y otro que señala a su predecesor, lo que
permite recorrer la lista en ambos sentidos. Aunque en la ﬁgura se han puesto dos punteros de
acceso, uno a cada uno de los nodos extremos, lo que permite iniciar un recorrido en
cualquiera de ellos, en realidad la lista sigue siendo operativa con un sólo puntero de acceso;
incluso —a diferencia de las listas simplemente encadenadas— éste no tiene por qué
pennanecer ﬁjo en el primer nodo, dado que el doble encadenamiento permite alcanzar un

nodo desde cualquier otro, sea anterior o posterior.

«X _
ooo

z l l



y Ilustración 13 Lista doblemente cncadenada
Lista multienlazada. Igual que la doblemente encadenada, cada nodo tiene dos
campos de enlaces, pero, en lugar de usarlos para apuntarse mutuamente un sucesor y su

y i predecesor, se utilizan para encadenar la lista en dos ordenes distintos —en el ejemplo, los

99



nodos están encadenados en orden númerico por el segundo enlace, y en orden de
codiﬁcación de carácteres por el primem. Los dos punteros de acceso, que ahora si son
necesarios, apuntan al primer nodo en cada orden —se puede considerar que lo que tenemos
son dos listas simplemente encadenadas que comparten los campos de ínfonnación. También
se podría pensar que una lista doblemente encadenada es una lista multíenlazada, en la que el

segundo orden es el inverso del primero.

, , ,V ,
>l . > 25 - ——>112l >400
' A

Ilustración 24 Lísla multienlazada

Se puede continuar introduciendo toda clase de variaciones, tales como listas
circulares doblemente encadenadas, listas multienlazadas doblemente encadenadas. listas
circulares con punteros a la cabeza, etc. Además. se pueden emplear los campos de
encadenamiento de otras fonnas, dando lugar a estructuras no lineales que pueden alcanzar

altos grados de complejidad, aunque ello escapa a nuestro interés en este momento.





Introducción a los métodos formales de especiﬁcación.

Concepto y propiedades.

El diccionario de la Real Academia Española deﬁne especiﬁcar como: "Fijar o
detenninar de modo preciso". Sabemos que es exactamente eso lo que hay que hacer con
cualquier problema para el que se quiera formular un algoritmo: explicar con claridad todos
los aspectos relevantes del mismo. La especiﬁcación del problema es un paso previo a la
implementación del algoritmo: debe describir qué es lo que se espera que el algoritmo haga,
pero no es su función describir cómo debe hacerlo —la separación entre el que’ y el cáma es
una de las reglas de oro de la buena programación.

La especiﬁcación persigue dos objetivos complementarios: (l) al implementador le
sirve para saber cómo debe de comportarse la aplicación que implementa y le permite buscar
la mejor manera de conseguirlo, (2) al usuario —ﬁnal o implementador de una aplicación que
usa un módulo especiﬁcado— le sirve para saber cómo debe usar la aplicación o módulo en
cuestión —que' información debe proporcionarle y cómo, y que’ infon-nación recibirá a

cambio.

La especiﬁcación y el ciclo de vida del software.

Un programa siempre —aunque se percibe más cuando es complejo— pasa por una
serie de etapas en su desarrollo: análisis de requerimientos, diseño, implementación y
validación y/o veriﬁcación. En la etapa de análisis de requerimientos la especiﬁcación capta
los elementos del problema, centra lu ideas que pudieran estar difusas y perﬁla los detalles
que determinarán la correcta implementación de la aplicación a desarrollar. Por ejemplo, ante
el enunciado ”se tiene un vector ordenada de enteros y se desea desarrollar un
procedimiento para insertar un valor de jbnna que se mantenga el arden entre las
elementos" surgen inmediatamente varias dudas que son fundamentales para saber qué es lo
que se quiere realizar: ¿Cuál es el tamaño máximo del vector? ¿puede haber elementos
repetidos? ¿ordenado signiﬁca en orden creciente]. Sólo cuando todas las preguntas hayan
sido resueltas tendremos un conocimiento preciso de lo que hay que hacer.

En la etapa de diseño se estudia cómo implementar el algoritmo más adecuado; se

divide el problema en subproblemas que se estudian por separado y generalmente se
l0l

desarrollan módulos independientes para resolverlos. Hay que especiﬁcar la ﬁmción de cada
subproblema y su relación con el conjunto prestando especial atención a la deﬁnición de las
interfaces de los módulos a desarrollar para cada uno. La correcta especiﬁcación de esta etapa
permite la implementación y prueba separada de cada módulo y su integración posterior sin
problemas para conformar la solución ﬁnal‘

Tras la implementación se puede usar la especiﬁcación en la etapa de
validación/veriﬁcación para deﬁnir casos de pmeba o para veriﬁcar formalmente el
funcionamiento de los algoritmos desarrollados.

Finalmente, la especiﬁcación interviene en la documentación del programa, tanto
intema —eomentarios insertados en el códígo- como extema —manuales de referencia y
uso—; esta ﬁmción sirve tanto para informar al usuario ﬁnal como para ayudar en la fase de
mantenimiento del programa posterior a su entrega y facilitar la realización de las revisiones

que fuesen necesarias.

Propiedades de la especiﬁcación.
Una especiﬁcación ha de ser:
(l) consistente, manteniendo coherencia lógica sin incurrir en contradicciones.
(2) completa, describiendo todos los aspectos del problema,
(3) precisa, describiendo los detalles con exactitud y

(4) realizable, pudiéndose implementar de forma práctica.

La especiﬁcación como contrato: precondiciones y postcondiciones.

Si está bien fonnulada, en la especiﬁcación de un problema se pueden identiﬁcar dos
partes: (l) la descripción de cómo deben ser —que’ condiciones deben cumplir— los datos
que se suministrarán al algoritmo para su proceso y (2) la descripción de las condiciones que
deben cumplir los resultados elaborados por el algoritmo para poder ser considerados una
solución válida al problema. Como lo primero especiﬁca las condiciones que deben cumplir
los datos antes (üviamente) de que el algoritmo los procese, recibe el nombre de
precondicíoner; asimismo lo segundo recibe el nombre de postcandicianex porque especiﬁca
las condiciones que debe cumplir la solución después (pLteriormente) de que el algoritmo la

ha elaborado. Por ejemplo, si vamos a calcular la raíz cuadrada de un número real con una

l02

determinada aproximación, el número en cuestión deberá ser positivo o no podremos intentar
el calculo —precondición—— y la solución no es cualquier número real, pero si cualquiera que
esté dentro del margen de aproximación especiﬁcado —postcnndición.

El par precondíciones/postcondiciones viene a constituir una especie de contrato que
compromete el correcto funcionamiento del algoritmo desarrollado, subordinado a que se le
proporcionen datos con las características adecuadas. Eventualmente se pueden incorporar a
ese contrato restricciones que obliguen a que la solución adoptada cumpla determinados
requisitos de implementación tales como la limitación en el uso de los recursos del

ordenador.

Lenguaje de especiﬁcación formal.

Una de las propiedades fundamentales de cualquier especiﬁcación debe ser la
precisión y claridad de su enunciado; desgraciadamente esta no es una caracteristica
dominante en el lenguaje natural. Por ello es conveniente fonnalizar las especiﬁcaciones
utilizando un lenguaje controlado; ejemplos típicos son las especiﬁcaciones pre/post de
algoritmos usando lógica de predicador‘ o las especiﬁcaciones algebraicas de Tipo:
Abstractas de Datos.

Cuando se usan predicados para especiﬁcar problemas diremos que un predicado
deﬁne —especiﬁca— aquellos estados que lo satisfacen; los predicados contradictorios no
sirven para especiﬁcar nada y las tautologías no marcan ninguna condición —si se pone una
tautologia como precondición el algoritmo deberá funcionar bajo cualquier circunstancia, y si
se pone como postcondición será correcto haga lo que haga. Las variables libres de los
predicados usados en una especiﬁcación designan información que se reﬂejará en variables
del algoritmo mientras que las. ligadas juegan un papel puramente operacional en la
deﬁnicion de los predícados, por esta razón algunos autores proponen el uso de letras griegas
para simbolizar las variables ligadas ya que las letras griegas no se pueden usar como
nombres de variables en los lenguajes de programación más extendidos y de esta manera se

ayuda a clariﬁcar las especiﬁcaciones.

5 Ver apéndice ‘Introducción a la lógica de prédicados‘
¡O3

Especiﬁcación pre/post usando lógica de predicados.

La especiﬁcación formal de un algoritmo está formada por tres elementos: (l) la
interfaz —cabecera y descripción de parámetros- del algoritmo, (2) la precondición ——un

predicado cuyas únicas variables libres son los parámetros de entrada o de entrada/salida del



algoritmo— y (3) la postcondi ón —un predicado cuyas únicas variables libres son los
parámetros de cualquier clase del algoritmo. El siguiente ejemplo muestra la especiﬁcación
fonnal de un procedimiento llamado RaizCuadrada con dos parámetros reales —x,y— que
debe calcular la raiz cuadrada de x para devolvcrla en y.

procedimiento Raízcuadrada (x,y)
variables entrada real x
salida real y

(pre :(x 2 0))
(posnty 2 o) /\ (abs(y'y - x) s 0,00009}

Si lo que se quiere especiﬁcar es una ﬁmción usaremos su nombre y parámetros para

designar el valor resultante de la ejecución de la función.

función real llaízCuadradahc)
variables entrada real x

(pre zlx > 0))
(post: Raízcuadradalx) = y /(y 2 0) /\ (abs(y‘y - x) s 0,00009)

Si el algoritmo no es un procedimiento ni una función no tendrá parametros, pero
seguramente tendrá que interaccionar con el usuario a través de los dispositivos de
entrada/salida —los procedimientos y funciones también pueden hacerlo si es necesario.

Reservaremos las palabras ENTRADA y SALIDA para designar los respectivos ﬂujos de datos

desde la entrada y hacia la salida estándar.

algoritmo Raízcuadrada
(pre : ENTRADA : x / (x 5 real) /\ (x 2 0))
(post: suma = y / (y e real) A (y 2 o) A labsly’)! e x) s 0430005))

Si la estructura de los datos de entrada o salida es compleja se puede recurrir a
mecanismos de descripción más elaborados; los mismos mecanismos se pueden utilizar para
describir la entrada/salida desde ﬁcheros. En cualquier caso, este tipo de descripción entiende
la entrada/salida como ﬂujos secuencíales de datos —no se aborda, por ejemplo, la
especiﬁcación de una interfaz gráﬁca de usuario —es un problema de diseño gráﬁco más que
de especiﬁcación de algoritmos.

Una cuestión importante es cómo expresar la modiﬁcación que sufren los parámetros
de entrada/salida de los subprogramas. Supongamos que queremos desarrollar un

104

procedimiento para intercambiar el valor de dos variables enteras, A y B. No se necesita
ninguna precondición especial aparte de que sean de tipo entero, pero ¿cómo podemos
expresar la postcondición de que al ﬁnal sus valores hayan sido intercambiados. es decir, que

A tenga el valor inicial de B y B tenga el valor inicial de A?

pzocadhniento Intercambía (A, a)
variables entrada/salida enteras A, e
(pre ; ninguna)

(post: (A = a) /\ u: = m)

Evidentemente la postcondición anterior es incorrecta; lo que expresa es que al
ﬁnalizar la ejecución del procedimiento A y B son iguales. Se necesita algún mecanismo para

distinguir el estado de una variable después de la ejecución con respecto al que tenía antes.

Usaremos un apóstrofe (') para hacer dicha distinción.

procedimiento Intercambia (A, B)
variables entrada/salida enteras A, a
(pre ; ninguna)

(post: (A' = B) /\ 03' = m)

Con la convención establecida la poscondición dice que A después de la ejecución
(A') debera tener el valor que tenia B antes de la ejecución (B), y que B después de la
ejecución (B) deberá tener el valor que tenía A antes de la ejecución (A). Para mantener una
cierta ortogonalidad en las expresiones es adecuado incluir en esta convención los parámetros
de sólo salida —aunque su valor "antes" sea irrelevante, estaríamos expresando que todo lo
que tenga apóstrofe ha sido modiﬁcado por el algortimo. En este caso la especiﬁcación del

procedimiento RaízCuadrada debe modiﬁcarse tal como se reﬂeja a continuación.

procedimiento RaizCuadrada (x, y)
variable: entrada rea]. x
salida real y

(pre :(x 2 0))
(post:(y' z o) /\ (abs(y'*y' - x) s o,oooo5))

En caso de que una especiﬁcación resulte muy compleja, se puede descomponer
deﬁniendo funciones auxiliares de una forma similar a como se hace en el diseño descendente
de programas. Las funciones de especiﬁcación tienen como objetivo simpliﬁcar la expresión
de los predicados pre/post —no deﬁnen subprogramas que tengan que ser implementados. En
el siguiente ejemplo se especiﬁca un procedimiento para insertar sin repetición un elemento

en un vector ordenado; la especiﬁcación tiene que expresar que el vector ha de estar ordenado

l05



antes de la inserción y debe seguir ordenado después, y que se añade sólo si no está ya en el

vector.
procedimiento InserCar1V,N,E)
variable entrada/salida entero vtloo] [Vector ordenado de enteros.
natural N [Número de elementos en V.
entrada entero E {Elemento a insertar en V.
(sea:
ordenadoívía b]; s «¡voce e aHbtAm < B):(V[0(] < vmn)
Está(V[a..b],E s (3a e a..b / vw] t 3))
(pre : (N s o..99) /\ tordenadotvlLdm)
(post:

(no Está(V[1..Nl,E)) -°
(mv = N + 1) /\ (Drdenado(\l‘[1..N']) /\ (zscátvunum) /\
(Ver E IIIN): (Está(V',N',V[a])
Esr.á(V,N,E) — tw = N) A (v' = v))

Obsérvese que la función Ordenado no sólo eaablece cuándo un vector está ordenado
de menor a mayor, sino que además exige que no haya elementos repetidos —al usar < en
vez de s. La precondición especiﬁca que el vector a la entrada debe estar ordenado —según
las condiciones de la función 0rdenad0— y que debe existir espacio para la inserción —N
menor que el número máximo de elementos del vector—, pero no exige que el elemento a
insertar no este’ ya en el vector. La poslrcondición se halla dividida en dos panes dependiendo
de si el elemento a insertar estaba o no en el vector de entrada. Si estaba no se modiﬁca nada.
mientras que si no estaba debe estar, y también todos los demás elementos que si estaban.

La utilización de las funciones auxiliares con nombres signiﬁcativos —0rderu1da,
Está- pennite que los predicados pre/post sean mucho más simples de entender en primera

instancia —aunque luego haya que recurrir a la cláusula sea para ver los detalles.

Ejemplos de especificaciones.

Se presentan en este apartado las especiﬁcaciones fonnales de algunos de los
algoritmos mostrados en los capítulos anteriores acompañadas de su explicación en lenguaje

natural.

función real Máximo(V,N)
variables entrada natural N
real viso]
(pre: N s 1..5o}
(post: Máximo = m /((3o« e 1..N / vta] = m) /\ (vs s 1..N: V[B] s mH)

l06

Explicación: Una función real llamada máximo que toma un vector de reales con rango de
indice 1.50 y un número natural comprendido entre l y 50, y devuelve un valor del subvector

V[ l ..N] que es mayor o igual que cualquier otro valor de ese subvector.

función lógica Primo (p)

variables entrada natural p

(pre: ninguna)

(post: Primo (p) 2 ((\1y e Nalural)/\(y n 1)A(y s p): (p mod y e 0)) )

Explicación: Dado un número natural, p, la ﬁmción lógica Primo(p) devuelve verdadero si no

existe ningún número natural distinto de l y de p que sea divisor de p.

procedimiento Ordenselección (V, N)

variables
entrada entero N (m de elementos del Vector)
entrada/salida entera v[5o] (Vector a ordenar)

(sea:
(Ordenado(V[a..b])) s (VB e a..b)/\(\1u s a..B):(V[ot] s vlﬁll)

(Frecuencia (V[a. .b] ,E) E
Il o Frecuencia(V[a+1. .b] ,E) Si VIa] : E
|u o Frecuencia(V[a+1..b],E) si V[a] s E

(pre: u g 5o)
(post: Ordenadclv‘ [1. .111) /\

(vu e 1. .N: FreCuenCia(V[1..NI,V[u]) Frecuenciaw‘ [1. .N] ,V[a] ))

Explicación: dado un vector de elementos enteros con rango de índice l..50, V, y una
variable natural, N, menor o igual que 50, el procedimiento Ordenselección reorganiza los N
primeros elementos del vector de forma que quedan ordenados entre si de menor a mayor.
Los elementos del vector después de ordenar son los mismos que antes de ordenar y con el

mismo número de apariciones.

procedimianto Mezcla(V1,V2,V3,N1,N2)
variables
entrada enteras V1[50] , V2[50] , N1, N2
salida entera V3 [100]
(sea:
(0rdenado(V[a. .b] l) í (VB E a. .b)/\(Vu s a.-B) z (Vlotl s VHS] ))
(Frecuenciatvla, .b] ,13) 2
11 + Frecuencia(V[a+1..b],E) si V[a]

E
IO + Frecuencia(V[a+1. .b] ,13) si V[a] E

«¡a

(pre: (N1 s 50)/\(N2 s 50)/\
(ordenadow1 n, .N1] J )/\(0rdenado(V2 [1 . .112] ) ))
(pose:
(0tdenado(V3' [1..N1+n21)) /\
¿(va e 1. .111; Frecuencialvav [1. 311m2] ,v1[u]) =
Frecuenciawl [1. .N1] ,V1[or] )+Frecuencia(V2 [1. .N2] ,Vl[o1] ))
(Ver e 1. .N2: Frecuenciawj‘ [1..N1+N2] ,V2[u]) =
Frecuencia(v1[1..N1],V2[o<1)+1=recuencia(v2[1..N2],v2[u]))

l07

Explicación: dados dos vectores ordenados se genera un tercero también ordenado que

Contiene todos los elementos de ambos vectores.

procedimiento InsertarBnOrden (L, V)
variables entrada/salida PLista L
entrada Tipovalcr v
(sea:
OrdenadolL) E (L : NULO) V (Lásíguiente = NULO) V
(Knaïnro s LﬁSiguiente/dnfo) A
(Ordenado (Lasignience-unto) t)
Frecuencíallqlï) E
lo si (L : NULO)
¡o + Frecuencia(Lasiguieneej) si (L r NULO) A l(L >Info v E)
Il + Frecuencia(Lesiguientej) si (L a‘ NULO) /\ (Leﬂnfo = E)

l

(pre: ordenadom)
(post: Ordenadom‘) /\ (Frecuenciamhv) : Frecuencia(L,v) + 1) /\
Va e Tipovalor: Fzecuenciamua) : Frecuenciaﬂuu)
l

Explicación: Dada una lista ordenada y un valor. se modiﬁca la lista de manera que el valor
aparece en la misma una vez más de las que aparecia, el resto de la los elementos de la lista

permanecen igual y la lista sigue ordenada.

Cumplimiento de las especiﬁcaciones: Corrección, robustez y amigabilidad.

La especiﬁcación entendida como un eontmto delimita las responsabilidades del
ímplementador y el usuario; este no está obligado a dar más que lo ﬁjado en las
preeondíciones pero aquel sólo queda obligado a que el programa funcione correctamente
cuando se ejecuta en las condiciones estipuladas. y no tiene ninguna obligación cuando las

precondiciones se incumplen. Por ejemplo. dada la especiﬁcación:

procedimiento Raízcuadrada (x, y)
variables entrada real x
salida real y
(pre :(x 2 0))
(post:(y' 2 o) A (abs(y'*y' — x) s o,oooo5))

El siguiente algoritmo es correcta:

procedimianto Raízcuadrada (x,y)

variables entrada real x
salida real y
local real z

[08

mientras abSÜt r Z) >= 0.00005 hace:
31* ((x/yl +y) /2
z " Y ' Y
fin mientras
retornar
fin procedimiento

El problema es que, aunque la precundicrón establece que x debe ser mayor o igual
que cero, dado que es una variable de tipo real el usuario podría pasar un valor negativo. Al
no cumplirse la precondición el diseñador del algortimo puede optar por cualquier opción
desde dejar que el algoritmo pueda abonar hasta que no acabe nunca ——como ocurre en este
caso. Puede elegir modiﬁcar el algoritmo de forma que ante un incumplimiento de la

preoondición se minimicen los posibles efectos indeseados:

procedinianto Raizcuadrada (x, y)
variables entrada real x
salida real y
locsl real z
si x 2 0 entoncas
y * x / 2
z " Y * Y
mientras abs(x v z) >= 0.00005 hacer
Y‘*((X/Y) +Y)/2
z e Y * Y
ﬁn mientras
ﬁin si
retorna:
un procedimiento

Tenemos ahora un algoritmo más robusta: los errores del usuario no le penurbzrn, no
abona ni entra en un ciclo inﬁnito, sino que siempre acaba, aunque si los datos de entrada son
erróneos el resultado que entrega es igualmente erróneo. Lo único criticable es que no
muestra demasiada consideración hacia el usuario —que tampoco la ha tenido——; sería más
amigable que se indicase de alguna manera que el resultado no es correcto para dar la
oportunidad al usuario de hacer alguna comprobación a posteriori —aunque si ha sido tan

descuidado como para no respetar la precondición es poco probable que las haga.

procadimianto RaizCuadrada (x, y)
variables antrads real x
salida real y
locsl real z
si x 2 0 entonces
y ‘r x / 2
z e Y ' Y
mientras abslx - z) >: 0.00005 hace:
ye (tx/y) +y) /2
z e Y * Y
Ein mientras

[09

ai no
Y ‘ "1
un si
IGCOIHSZ‘
ﬁn procedimiento

En la última versión del algoritmo se ha optado por indicar el error asignando -l al
parámetro de salida. Se ha podido tomar esta decisión porque el rango de valores válidos de y
como solución de la raíz cuadrada no cubre el rango de valores de su tipo Ay tiene que ser
mayor o igual que cero y quedan los negativos para asignar códigos de error. Si no hay
valores inválidos que se puedan usar como códigos de error y no se quiere o no se puede
modiﬁcar la interfaz, se puede recurrir a los mecanismos de resolución de excepciones que
ofrezcan los lenguajes a los que el algoritmo vaya a traducirse.

Cara al usuario ﬁnal la amigabilidad de un programa implica que le proporcione
ayuda, le informe de las causas de los errores que se produzcan y le de la oportunidad de

corregirlos y continuar la ejecución.

Apéndice: Introducción ala lógica de predicados.

Deﬁnición.

Un predicado es una aﬁrmación; por ejemplo "x es mayor que cero", que formalmente
se expresa como: x > 0. Un predicado elemental —re'rmino— puede ser: una variable lógica,
una constante lógica, una función lógica —en este contexto una función lógica es un
predicado formado por un nombre y una lista de argumentos entre paréntesis, como Par(x) o
Primo(x)— o una expresión relacional. Un predicado no elemental se puede formar como la
negación de un predicado (mP), la disyunción de dos predicados (P V Q) o la conjunción de
dos predicados (P A Q) —en deﬁnitiva, una expresión lógica. También se forma un predicado
relacionando otros dos mediante una implicación (—». leido si  entonces ...) o un
bicondicional (n, leido  si y solo si ...).

Dado un predicado, denominaremos estado a cualquier posible asociación de valores
a sus variables. Se dice que un estado satisface un predicado si el predicado es verdadero para
ese estado. Un predicado es sarísfacible si existe al menos un estado que lo satisface. El

conjunto de estados para los que un predicado se satisface constituye su dominio de verdad.

lll]

Un predicado no satisfacible es una contradicción. uno que se satisface siempre es una
raulalagia. Decimos que un predicado, P, es mas fuerte que otro, Q, si el conjunto de estados
deﬁnidos por P es un subconjunto propio“ del conjunto de estados deﬁnidos por Q. Un
predicado se debilita al añadir disyunciones y se fonalece al añadir conjunciones.
(x>0)V(x=0):(x>0):(x>0)/\Par(x)

Equivalencia.

Dos predieados, P y Q, son equivalentes —simbolizado P e Qv si siempre que uno es
verdadero el otro es verdadero y siempre que uno es falso el otro es falso —se satisfacen
exactamente en los mismos estados. Decir que dos predicado, P y Q, son equivalentes es lo

mismo que decir P - Q. La equivalencia sigue las siguientes leyes:

Leyes de la equivalencia

Identidad: P s P

Negación: 1*?) z P

Exclusión del termino medio: P V "P 2 verdadero

Contradicción: P /\ “P s falso
Ccnmutativa: P V Q z Q V P
P /\ Q s Q A P
Distributiva: P A (Q v R) z (P A Q ) V (P A R)

PV(Q/\R)E(P vomawk)

Asociativa; ¡wo/ima (PAQ)/\R
Pv(QvR)s(PvQ)vR

Simpliﬁcación de la P V P z P
disyunción: P V verdadero s verdadero

Pvfalsoal’
PV(PAQ)sP

" Un conjunto, A, es un subconjunto propia de otro, B, si todos los elementos de A son elementos de
B pero existe algún elemento de B que no es elemento de A.
l l l

Leyes ¡‘le la equivalencia

Simpliﬁcación de la P /\ P z P
conjunción: P /\ verdadero 2 l’
P /\ falso 2 falso
P /\ (P v Q) s P
Leyes de De Morgan: 1P V Q) 2 '*P A ﬁQ
‘(P /\ Q) í ‘l’ V ﬁQ
Ley de la implicación P =- Q s ‘P V Q
Ley del bicondicional P - Q E (P -= Q) /\ (Q — P)

Usaremos el símbolo z para deﬁnir un predicado mediante una equivalencia, por
ejemplo. la siguiente expresión: "Par(x)í(x mod2:0)". deﬁne el predicado Par(x)

estableciendo su equivalencia con (x mod 2 = 0).

Cuuutiﬁcadores.

Al enunciar un predicado es necesario exponer cuál es su dominio de verdad. esto
suele implicar frases del estilo de: "el predicado se cumple gara todos los valores de x que ..."
o "existe atgún (algunos) valor de x que cumple  y satisface el predicado". Para formalizar
esta clase de expresiones existen el cuantiﬁcador universal (V, leído "para todo...") y el
cuantiﬁcador existencial (E, leído "existe algún..."). Junto con los cuantiﬁcadores usaremos
los símbolos "/" (tal que ...) y "z" (se veriﬁca. se cumple que ...), además de los propios del
álgebra de conjuntos —un dominió es un conjunto de estados.

Primo(x) a ((Vy s Natural)/\(y ; l)/\(y c x): (x mod y s 0))

Se deﬁne que x es primo si gara todo y natural distinto de l y de x se
veriﬁca que x no es dívísible por y.
(Ex c Natural) / *PrÍmo(x)

Se aﬁrma que existe algún número natural que no es primo.

Las variables que en un predicado aparezcan afectadas por un cuantiﬁcador se
denominan variables ligadax —al cuan\iﬁcador—, el resto se denominan variables libres. En

|l2

los ejemplos anteriores x es libre en el primer predicado pero ligada en el segundo e y es
ligada en el primero.

Si un predicado está afectado por una cuantiﬁcación universal y el dominio de valores
de la variable ligada al cuantiﬁcador resulta ser el conjunto vacío, el predicado se considerará
verdadero —"Para todos los elementos de C se cumple P" es equivalente a "No hay ningún
elemento de C para el que no se cumpla P"; si C es el conjunto vacio lo segundo se cumple, y
en consecuencia también lo primero. De forma similar. si un predicado está afectado por una
cuantiﬁcación existencial y el dominio de valores de la variable ligada al cuantiﬁcador resulta
ser el conjunto vacio, se entenderá que el predicado es falso. En los siguientes predicado: el
dominio de valores de x se expresa como un rango —cosa frecuente— que es vacío si N < l:

(VX e 1>IN:V[X]> 0)

(sx e l..N/ V[x] > 0)

Vistos en detalle, los cuanliﬁcadores universal y existencial no son más que la
acumulación de las operaciones de conjunción y disyunción:
(vx s LN: V[x] > 0) 2 (V[l] > 0) /\ (V[2] > 0) A  A (V[N] > O)
(Ex e1..N/V[x]> o)2 (v[1] > o) v (V[2] > o) v  v (vm > o)

En matemáticas estamos acostumbrados a otros simbolos que expresan la

acumulación de una operación: el producto (H) y el sumatorio (D. Estos cuanliﬁcadores

pueden también resultar útiles en la construcción de predicados.

ll}

Elementos básicos de programación (l).

El ordenador como máquina de proceso de información.

La informática es el conjunto de conocimientos cientiﬁcos y técnicos que se ocupam
del tratamiento de la infomiación por medio de ordenadores. Un ordenador cs una máquina
para procesar información, elaborándola y transformándola. Una máquina de proceso consta
de: una entrada por donde se introduce la materia prima, una unidad de proceso donde se
realiza el proceso propiamente dicho, y una salida por donde se obtienen los productos
elaborados. En un ordenador los dispositivos de entrada típicos son el teclado y el ratón. la
salida se realiza habitualmente a través de un monitor de vídeo, y el proceso se lleva a cabo
en la unidad central de proceso, que aloja el procesador junto con dispositivos para la

representación y almacenamiento de infonnación y otros elementos de control.

Disms os de salida






Impresora

’ " Unidad de Proceso
l nidades de

al macenamiento




ÉFIoppy dnvcr (FD)

Hard DIsku-ID]

ﬁ Procesador



Dism de entrada emo

n Controladores
de dismsitivos

Ilustración I Partes de un ordenador

Un proceso es un conjunto de acciones que se realizan para conseguir un resultado. El
ente activo encargado de llevar a cabo estas acciones es el procesador. En un ordenador el

procesador es un circuito electrónico capaz de reaccionar a detenninados conjuntos de

estímulos electricos que se identiﬁcan como instrucciones —para ejecutar ncciones- o
como datos —que componen la información en proceso.

Para que un procesador pueda realizar un detenninado proceso —necesario para la
resolución de un problema—— hace falta programas-lo. Un programa informático deﬁne la
representación de los datos que integran tanto la información a procesar como los resultados
esperados (estructuras de datos), y describe la secuencia de acciones (algoritmo) que, en
función de los datos de entrada, se deben ejecutar para obtener la solución buscada.

El conjunto de dispositivos ﬁsicos que conforman un ordenador se denomina
hardware; el conjunto de programas que hacen funcionar esos dispositivos de forma

adecuada recibe el nombre de software. ' '-

El desarrollo de un programa comprende tres fases principales: (l) álisis y dise}o,)

en la que se estudia el problema y se eligen las estructuras de datos y los algoritmos para
resolverlo, (Zlcodiﬁcación y depuraeiﬁnfen la que se escribe el programa y se corrigen los
errores que puedan aparecer y (3) igmtenimiento) en la que se realizan actualizaciones y

correcciones de problemas detectados durante el uso del programa.

Lrrueunuár’ l

7 if" {Tel v

_ Programa esaïiïpor el " p ’ ’
cano: de ‘ y , ____ Iograma ejecutable
o  e 1335233.932: 3a.. _ >  i >Lev wwe

ñ o  l‘

Inlemcnin

EJccma
l
V



l Pmgííníndar l

Ilustración 2 Codiﬁcación de un programa

Un programa se escribe utilizando un lenguaje que el procesador encargado de
ejecutarlo comprenda. En realidad, un procesador infon-nático sólo comprende un lenguaje de
ceros y unos (lenguaje máquina) que representa los impulsos eléctricos a los que responde.

Dado que para un programador humano resulta muy diﬁcil componer aplicaciones con un
2

lenguaje tan falto de abstracción, se han desarrollado lenguajes de programación de "alto
nivel" que utilizan simbolos, palabras y reglas de composición más próximos a un lenguaje
natural humano, aunque muy simpliﬁcado y sin las ambigüedades de este. El programa
escrito en un lenguaje de alto nivel es traducido a lenguaje máquina por otro programa —un
compilador o un intérprete—, a ﬁn de que el procesador pueda ejecutarlo; pero el efecto es
que el programador escribe su programa como si existiese un procesador virtual capaz de
entender el lenguaje de alto nivel.

Muchas veces se suelen escribir algoritmos generales utilizando un pseudolenguaje,
el cual suele parecerse a un lenguaje de programación, pero pennitiendo algunas libertades
que faciliten la descripción del algoritmo sin preocuparse de algunos detalles sintácticos que

se tendrán que concretar al trasladarlo a un auténtico lenguaje de programación.

Concepto de algoritmo.

La palabra algoritmo deriva del nombre del matemático persa del siglo IX Mohammed
¡bn Musa aLKhowárizmí, autor de un libro sobre como operar con el sistema decimal de
numeración originario de la India, libro que, tras ser traducido al latín, fue origen de la
adopción de este sistema en Europa. La característica más relevante de las operaciones
descritas (suma, resta, multiplicación y división) es que se pueden realizar de forma
mecánica: basta con seguir los pasos indicados para obtener una solución correcta sin
necesidad de ningún conocimiento teórico adicional.

La ENCICLOPEDIA DE CIENCIAS DE LA COMPUTACIÓN‘ deﬁne cl término en función de un
problema y un dispositivo que se va a usar para solucionarlo: un algoritmo es una
descripción _pr_ecisa de un metodo para solucionar el problema escrito en un lenguaje
comprensible para el dispositivo que debe cumplir las siguientes propiedades:

l. al aplicarlo a un caso concreto del problema, da lugar a la ejecución dc_una secuencia

ﬁnita de acciones,

2. dicha secuencia tiene una única acción inicial,
3. cada acción en la secuencia tiene una única sucesora, y
4. la secuencia termina en un tiempo ﬁnito encontrando una solución o determinando

que no existe una para ese caso panicular.

‘ENCYCLOPEDIA OF COMPUTER SCIENCE. lEEE Press. New York, 1993. ISBN 0-442-27679-6
3



g mglo: algoritmo de resolución de gcuaclones do «mudo grado
identiﬁcar los coeﬁcientes: a, b, c

2. calcular bz

3. calcular 4ac

4. restar bz - 4ac

5. calcular la raiz cuadrada de] resultado anterior

6. sumar -b al resultado anterior

7. calcular 2a

8. dividir el resultado del paso 6 por el resultado del paso 7 para obtener la l‘ solución
9. restar el resultado del paso S a -b

10. dividir el resultado anterior por el resultado del paso 7 para obtener la 2“ solución

Nótese que en la deﬁnición de algoritmo no se hace ninguna suposición acerca de la
naturaleza del problema ni del dispositivo que se va a usar para resolverlo. Son validos
cualquier clase de proceso y cualquier dispositivo (incluyendo un ser humano) capaz de

ejecutarlo.

Fiemglo: algoritmo gara poner en marcha un coche
‘l. poner el coche en punto muerto

«2. pisar el embrague

‘S. llevar la palanca de cambios al punto muerto
‘4. introducir la llave en el contacto

girar la llave hasta el punto de arranque

‘S. soltar la llave

‘7. poner primera

8. pisar el embrague

‘Q. llevar la palanca de cambios a la posición de la primera marcha

‘lo. poner las manos en el volante J

l l . acelerar suavemente al mismo tiempo que se suelta el embrague

Un algoritmo describe un método determinista: ante las mismas entradas se generará
la misma secuencia de acciones, que conducirán al mismo resultado de la misma manera.
Podríamos decir que un algoritmo establece una aplicación entre el espacio de casos solubles
de un problema y el espacio de soluciones del mismo, de tal manera que, a cada caso del

problema le hace corresponder una solución.





 —É t"



Espacio a.

deﬁnición del solucione:
Problem: delPrnhlemI

Ilustración 3 Elementos que interactúan en la solución de problemas

En resumen, las dos caracteristicas esenciales de un algoritmo son: tinitud «siempre
acaba proporcionando una solución o detenninando que no existe ninguna- y el
determinismo —siempre produce los mismos resultados para los mismos datos.

Para poder formular una algoritmo que solucione un problema, éste debe estar
especiﬁcado con claridad; si, por ejemplo, planteamos el enunciado: "calcular la raiz
cuadrada de un número real, x", no podremos encontrar ningún algoritmo que lo satisfaga
dado que la raiz cuadrada de un número real cualquiera tiene, en general, inﬁnitos decimales,
por lo que no es posible calcularla con un número ﬁnito de acciones.

Si restringimos el problema y pedimos, por ejemplo: "calcular la raiz cuadrada
positiva de un número real, x, con una precisión de cuatro decimales", ya será posible
proponer un algoritmo, puesto que hemos introducido una condición (la limitación de la
precisión) que permite alcanzar un resultado con un número ﬁnito de pasos; además se ha

precisado otro matiz, que estaba ambiguo, al indicar que queremos la raíz positiva.





 3 u,“ :

u t"

v
No obstante, no todas las soluciones que propongamos constituirán un algoritmo, Por

ejemplo:



l elegir un número, y, y calcular y?’ ‘

si |yz  < 5 * l0'5 la solución es y, terminar; si no repetir desde el paso l



zm}
do de elección de los sucesivos valores de

//" 7

no es un algoritmo, ya que no se establece el m
y, lo que impide garantizar que el proceso tennina. Podemos utilizar otro método; el‘ siguiente

es conocido como método delNewton-Raphsonzl

l ísleay=xl2ii Q I‘

4. Á _ ¿,1 _., /, 1,,’ , ,4 _,»



calcular yz
h si |y2 - x | <5 * l0'5 la solución es y, terminar; si no hacer el paso 4
recalcular y como «x/y) + yﬂiïty repetir desde el paso 2
./Í/ » . «, Ju}.

Este método produce una solución adecuada siempre que el número x sea positivo
dado que, para cualquier y, la raiz cuadrada de x está comprendida entre ¿gy e i, si y es mayor
que x/y, o entre y y x/y, si y es menor que x/y. La fórmula de recálculo de y —((x/y) + y)/2—
hace que el valor de y converja al valor de la raiz cuadrada de x.

Cuando x es negativo se repiten indeﬁnidamente los pasos 2 al 4, lo que muestra que
esto en realidad es un semialgorítmo, ya que hay estados iniciales para los que no termina ni

hallando una solución, ni concluyendo que la misma no existe. Podemos añadir un paso

previo:

1 si x < 0, no hay solución, terminar

2 sea y = x/Z

3 calcular yz

4 si if - x | < 5 * 10's la solución es y, terminar; si no, hacer el paso 4
5 recalcular y como ((x/y) + y)/2 y repetir desde el paso 2

y tendriamos un algoritmo escrito en un lenguaje adecuado para un procesador humano con

unas mínimas nociones de matemáticas. Si el procesador previsto es un ordenador habria que

6

ﬁ? ,24’  V 4 _ ¿//- l, ‘ //r7¡’l

rcescribirlo en un lenguaje de programación, donde tendría un aspecto similar al que se

muestra en la siguiente pagina, escrito en pseudolenguaje.

algoritmo Raízcuadrada
variables reales X, Y, Z
escribir "Desea Calcular la raíz cuadrada de:
leer X ‘
si X > 0 entonces ' V.  N. h?‘
‘l e x / 2 i ‘ ,r 4; 9
Z e y a y , ,« ,
mientras abs(X - z) >= 0.00005 hace: - h,  , r
‘lv (Kx/Y) +3!) /2
z e ‘l * Y
fin mientras
escribir "La raíz cuadrada es: ", Y M. ,—, .. al . 5.a, ,
si no ïxvïzw n. u. n‘. . ¿t
escribir "no existe una raíz cuadrada real de", x '
tin ei
parar
Ein algoritmo




Todo programa informático es como mínimo un semialgoritmo; gn programa que
siempre termina es un algoritmo. y un algoritmo es correcto si hace lo que se supone que
debe hacer, es decir si cuando se le proporcionan datos adecuados proporciona resultados
correctos según la especiﬁcación del problema para el que ha sido diseñado. Para resolver un
mismo problema pueden existir varios algoritmos diferentes; la elección de uno u otro
dependerá de su eﬁciencia en términos de tiempo y recursos que consuma.

[.21 algorítmica, como disciplina que se ocupa del estudio de los algoritmos y de las
metodologías para desarrollarlos comprende tres facetas‘ cómo construir algoritmos (diseño),

cómo determinar si un algoritmo es correcto (víerjﬁcación) y como medir la eﬁciencia de los

algoritmos (análisis).

Variables, constantes y expresiones.

Variables.

Cuando se escribe un algoritmo se utilizan símbolos para representar los elementos de
información que intervienen en el proceso especm por él. Esto es similar a lo que se
hace al describir una función matemática, por ejemplo, en:

f(x,y) = 3x2 + 5y



x e y son variables, simbolos que se utilizan como comodines para poder expresar la fonna

general de la función. Los valores concretos de f se obtienen dando valores a x e y:

ttl,1)= a
f(l,2)= ¡3
r(1,3) = 18
r(2,1)=17
r(2,2)=22
r(2,3)=27

Sin embargo, mientras una función matemática expresa una correspondencia entre dos
conjuntos de valores (o de un conjunto consigo mismo), un programa informático describe un
proceso de transformación de información; esto signiﬁca que los elementos de infonnación
representados por las variables pueden cambiar a lo largo del proceso, pasando a representar
un valor distinto del original. Por ejemplo, en el algoritmo RaízCuadrada, que usa tres
variables —X, Y, Z—, las variables Y y Z empiezan teniendo un valor dependiente de lo que
valga X y luego van cambiando a lo largo del proceso; supongamos que X toma inicialmente

el valor 9. La siguiente tabla muestra la evolución de los valores de las variables implicadas

en el proceso mientras el mismo se ejecuta.

Iteración X Y Z

0 9,0 4,5 20.25

l 9,0 3,25 10,5625
2 ' 9,0 3,0096 l 5 9,057785
3 9,0 3,000015 9,000092
4 9,0 3,0 9,0

La tabla muestra la traza de la ejecución del algoritmo RaizCuadrada. La traza

flm Ii‘ Íﬁ
visua a__la evolucion del estado de un proceso —entendido como el conjunto de valores de

las variables implicadas- a medida que se ejecuta el algoritmo que lo dirige, a panir de unas



entradas iniciales dadas. Se entiende por iteración ccglagia de l
8

as veces que se repite un

.ngnnnnnnnnnnnnnnndQ0ﬂﬁnﬁfihflﬂﬁhﬁﬂﬂﬂﬁﬁﬁﬁFÜQWÜÍÏÜPÑFPPPPÍ

bucle. Puede ser una herramienta útil en la localización de errores en un algoritmo, aunque en
ningún caso sirve para probar su correcto funcionamiento, ya que este sólo queda probado
para las entradas utilizadas.
Otra diferencia formal entre las variables usadas en matemáticas y las de un algoritmo"
informático es que para las primeras suele usarse una letra como identiﬁcador, mientras que
r las segundas suíelen tener unrnorïltíreí más largo. que se recomienda sea signiﬁcativo, y que
en la mayoría de los lenguajes se forma como una sola palabra empezando con una letra y
continuando con una combinación de letras, números y unos pocos caracteres especiales.
Además, las variables de un programa no son sólo un simbolo abstracto, identiﬁcan la
porción del hardware del ordenador utilizada para representar el valor de la información
simbolizada por la variable. El dispositivo hardware implicado es la QCJIGLÍB, un conjunto
de circuitos organizados desde el punto de vista lógico como una secuencia de celdas

direccionables individualmente. El valor de una variable se almacena utilizando una o más



“‘ . celdas consecutivas, y es accedido a partir de la geccióg de la primera Auna dirección es



una combinación de impulsos electricos capaz de "activar" la respuesta de una celda

individual. El espa (numero de celdas) utilizado por una variable es ﬁmción del tipo de



información que represente. Como el número de celdas de memoria es necesariamente ﬁnito,
el volumen total de infonnación que puede manejar un programa es limitado, lo que hace
necesario un uso racional de la memoria que evite ocupación innecesaria de espacio mediante

una adecuada deﬁnición y estructuración de los datos.

Declaración de variables.
Las variables utilizadas por un algoritmo deben declararse antes de su empleo. Una
declaración especiﬁca cuántas variables van a usarse. cómo se llaman y de que tipo es la

información que simbolizan.

variables reales X, Y, Z
enteras I, J

La declaración cumple un doble propósito: para el lector, informa de los elementos
simbólicos que va a utilizar el algoritmo; para el ordenador, determina cuánta memoria

necesitará el algoritmo para ejecutarse y cómo debe organizarse la misma.

Operacion es elementales.

Las variables son los envases para la materia prima con la que trabajan los algoritmos
informáticos. La acción descrita por un algoritmo gira en tomo ala atribución y modiﬁcación
de valores a las variables. Existen operaciones para incorporar información al proceso en
curso; esta infonnación es tomada "del exterior" y almacenada en una variable. De la misma
manera existen operaciones para enviar "al exterior" la infonnación resultante del proceso.
Estas operaciones se conocen como operaciones de entrada/salida.

algoritmo Raízcuadrada

escribir "Desea Calcular la raíz cuadrada de: "
leer X
si

escribir "La raíz cuadrada es: ", Y
si no

escribir "no existe una raiz cuadrada real de", X
Ein ai
parar
fin algoritmo

La operación que permite cambiar el valor de las variables cuando sea preciso a lo
largo del proceso se conoce como asignación y en pseudolenguaje suele simbolizarse con
una ﬂecha. En la asignación intervienen dos elementos: una variable a la que se le va a dar un
nuevo valor, y un valor que se le va a dar a la variable. Caso de utilizarse una ﬂecha como
símbolo de asignación ésta señalará desde el valor (normalmente situado a la derecha) hacia

la variable (normalmente situada a la izquierda).

algoritmo Raízcuadrada
si...
Y**X/2
Z<’Y*Y
mientras .
Y+l(X/Y)+Y)/2
Z**Y*‘l
fínmiantraa
ﬁin si
parar
tin algoritmo

C unstantes.

No toda la información que se utiliza en un algoritmo necesita almacenarse en
variables; en la implementación del método de Newtonjiaphson hemos empleado los
valores 0.00005 y 2 como constantes numéricas y los valores "Desea calcular la raiz cuadrada
de: ", "La raíz cuadrada es: " y "no existe una raíz cuadrada real de" como mensajes.
Representan valores literales que el algoritmo emplea en los puntos donde aparecen.

Existen ocasiones en las que conviene utilizar constantes simbólicas en vez de
literales. Por ejemplo, si en un algoritmo necesitamos utilizar el número n podemos

asimilarlo al valor 31416 y utilizarlo cuantas veces haga falta:

algoritmo Redondo
vnriable real Radio

escribir "Deme el radio: "

leer Radio

escribir "Círculo: ", 3.1416*Radio*Radio

escribir "Circunferencia: ", 2*3.l416*Radio

escribir "Volumen esférico: ", (4/3)*3Jálñﬂïadicﬂïadiwﬂïadío

para:
fin algoritmo

Sin embargo, si decidimos en otro momento modiﬁcar la precisión del método
utilizando como valor de n 1141592653590 tendriamos que cambiar el valor literal en todos
los sitios donde aparezca, cosa que no tendriamos que hacer si simplemente pudiéramos
deﬁnir un simbolo con ese valor y utilizar ese simbolo donde hiciese falta, de forma que para

cambiarla precisión del algoritmo sólo sería necesariocambiar la deﬁnición del símbolo.

algoritmo Redondo
constante real p 3.14159265359
Variable real Radio

algoritmo Redondo
cen-tanta real pi=3.1416
variable real Radio

escribir "Deme el radio: " escribir "Deme el radio: "

leer Radio leer Radio

escribir "Círculo: ", escribir "Círculo: ",
piﬂladicﬂíadío piﬁïadioﬂïadio

escribir "circunferencia: ", escribir "circunferencia: ",
2"pi*Radio 2*pi*Radio

escribir "Volumen esférico: ", escribir "Volumen esférico: ",
(4/3) ‘piﬂïadioﬂïadioﬂladio (4/3) svpiwxadionzadio-xadio

para: parar

fin algoritmo Ein algoritmo

Una constante simbólica es formalmente como una variable con la restricción de que
no se puede cambiar su valor —por tanto no aparecerá nunca en una operación de entrada, ni

como destino de una asignación.

Expresiones.

Una expresión es un conjunto de operandos ligados emite’ si por ¡operadores que
representa un gg Un operando puede ser un valor, una constante simbólica, una variable o
una función. El valor de la expresión se calcula como el resultado de aplicar los operadores
sobre los operandos en el orden adecuado. Una expresión se dice que es del tipo del valor que
devuelve. Los operadores aplicables dependen del tipo de los operandos

x +3/ l 8

El orden de gadigción dependeícïaí reglas deprecedencia entre los operadores —

un producto o una división habitualmente se deben evaluar antes que una suma o una resta.

Los operadores de irguï precedencia seeyalúanísegnin las reglas de asociatividad del

lenguagnognalmente dgigguierdajgereeha (un ejemplo de operador con asocíatividad de
derecha a izquierda es la exponenciaeión: x"3”2 s x”(3”2)). El orden de evaluación puede

modiﬁcarse mediante el uso de paréntesis:
(x +3)/l s

Tipos de datos.

El tipo es una de las caracteristicas más relevantes de los datos. Es fácilmente
constatable que en el mundo real existen diversas clases de información, tanto por su formato
(numérica, textual, gráﬂcaw), como por su signiﬁcado (volúmenes, masas, velocidades,
sueldos, notas...) En programación, el tipo está relacionado con la clase de infonnación que
se quiere manejar y determina una representación, un rango de valores —que depende de la
representación- y un conjunto de operaciones aplicables a esos valores. Aunque estas tres
características son especiﬁcas de cada tipo, es normal en la mayoría de los lenguajes que se
pennita algún grado de compatibilidad entre algunos tipos concretos: Un tipo, TI, es

compatible con otro, T2, si en cualquier lugar de un programa donde se espera que aparezca

l2

LDHIQQQQGQHGQIIﬁQmQnQlQa-nnn-nonnonnnn-nq-mnninnnnnnn
n...

un valor de tipo T2 se puede usar en su lugar uno de tipo T1; para ello el lenguaje debe
disponer de alguna regla de conversión automática que haga corresponder valores de tipo T1
a valores de tipo T2. Dos tipos son equivalentes cuando son mutuamente compatibles.

La ﬂexibilidad de los lengiajes de programación modemos pasa por ofrecer un
conjunto pequeño de tipos primitivos muy básicos junto con potentes mecanismos para que el
programador pueda deﬁnir nuevos tipos a partir de ellos y de los ya deﬁnidos. Normalmente
existe un conjunto de tipos no primitivos ya predeﬁnidos, por ser de amplia aplicación. Por
tanto, se puede establecer la distinción entre tipos predeﬁnidos —que pueden ser primitivos o
derivados— y tipos deﬁnidos por el programador —que siempre son derivados.

Además, los tipos pueden dividirse en simples y estructurados. Un tipo simple
representa una entidad individual, con un valor indivisible. Un tipo estructurado representa
una clase de entidad que está compuesta de partes identiﬁcables separadamente. En cada caso
se pueden establecer otras clasiﬁcaciones y subdívisiones, por ejemplo, entre los tipos
simples se puede distinguir entre ordinales o discretos y no ordinales. De los que se
presentan a continuación, son ordinales los tipo entero, carácter y, generalmente el lógico,

siendo no ordinal el real.

Tipos de datos primitivos.

Los tipos primitivos son tipos, generalmente simples, que no basan su representación
en ningún otro tipo, siendo normalmente provistos por el hardware. Se pueden enmarcar en
tres categorías: numéricos, lógicos y caracteres.

Debido a las fuertes diferencias en cuanto a su representación óptima en un ordenador,
los tipos numéricos se dividen en reales y enteros; ambos representan un subconjunto ﬁnito
de valores de sus correspondientes modelos matemáticos. En nuestros algoritmos llamaremos
real al tipo que representará números reales, y entero al que representará números enteros. En
los lenguajes de programación se suele tener la posibilidad de optimizar el gasto de memoria
distinguiendo, en función de las necesidades de representación. diversas "longitudes" de tipo
(enteros largos, nonnales, cortos...) lo que implica distintos rangos de valores. Los tipos
numéricos admiten:

- Los operadores aritméticos básicos: +. -. “, /.

- Los operadores relacionales: <, >, I, ,_, L, —aunque, por cuestiones de representación

13

que no vienen al caso, no suele tener mucho sentido comparar si dos números reales

son iguales o no.

- Diversas funciones matemáticas de uso común (Abs, Sen, Cos, Tag,...).

Habitualmente (salvo lenguajes con un tipado muy fuerte) los tipos enteros son
compatibles con los reales, es decir, en cualquier expresión podremos usar un valor entero
donde se espera un valor real. Lo contrario no es cierto, ya que un real puede ser convertido a
mas de un entero, con lo que dicha conversión no puede ser automática. En nuestro

pseudolengu ‘ utilizaremgslas función de conversión: ParteEntera, gue devuelve el valor



emszcaﬂsumeseonsïisnte a, ¡3,Pﬁﬂ3..°'!F°,T,a 69,91 nílmefo real PN 916m9“

ParteBntera(5.75) 5, ParteEnterat-Lﬂl) : -3

Los tipos lógicos son aquellos que representan dos valores (verdadero, falso), y
admiten como operaciones, al menos, la negación lógica, la disyunción lógica y la conjunción

lógica, cuyos signiﬁcados se muestran en la tabla.



 ) onjunc On logica (y A) V elisa
Falso Falso Falso Falso Falso Falso Falso Verdadero
Falso Verdadero Verdadero Falso Verdadero Falso Verdadero Falso
Verdadero Falso Verdadero Verdadero Falso Falso

Verdadero Verdadero Verdadero Verdadero Verdadero Verdadero

La importancia de los tipos lógicos reside en que se usan para controlar la ejecución
de los algoritmos, como veremos más adelante. Llamaremos Iégígjl tipo logico que
waregrgsïn asesina vseuddenzuaïe-

Los tipos carácter sirven para representar caracteres —el diccionario de la Real
Academia deﬁne carácter como "signo de escritura o de imprenta"—, incluyendo
generalmente todas las letras mayúsculas y minúsculas, los digitos del '0' al '9‘, signos de
puntuación, simbolos arítmeticos y otros símbolos especiales, dependiendo del alfabeto
utilizado —el más habitual es el American standard Qode for information Jnterchange (código

ASCII). gas únicas gpeﬁxLicme pggg; ¿entreácaracteres individualesjon las relacionales,



comparaciones entre caracteres basadas en el orden implícito ——4segu¿n ' ¡‘Le

l4

confrontación- dado por la codiﬁcación binaria del alfabeto. En nuestro pseudolenguaje
llamamos carácter al tipo que representa caracteres. Los literales de tipo carácter los

representaremos entre comillas simples: ‘A’, 'a'.

Estructuras algorítmícas de control.

Un proceso se realiza ejecutando una secuencia de

instrucciones, una detrás de otra, al dictado de un algoritmo; pero si



el orden de ejecución tuviese que corresponderse directamente con

el orden en que están escritas las sentencias del algoritmo, no  l

habría posibilidad de escribir algoritmos generales, que fuesen  l

capaces de indicar reacciones diferentes ante la variación de los



datos que confonnan el caso del problema que se este’ tratando en



cada ejecución —vimos como el algoritmo RaízCuadrada hace
cosas diferentes según X sea menor que cero o no, y como, en el segundo caso, el número de
veces que se repite el cálculo de Y y de Z depende del valor de X.

Por tanto, a la hora de escribir un algoritmo necesitamos, además de la facilidad para
escribir una serie de instrucciones con ‘estructura secuencial, otras para poder indicar
variaciones en el ﬂujo de instrucciones que deben ejecutarse, en ñinción de alguna condición
eyaluable.

Bñhm y Jacopini’ demostraron en los años 60 que para escribir cualquier algoritmo
son suﬁcientes, además de la estmctura secuencial básica, una estructura de selección entre
dos posibles ﬂujos de ejecución, y una estructura que permita controlar la repetición de un
conjunto de acciones. .

Dijkstra, uno de los padres de la programación estructurada’, propuso el uso de tres
estructuras del tipo de las enumeradas, caracterizadas por tener un único punto de entrada y
un único punto de salida, lo que permite anidarlas y concatenarlas sin problemas.

Los lenguajes de programación deben ofrecer sentencias de control que permitan

‘Bóhm 8. Jacopini: "Flow diagrama, Turing machines, and languages with only two formation rules".
CACM V9 #5 pp.336_371 (May '66).

’Dijks1ra: "Goto considered harrnful". CACM V11 #3 pp.147_148 (March '68) | Dijkstra: ‘Notes on
structured programming". pp17_19 in Dahl. Dijkstra 8. Hoare: Structured programming Academic
Press 1972.

l5

implementar versiones básicas de las estructuras de selección y repetición —la estructura
secuencial se da por supuesta-g pero la mayoria de los lenguajes no se limitan a ofrecer las
versiones básicas, sino que incluyen variaciones convenientes para facilitar la escritura y la
legihilidad de los programas. El denominador común de todas las variaciones es que siempre
se puede conseguir el mismo efecto usando las versiones básicas. Las versiones más

habituales son las que se muestran en la siguiente tabla.

Estructuras de control

Básica No básica
selección Estructura de selección lógica entre Estructura de selección múltiple
dos altemativas. (proceso por casos)
Estructura repetitiva con una Estructura repetitiva con una
Repeﬁción condición lógica preevaluada. condición lógica postevaluaïla.

Estructura repetitiva controlada por
contador.



Estructuras de selección.

La es_tructura de selección básica es una que permite elegir entre dos posibles
altemativas para el ﬂujo de ejecución en función de la evaluación de una condición de tipo

lógico. Su expresión sintáctica en cl pseudolenguaje que utilizamos ya la hemos visto cn el




algoritmo RaizCuadrada:
si <condición> entoncas Algoritmo
<accíón> RaízCuadrada
si no . . .
<acción si X > o entonces
alternativa> . . .
Ein si si no
o bien, si la acción alternativa es - - -
Ein si
no hacer nada: pu“
  fin hlsoritﬂn

<acción>
fin si



Muchos lenguajes ofrecen además una estructura de selgión múltiple, que

denominaremos de proceso por casos, cuyo efecto se puede conseguir anidando varias

16

C

/

estructuras de selección básicas, aunque el efecto sería un algoritmo con más código y más

diﬁcil de entender.



“gún <9XPreSiÓn> hice! donde cada alternativa tiene una de las siguientes
<alternativa> bmas
<alternativa> l '
. 1 (1)
a1ternatíva> i <etiqueta> <acción>
en ocre caso i (2)
<acción> <etiqueta>. .<etiqueta> <acción>
tin según (3)
<etiqueta>, <etiqueta>, . .. <acción>



La expresión, generalmente, debe producir como resultado un valor ordinal, según el
cual se ejecutará la acción correspondiente a la altemativa que lo tenga como etiqueta. Si el
valor de la expresión no coincide con ninguna etiqueta, se ejecutará la acción englubada por
la cláusula en atru caso, si la hay. Todas los posibles valores de la expresión deben estar en

una y sólo en una d; 18,5 altemativas.

algoritmo Calculadora
variables entera Operación
reales Opl, Op2, Res

leer Operación
leer OpLOpZ
según Operación hace:

1: Res <— Op1+0p2

2: Res v Op1_Op2

3: Res e Op1*Op2 ¿t

4: Res r Opl/opz y /
un según ‘i /
escribir Res , .
parar ‘t’ /
tin algoritmo {Calculadora} \\ /

Estructuras de repetición. / i

La estructura de repetición propuesta por _Dijkstría_ permitía realizan una



,ML
evaluar una condición y,_en función de la misma, ejecutar otra acción y repetir el proceso
desde la primera. No obstante, son pocos los lenguajes que implementan tal tipo de
estructura, y la que se entiende como estmctura de control de repetición básica es la
estructura preevaluada —la cgndición se evalúa antes de ejecutar la acción— que muestra la
ﬁgura de la segunda celda de la siguiente tabla, y qu ya hemos utilizado también en el

l . W
algoritmo RaízCuadrada. “ ‘ u" Mi“
V i



fa

mientras <eondici6n> hace:
<acción>
Ein mientras:

algoritmo Raízcuadrada

mientras abS1X-Z)>:0.00005 hace:
Y*((X/Y) +YJ /2
z « y w y
sin mientras



Repetición de Dijkstra Repcüción preevaluada

Es imponante que la condición de control este’ en coordinación con el cuerpo del
bucle. en el sentido de que las acciones de aquél estén encaminadas a hacer que la condición
deje de cumplirse, de manera que la ejecución de la estructura repetitiva pueda terminar. En
el caso del ejemplo, podemos observar cómo la sucesión de valores de Z es decreciente a
partir de la segunda iteración, mientras que X se mantiene estable, por lo que la diferencia en
valor absoluto X-Z converge a cero, llegando por tanto en algún momento a ser menor que
0.00005, que es el objetivo de precisión marcado por la condición. Si este tipo de

coordinación no se produce correctamente, podría ocurririgue, para determinados casos del

problema, una vez que laeiicucion alg_



ritmo alcance la estructura repetitiva, _no la
abandone nunca, produciéndose lo que se conoce como Álgucle inﬁnitg, que es contrario a la

propia defmición de algoritmo.

repetir
acción
hasta que condición



acción
mientras no condición hacer
acción
Ein mientras



Repetición postevaluada

También es frecuente la aparición de una estructura de control postcvaluada —bucle
en que la condición se evalúa después de ejecutar la acción» que produce la ejecución de la

acción controlada una o más veces, mientras que la estmctura repetitiva básica ejecuta la

IB

acción cero o más veces. Esta estructura es perfectamente implementable con un bucle
preevaluado, repitiendo la acción e invirtiendo la condición.

Otra forma de repetición la proporcionan los but-les controladas por contador, que se
pueden emplear cuando el numero de iteraciones a realizar ya se conoce en el momento de
iniciar cl proceso repetitivo. Si es ese el caso, no hace falta plantearse una condición lógica
que nos diga cuándo se puede tenninar la ejecución del bucle; en su lugar, puede utilizarse
algún mecanismo que simplemente "cuente" las iteraciones realizadas, y detenga el bucle
cuando se ha alcanzado el número deseado. Tomemos como ejemplo el siguiente algoritmo
que sirve para multiplicar dos números naturales mediante sumas sucesivas:
algoritmo Multiplica

variables naturales Multiplicando, Multíplicador,
Producto, Contador

escribir "Multiplicandcïm"
leer Multiplicando
escribir "Multiplicadorz"
leer Multiplicador

Producto F O‘
para Contador desde 1 hasta Multiplicador hace:
Producto * Producto o Multiplicando
Ein para

escribir "el producto es: ", Producto

parar
Ein algoritmo

La forma general de un bucle controlado por contador involucra:

- una variable de tipo ordinal que actúa de contador,

- la especiﬁcación de un valor inicial para empezar el conteo,

- la especiﬁcación del valor ﬁnal que debe alcanzarse antes de terminar, y

- el "paso" o incremento que suﬁirá la variable controladora tras cada ejecución del
bucle.

El paso por defecto es 1, suponiendo que el valor ﬁnal es mayor que el inicial; si es al
contrario, se deberá especiﬁcar un paso negativo (-1). También se pueden especiﬁcar pasos
distintos de l, aunque si un lenguaje sólo permite pasos iguales a la unidad ello no supone
ningún problema, dado que el paso deseado se puede calcular como una función del valor de

la variable contadora.

Í para <contador> desde <valor inicia1> hasta <valor fina1> [paso <paso>]

n hacer
¿ unggn

En ningún caso se debe intentar modiﬁca: explícitamente la variable Contadora en el

cuerpo del bucle, ya que, de poder hacerse, ello podría desbaratar el afecta de conteo, con

resultados posiblemente inesperados.

Z0

m.n.nnnnnmanana;nan¡ganannannmnnnnnnnnnnnnnnniinnnvllﬂﬁﬁ
A .‘ l

Elementos básicos de programación (2).



Ristras de caracteres. y / w u v l



ejemplo, dado el alfabeto {x,y,z), son rístras "x", "xy“, "xxyyz", "zyxx", Una ristrapuede

no contener ningún carácter, dicha ristra se representa por jj" y se llama ristra nula o vacía.

Aquí se usará el símbolo @ para ﬁcï el carácterrespacio, cuando sea signiﬁcativo a
efectos docentes. Ha de notarse que la ristra "@" contiene el carácter espacio y no debe

confundirse con la rislra vacia ("").
A la hora de declarar variables se pueden distinguir tres clases de ristras de caracteres:



(l) de tamaño tﬁgga) de tam limitado (3) de tamaño dinámico. Las variables ristra de
‘a , L Y  ¡1
tamaño ﬁjo se declaran como ristraﬁgﬂqmaño], y el valor que contienen siempre tiene la

longitud deﬁnida, que se completa con espacios, caso de asignarse un valor con menos

caracteres. Las variables rístra de tamaño limitado se declaran como ristraﬂamaña] y su
contenido podrá ser una ristra de cualquier longitud comprendida entre 0 y Tamaño. Las
variables ristra de tamaño dinámico se declaran simplemente como ristrra y pueden albergar

ristras de cualquier longitud.



A los valores de tipo ristra le son É ¿lomasírelacionales basadas en la
ya mencionada sícpencia de confrontación del código, que generalmente se dispone, de tal
forma que, en lo que se reﬁere a los caracteres alfabéticos, semantiene la ordenación
alfabética natural, siempre que sean todos mayúsculas o minúsculas, así las siguientes

comparaciones serían ciertas:

‘WSÏÏDRES,’ < “mA u’ o L z l 3,1, zz’... u  a 4 y
“JOSÉ” < “JOSELEÏ

TEDRO" 2 "ÁÏNToNIoz

‘¿ﬁlntonitf < ‘álitonioí...

Además de estas operaciones, el tipo ristra dispone de otras especíﬁcas que se
enumeran a continuación:
- Cálculo de la longitud. La longitud es una propiedad de las ristras que se deﬁne

como el numero de caracteres que las forman. En nuestro lenguaje algorítmico



" llamamos lon() a la operación que aplicada sobre una ristra produce un valor entero

que representa su longitud, asi: lon(“Canarias”) es 8 y lon(“ULPGC") es 5.



I" Naturalmente, no es demasiado útil emplear la operación lon() sobre valores literales,
sino más bien sobre variables de tipo ristra (esta misma aﬁrmación es aplicable a la
mayoría de las operaciones); así, si A es una variable de tipo ristra, lon(A) será igual a
la longitud de la ristra contenida en A en el momento de aplicar la operación lon(). La

lgngïuggie _l_a r' (nula es 0.



- Concatenación. Es la gig‘); ge_qos sulgristras para fonnar una mayor por simple
 yuxtaposicion. Para expresar algorítmicamente la concatenación empleamos el
/ símbolo +; de este modo la expresión: “Las” + “@Palmas”, producirá la rístra
“Las@Palmas”. La ristra’ nula actúa corno elemento neutro para la operación de

concatenación, es decir, “” + X = X + “" = X, siendo X una ristra cualquiera.
- Eagizzgiojﬁderun} ísuhristra. Consiste en averiguar en qué posición se halla una
\ ¿uyrjstra dentro de* una” ristra dada; por ejemplo, en la ristra

“Las@Palmas@de@Gran@Canaria", encontramos la subristra “Palmas” comenzando



/ " ' ¡’Í k en la posición S. La localización de subristras se implementa como Estas), siendo R
v, 14 la ristra, S la subristra a buscar y pos(R,S) la posición en R del primer carácter de la

7 primera aparicion de izquierda a derecha de la subristra S, si se encuentra, o cero en

caso de que S no sea una subristra de R.

- QQpjaAde una subristra. Se trata de, dﬁqyna ristra, obtener otra tomando un trozo
‘V de ella. Se ha de especiﬁcar la ristra fuente, la posición de comienzo de la subristra a

a1 tomar y el tamaño de la misma. Aplicamos esta operación con el f_v¿1n¿to_sub(R,P,T),
de forma que sub("l.as@Palmas@G.C.”,6,5) produce la ristra “almas“. En el caso de
¿Legercer parámeuo se omita, (¿mi mayor que lon(R) fP + 1, la rí_str_a resultante se
formará tomando los caracteres deílidesde l’ hasta el ﬁnal: sub(“Las@lÏa_lmas”,5,9) =

y’ sub(“Las@Palmas”,5) = “Palmas”. Otras situaciones, como: P s 0, P >‘7lon(R), T s



0,... producen la ristra nula.

22






Entre el tipo carácter y el tipo ristra consjderaremos que existe compatibilidad, lo que
permite, por ejemplo, concatenar un carácter a una ristra o localizar un carácter individual

como subristra dentro de una ristra o asignar un mrácter a una ristra.

ÏÉEEÉEEESY ",0 °"1¡"='°S-

Se deﬁne un tipo ordinal como gLél en que es posible establecer una aplicación
biyectiva entre los valores del tipo y un subconjunto ﬁnito de los números naturales de forma
que se establece el orden entre sus elementos. Lo que signiﬁca esto es que hay un valor que
c4 primero y cada valor del tipo tiene un sucesor, que es único —naturalmente, puesto que
el rango de valores del tipo tiene que ser ﬁnito, existe un valor que es el último y no tiene
sucesor. Si Y es sucesor de X, entonces decimos que X esípredecesor de Y; como el primer
valor no es sucesor de nadie, no tiene predecesor.

De los tipos primitivos, se consideran ordinales los t_ip_os enteros y el tipo carácter; a
veces, también se considera ordinal el tipo lógico, mediante el artiﬁcio de considerar el valor
falsa como primer valor y el verdadera como su sucesor, o viceversa. Los tipos reales no
pueden ser ordinales, ya que entre cada pareja de reales existen inﬁnitos reales, con lo que no
es posible establecer la aplicación con los naturales que pennita encontrar el sucesor de un
real dado.

Aunque todos los tipos ordinales poseen un orden entre sus elementos, no debe
confundirse que un tipo sea ordinal ¡cg que exista un orden entre sus valores: en los reales
son perfectamente aplicables los operadores relacionales —salvo quizás la igualdad, por
razones de representación. Se puede saber cuando un real es menor que otro. lo que no se
sabe es que real sigue a uno dado.

Para los tipos ordinales se deﬁnen operaciones especiﬁcas que dan acceso a la
correspondencia con los naturales, tales como:

Wpﬂipgordinal). Devuelve el primer valor de un tipo ordinal.

, v lÉltimo(Tipo_Ordinal). Devuelve el último valor de un tipo ordinal.
l k, , 0rden(Valor_Ordinal). Devuelve el valor natural correspondiente a un valor ordinal.

«—‘ Valor(Tipo_Ordinal,Valor_Natural). Devuelve el valor que corresponde en un tipo



Su9esor(Valor_0rdina1). Devuelve el valor sucesor de uno dado, excepto para el
ultimo.
PredecesorWalor_Ordinal). Devuelve el valor predecesor de uno dado, excepto para

el primero.

Ínalesﬁdefinrig por el programador.



“¿S d "f!

Uno de los mecanismos más sencillos para pennitir al programador deﬁnir nuevos
tipos a partir de los predeﬁnidos es la posibilidad de deﬁnición de nuevos tipos ordinales. La
deﬁnición de nuevos tipos ordinales puede hacerse por acotación ¡dí un subLngo deglores
de un tipo ordinal ya deﬁnido, o por enumeración exhaustiva y ordenada de todos los valores

del nuevo tipo. En consecuencia, hablaremos de tipos subranga y tipos enumerados.



tipo Byte es entero o. .255 fin tipo /«/ ' ""

tipo Natural es entero O..Ü1timo(entero) fin tipo‘
tipo Positivo es entero lnﬁltimcﬂentero) fin tipo

tipo Negativo es entero Primercuentero) ..-1 Ein tipo w
tipo Días es .5 ¿wm cv -  ‘ N"

lunes, martes, miércoles, jueves, viernes, sábado, domingo
fin tipo

tipo DíasLaborables es Días lunes. .Viernes Ein tipo

A los tipos subrango se les pueden aplicar las operaciones del tipo base de donde se

ha tomado el rango; a losenumeradgs sólo les son aplicables las operaciones generales_de los

tipos ordinales.

Zipos de datos estructurados.’

Una «¿Quail ¿eg qtipoestructurado, es un objeto de datos que está compuesto



de otros objetos de datos, llamados componentes o átomos, que pueden ser a su vez simples o

estructurados.

Como mecanismos básicos para construir estructuras de datos suelen distinguirse; uno
para crear estrucluras homogénea: y otro para crear es/ructuras heterogéneax.

Una estructura homogénea es la que está formada por componentes que son todos
dAel mismo tipo, mientras que una estructura heterogénea está formada por componentes
que pueden ser de tipos diferentes. Las estructuras heterogéneas sirven para IÏEÜSCÏIIKT

entidades complejas ;por ejemplo los datos contenidos en la ﬁcha de un alumno, tales como

24

nombre, dirección, teléfono, fecha de nacimiento,...— mientras que las estructuras
homogéneas sirven más bien para representar colecciones de elementos —por ejemplo la lista
de los alumnos matriculados en una asignatura. El modo de tratar cada tipo de estructura es

muy diferente.

n zw v» « >  “ r, "ﬂ/zmcmﬁ; ¡»y v-,y,¿,1 , , a



a APN/v» ,»_:,;/,,z, v/'Ju,«»v¿ jr: :. 114g ¿ibm-sm

Estructuras heteroééhens.“ ' ﬂmynﬂ ¿f V”?

El mecanismo disponible habitualmente en los lenguajes de programación para formar

estructuras heterogéneas —comúrunente conocidas por la denominación inglesa de_record—

pennite agrupar conjuntos de datosdiversos que ‘se referencian como una entidad única. Por

ejemplo:

i tipo Persona es estructura

campos risera‘ Nombre, PrimefApellido, segundonpenido
campo tiatral9l NIF
Ein tipo w y s , ——





Los c_omponentes de la estructura reciben el nombre de canje los campos pueden



ser de tipos de datos diferentes. Se puedfeﬂacceder a cada campo por separadoto maneja: la

estructura como un todo. Por ejemplo, si declaramos las siguientes variables de tipo Persona:

variables Persona Personal, Personaz

podemos tratarlas como un todo:

Personal F Per50na2

o acceder a un campo individual:

PersonaLNombre "' "Juan"

Para acgder a un campo individual se pone el nombre de la variable seguido de un
punto (.) y el nombre de_l_carnpo. Con los campos se puede realizar cualquier operación
acorde con su tipo; con la Etructura completa sólo se pueden realizar, en principio,
asignaciones y comparaciones de igualdad/desigualdad.

Una e_st_ructura Leterogéneapuede, en general, contener campos de cualquier tipo,

incluso de un tipo estructurado.

25



M’! r’
K
tipo Empleado u astructuru
campo Paqui 51d’ n,
campo Entero Arïuguedad
campo real Salario
un tipo



Naturalmente, esto hay que tenerlo en cu la L la hora d_e>aíceeder ¿ﬁuníeampd

individual usando la notación de punto.

variable Empleado Empleadol

Empleadolidentidadﬂombre » "Juan"
, Á J

Estïcturas homogéneas.

Una estructura homngénea lisina —lo que en inglés se conoce como array- es un

conjunto qjgensiqnado de elementos del mismo tipo. Con dimensionado queremos decir que
los elementos se hallan alineados según una o más dimensiones, donde alineado signiﬁca que
están dispuestos en "hilera", de fonna que uno es el primero y todo elemento que no sea el
primero "sigue" a otro. Esto pennile designar paga elemento individual ¿gún su posición

mediante un conjuntg de indices (uno por cada dimensión).
l M‘ /
m!" lg,» ‘i ‘l

w} Elïlíﬁﬁlllíﬁl «e
. ‘ b ‘¿:1

mmiﬁnmn
[LH [L2 2,31 Bxﬂ y '
EJULZJ l
luwulwzly L








‘ Ilustnción 4 Organización en l y 2 dimensiones

Una estructura homogénea se carzicteriza por:

- su 513353 de dimensiones,
- el número máximo de elementos en cada dimensión,
- el gigoz-pgjinal, como requiere el efgcto d_e qlineación- y rgngp de variación de los

indices en cada dimensión y

- el tipq de los elementos que contiene.

26

De acuerdo con lo anterior consideraremos sjpgácticamentfe válidas las siguientes





deﬁniciones de tipo. 7,”, /   ¡_ ¡ﬂ! ¿[W ¿F 4 ¡ “¡(4 V)
11) cipo Vector es estructura enteroll. .100] Ein tipa “o /// ‘ , l/í‘

(2) tipo Matriz es estructura rea1[1..100,1.‘90] Ein tipo .3 x 7,, ,

(3) tipo VHorasExtra es estructura

real [Pfimero(DíasLaborab1es) . .Ü1timo(DíasLahorab1es) 1
Ein tipo
(4) tipo TFrecLetra es estructura entero['A' . . 'Z'] tin tipo

En (l) se deﬁne una estructura homogénea de elementos enteros dispuestos en una
dimensión e indizados de l a l00. En (2) una estructura de elementos reales, organizados en
dos dimensiones, la primera con índices de 1 a 100, y la segunda de l a 50. Enr3 también se
deﬁne una estructura de componentes reales. pero es monodimensional, y sus índices se
mueven en todo el rango de valores del tipo DiasLaborables —que será ordinal. Por último,
en (4) se deﬁne una estructura de enteros cuyo rango de índices está formado por las letras
mayúsculas de la ‘A’ a la 'Z' tomadas en su orden,

También es frecuente deﬁnir estrgtuiïtonpgéneas especiﬁcando, no el rango de

variación de los índices, sino el número de elementos en cada dimensión:

tipo Vector es estructura enterollDül Ein tipo
tipo Matriz es estructura real[100,50] un tipo

Esto sólo se puede hacer si existe un convenio que deﬁna cual, y de que tipo, es el
glor de comienzo de los rangos. Si acordamos que los rangos por defecto empiezan en l, lo
anterior es equivalente a los casos l y 2 del primer ejemplo.

Tampoco resultan extrañas —aunque quizás poco convenientes a veees— las
declaraciones de variables usando estructuras homogéneas "anónimas“, dfeﬁnidas en la propia
declaración. En el siguiente ejemplo se declaran dos variables enteras (m), y una tercera

(Vea) que es un vector de 10 elementos enteros, con índices de l a 10:

variables enteras i, j, Vec[1..10]

Es importante señalar que las constantes usadas en la deﬁnicion para especiﬁcar el
numergde componentes y rango de indización expresan el número máximo de componentes
que va a tener la estructura’ a efectos de reserva de memoria) Si en el tipo Vector se hace una
reserva de espacio para 100 elementos enteros —es así en ambas modalidades de

declaración—, los algoritmos que utilicen variables de tipo Vector podrán tratar colecciones

27

de hasta l00 elementos, pero no es necesario obligar a que siempre tenga que haber

exactamente l00. Es habitual asociar a cada variable dimensionada una variable ordinal por

cada dimensión que se use para saber hasta qué indice se havllenado la variable en esa

dimensión.
I ,- / y
vazxames Vectorlv“ WWW.‘ ’/"""¿;;r_r,-\
"ww-x natural Nummementos .s—

leer Num-Elementos

Zur/tc; 3/

(NumElementos tendrá que ser menor que 10o)

pax-Ji desde 1 hasta NumElementos hacer

leer kvli]
tin para

(se rellenan los primeros Nummementos de v)

Una altemativa interesante es "encapsular" en una estructura heterogénea el vector

junto con la variable gue indica la porción que se está usando —se ha cambiado el tipo de la

variable Numalementos para ajustarla a lo que es posible segin el rango deﬁnido para el tipo

Vector:

tipa Indicevector es entero 074100 fin tipo

tipo VectorEncapsulado es estructura

campo Vector Datos
campo Indicevector NumElementos
fin tipo

En principio, el tipo de_los componentes de un conjunto dimensionado puede ser

cualquiera ——está limitado en algunos lenguaies—, inclusqotro conjunto gmensionado:

tipo Fila es estructura reallso] Ein tipo
tipo VecVec ee estructura Fí1a[100] fin tipo se



{Mi i/¿"íim r’
fu

El resultado escomo una estructura multidimensional. Aunque la diferencia parezca

una cuestión trivial de sintaxis, sirve para ilustrar como una misma realidad puede admitir

diferentes interpretaciones y tratamientos.

variable Macri z M

para i desde 1 hasta 10o hacer
pura j desde 1 hasta 5o hace:
M[í,j] * Ü
tin para
fin para

variable VecVec M

para i desde 1 hasta 10D hace:
pare j desde 1 hasta 5o hace:
Mii] [j] * 0
Ein para
ﬁn para

Los ejemplos también ilustran cómo las sentencias repetitivas, y en particular la

controlada por contador, están íntimamente ligadas al tratamiento de conjuntos

28

‘¿ﬂ ¡,{( «¡.4 c, g





1: V ¿
"; (mu/a l
l

(Lirnensionados. Es lógico que si se tiene una colección de elementos del mismo tipo la
mayoría de las operaciones a realizar con él consistan en repetir un mismo tratamiento para
cada uno de los elementos de la colección. Dadas las características de la estructura, el acceso
a todos y cada uno de los elementos implica oyjener cada una de las posibles combinaciones
de valores de los índices, esto se consigue anidando un bucle por cada dimensión que haga

ge una variable del tipo ordinal adecuado recorre el rango _de valores del índice de esa

Énensión.

subprogramas;

¡Concepto de subprograma.
Supongamos que queremos hacer un programa para calcular el factorial de un
número. El factorial se puede deﬁnir como:
n! = 1
n! = n'(n-1)'..."1
(producto de todos los naturales de l a n)

sin=0
sin>0

Un algoritmo que implemente esta regla es bastante sencillo, consiste básicamente en

una estructura repetitiva que acumule las sucesivas multíplicaciones.
/ ¡{,1 x ' 1 ¡a \

algoricm factorial
variables naturales n,

guay y, ‘lswk
f,
wz/uz!» A; .

escribir "déme un valor natural: “
leer n

,x¡f,‘_/¡I,4 m:



¿,1 ¿M1 z- \



f 1 —- («wz-wn npzw/fv/w/
para i. donde n hasta éñyaso -1

t e f ú i " “
fin para

hace:
2 v



———/ 1/ 1- qu‘ MJ!"
u!’ (4 ¡r u. n’ .,

escribir "el factorial es: ", f

para:
Ein algoritmo

1;!"

4,;



29 ‘

¿,_.__,.

4'.- 3
1.104: lo

Realmente simple, pero pongámonos en el caso hipotético de que el procesador
disponible no tenga deﬁnido el operador de multiplicación, aunque si el de suma. Tenemos

un algoritmo para multiplicar mediante sumas, podemos adaptarlo para incluirlo en el cálculo

del factorial: , ,4 M W’
I?“

algoritmo factorial 1/ (

vnzinbleunaturales n, f, ,
Multiplicando, Multiplicador, Producto, contador





escribir "déme un valor natural: .,
leer n "



"M. ¡www  w



‘¡hasta 2 paso -1 hace:
Multiplícarído e f r— W" h“
Multiplicador e i n- —

u 4V t.- m/v w:



w v  —.-« .4 w I r.



Producto «(o w í , «rw. « y
para Contador desde 1 hasta Multiplicador hace: ——r
Producto e Producto + Multiplícando

Ein para

E e Producto
Ein para

escribir "el factorial es: ", E

para:
fin algoritmo

Claro que ahora, el algoritmo ya no parece tan sencillo; y la situación podria

empeorar. Imaginemos que lo que queremos es calcular ‘un número comhinatorio:

m m!
n n!(m-n)!

Lo que necesitamos es un mecanismo que permita mantener algoritmos separados
para resolver problemas diferentes, pero que al mismo tiempo posibilite que, si como parte de
la acción de un algoritmo se precisa resolver un problema con entidad propia, aquél pueda
"subeontratarlo" con otro que se dedique exclusivamente a la resolución de dicho problema
proporcionando los resultados para que el primero pueda continuar. Este mecanismo son los
xubpragramas. Un pr_ogi¿a_ma queda organizado como un comunto de subprogramas, uno de
loscuales contiene el algoritmo principal, con la lógica general de resolución del problema,

que controla la ejecución del resto de los subprogramas —se ocupan de la resolución de

partes concretas de aquel.
Un programa se ejecuta a petición de un usuario, el cual debe conocer los datos que el

programa precisa y será quien supervise los resultados. lJn Subprograma se ejecuta a petición

3D

l r
M/"a-z >/>x'



mnnnnn-nnnnnnnnnnnnnnn Ï
nnnnennnnnnnnnnnnnnnll¡QEQEQQRQ!

de otro algoritmo llamador —puede ser directamente un programa u otro subprograma—
que, al igual que el usuario ﬁnal, debe proporcionar al subprograma llamada los datos que
precise y recibir del mismo los resultados que genere; como esta comunicación entre
llamador y llamado no puede establecerse a través de los canales habituales de entrada/salida
—dado que no tienen "existencia ﬁsica" y por tanto no pueden usar un teclado o ver una
pantalla—, se_ establece a través de las llamadas [mas de pqrámerrgg Los parámetros
representan los datos que se intercambian entre el Subprograma llamado y el que lo llama;
pueden ser de _e_m‘_r:q_da, de salida o de entrada/salida, según el sentido en que se realice la
transferencia de información; un subprograma pued_e4tgn_m' además variables locales que
utiliza inítemamente, pero no están implicadas en la comunicación entre un subprograma y su
llamador. Eventualmente, un subkïograrnaïpuede tener acceso ¿{variables globales, deﬁnidas
en alguna zona de acceso común, fuera del Subprograma, pero ello no es muy adecuado,

porque supone una forma de comunicación no explicita, no ya entre un subprograma y su

llamador, sino incluso entre subprogramas aparentemente independientes.

Bgediruientas y funciones.
Se distinguen dos clases de subprogramas: los Eqpedimientos y las funciones. Los
Eyeedimientos‘ responden al concepto de acción algorítmiea como “transformación de
estados”; en este caso, se pasa de un estado representado por el conjunto de valores iniciales
de los parámetros de entrada y entrada/salida a un nuevo estado representado por los nuevos
gres de los parámetrosde entrada/salida y _síal@a_._ Las Eiqgrgí‘ se inspiran en las
homónimas matemáticas, las cuales establecen una relación entre valores de un dominio y
valores de un contradominio o rango, de manera que a gagvalgjel domirtigle corresponde
uno y sólo uno delgsntradomínio; la diferencia entre las ﬁmciones matemáticas y las
informáticas estriba en que las segundas se implementan como una secuencia de sentencias
que pueden hacer más cosas —dibujar algo en pantalla, modiﬁcar variables globales,
almacenar información en un dispositivo,...—, que no forman parte del resultado que
devuelve al ﬁnalizar —una función informática sin esta clase de efecros laterales es

conceptualmente lo mismo que una función matemática.

31



Función Función informática s‘, ¡

 ¡ ‘¿y
matemática equivalente r’ ﬂ (¡M ‘il: ’
ﬁx) :x2 función entera ¿(xr

variable entrada entera x
devolver x*x
fin función

Cuando escribimos un Subprograma gn su cabecpra esgeoíﬁcamos de qué glass de
Subprograma se trata, le damos un nombre y le aﬂuntamg; una lisg ge parámetrug/fofrfagcs
que describe los(datos que el Subprograma intercambia con quien lo llama.)

pzocadimiente Multiplicar(multiplicando,Multiplicadorproducto) ,  _
í variables ‘<" "” ’ ’ ú " ""
entrada naturales Multiplicando, Multíplicador

su} natura1 Producto
Quad atura1 contador
PIOÓHCLO F 0

para contador donde 1 aaata Multiplicador hncer
Producto «v Producto + Multiplicando
ﬂn para

retorna: v-— 1: wav ﬁ n 4 > u_ g,
fin procedimiento



o bien, implementando una función

/-* función natural Multiplicación(Multiplicar-nde,Multiplicadcr)

r
1 variables
2 entrada naturales Multiplicando, multiplicador
locales naturales Producto, Contador
Producto 4- 0
 para contador desde 1 naata Mu1t1p1icador hacer
V Producto e Producto + Multiplicando
(in para

devolver Producto
Ein función

32

u
G
É
ü
E



IPWFE P/IFIIIÜJOMEQP?



HÍPÜÜÍ’





Si comparamos estos dos subprogramas con el algoritmo de multiplicación que

habiamos desarrollado previamente observamos las sigiientes diferencias:

- La utilización dc las palabras procedimiento o función para indicar la clase de
Subprograma.

La aparición de las listas de parámetros formales y la desaparición de las operaciones
de lectura y escritura, ya que la comunicación se realiza con otro algoritmo a través de
las listas de parametros (ello no signiﬁca que en un Subprograma no puedan hacerse

este tipo de operaciones).

- La desaparición de la instmcción parar y su sustitución por otras que dan idea de que

el proceso continúa en otro sitio y no termina con la ﬁnalización del Subprograma.

Si comparjinos entre si ambos subprogramas vemos que:

- La fgición tiene gpdrámetro menos que el procedimiento, ya que al igual que en las
matemáticas, la propia función representa uniyalor (el resultado de su ejecución),

cuyo tipo se declara en la cabecera.

- La sintaxis dela sentencia que termina la ejecución del subprograma es diferente ya

que en la ﬁmcion sedebe indicar el valor resultanteje su aplicación.

Cuando un aigoiitmo necesite hacer uso de un Subprograma disponible, deberá
escribirse una jgtrfncpi n de llamada, en la cual se debe gpgzjﬁgar _el nombre del
ﬁaprggrariia que se requiere, junto con una listadegqrárriegas reales, que son las( variables
o valores del algoritmo llamador que se corresponden en esa llamada con los parámetros
formales especificados en la deﬁnición del Subprograma) La gorgspondencia entre la lista de
pírgirrietrosreales y la lista de parametros formales es, normalmente, posiciona], es decir, el
primer parámetro real sustituye cn la ejecución al primer parámetro formal, el segundo al
segundo y así con todos; ello implica que las listas de parámetros reales y fomiales deben
gcgicidir en el número de parámetros y que los que ocupan iguales posiciones iran de ser
gompatibles. A los ¿gérmenes formales de’ salida o entrada/salida sólo les pueden
corresponder parámetros reales que sean variables, mientras que a los de entrada les puede

corresponder cualquier expresión de un tipo adecuado, dado que desde el punto de vista del
33



subprograma son sólo valores que usa y(no necesita ningún área de memoria para depositar
un resultado como ocurre con los de salida.)

Cuando en la ejecución de un algoritmo se alcanza una instrucción de llamada a un
subprograma, se pasa a ejecutar éste, quedando suspendido el llamador hasta que el
subprograma ﬁnalice, momento en que se continuará con la siguiente instrucción. La
ejecución de una instrucción de llamada a un Subprograma es un proceso complejo ya que
implica guardar el estado actual del llamador, preparar las variables del Subprograma, si no
son estáticas‘ y los mecanismos de acceso a entomos no locales, si los hay, transferir los
parámetros reales a los formales y dar el control al Subprograma, asegurando que al ﬁnalizar
podrá devolverlo al punto adecuado del llamador. De modo similar, cuando un subprograma
ﬁnaliza hay que recuperar el estado del llamador, transferir, dependiendo de los mecanismos
de paso de parámetros, los resultados, dejar libre la memoria utilizada por las variables no
estáticas del subprograma y devolver el control al llamador en el punto adecuado para
continuar su ejecución.

Una diferencia importante entre las llamadas {procedimientos _y las llamadas a
funciones es que las primeras ctn_ns_ti_tuyen una sentencia más de un algoritmo; las lLrnadas a
Ïiones ¿beben formar parte de una expresión, ya que se debe recoger el valor resultante de
la función, que no queda asociado a ningún parámetro real. Vemos a continuación dos
versiones del algoritmo de cálculo del factorial, según la operación de multiplicación se halle

implementado como un procedimiento o como una función:

algoritmo Factorial
vnriahlasnaturalea n, f, i

escribir "déme un valor natural: "

leer n

f := 1

para i desde n naacn 2 paso -1 hacer

Multiplícarifjj) (Llamada a1 procedimiento Multiplicar)

ﬂnipnza

escribir "el factorial es: ", f

para:

sin algoritmo

‘una variable estática es aqueua que se ublCa deforma ﬁja en memoria ames ds wnenzsl ta eteeucsen dei programa y
permanece ahí hasta que la misma ﬁnaliza La mayoria de ¡es lenguajes usan las denominadas “variables de pila‘. que ocupan
¡a memoria cuando el euuprogtama en que esten ueeiarauas se va a ejecutar y la desocupan cuando tenntna su ejecución‘
ello tiene, entre mms, ¡a ventaja de permitir el uso del mismo espacio de memef por diferentes subprogramas. pero pagando
el coste de los mecanismos de ubicación y desubicsción
34

 nn¡amnmnnnnnanmnanannnnnnnnnnn¡manana-anna

algoritmo Factoríal
variableanaturales n, f, i

escribir "déme un Valor natural: "
leer n

f z: l

pan i desde n hasta 2 puc -1 hace:

ïlïultiplicaciórﬂﬁi) (Llamada a la función Multiplicación)

fin para "

escribir "el factorial es: ", Í
parar

fin ¡lgoritmo

Vemos que en ambas versiones los nrïbres de los m gs reales no coinciden con
los de los Eramitïrgnales declarados en las respectivas implementaciones del
Subprograma Multiplica. No obstante, tgmgpco supondría ningún pgslema guggllaimggeg
igual, en cualquier caso representan variables diferentes de subprogramas diferentes, por lo

menos hasta que la llamada las relaciona.

Tópicos avanzados en relación con los subprogramas.

Mecnnfíslï d asordeipnrámetros.



Cuando se llama a un subprograma, debe transferirse información entre los
parámetros reales y los fonnales. En la práctica, existerLdos modos de hacer este tipo de

transferencia: mediante la cogía del valor de u_n parámetros en el otro, o mediante la

transmisión de la referencia (dirección) del parámetro.



La grimeraolgón signiﬁca que el Earámetm formal > ¡son realmente variables
gstirtas. Es un mecanismo corriente en el Basjodeiygrámetros de entrada/comúnmente
llamado paso por valor —en el momento de producirse la llamada, el valor del parámetro real
se copia en el parámetro formal, y se trabaja con éste. Algunos lenguajes implementan
también mediante copia, en este caso llamada paso por resultado, losgámetrgs de salida —
cuando el Subprograma va a retomar se copia el valor del parámetro formal, con quién se ha
estado trabajando, en el parámetro real—, y los gïámetrosnde entrada/salida, lo que
constituye el pgsgpor yglorgresultado.

La segunda opción consiste en dar al subprograma la dirección del parámetro real,
para que lo use directamente en vez del formal. Setrabajaenel espacio de almacenamiento

Llparametro real —el parámetro formal actúa como un simple aIias—, lo que hace este
35

n n n d)

mecanismo poco adecuado para el paso dgparametros de entrada ——a menos que exista algún



mecanismo adicional que impida que se modiﬁque, lo que podríamos llamar paso por
referencia constante. El mecanismo de paso por referencia se usa mucho con los parametros

de salida y entrada/salida. Al no tener que realizarse copias de valores, el paso de parámetros

¡son

por referencia puede resultar más eﬁciente, especialmente cuando se trate de tipos

estructurados de gran tamaño. Sin embargo pueden surgir problemas si un mismo parámetro



real se hace corresponder a dos parámetros formales de salida o entrada/salida diferentes, lo

¿a que puede dar lugar a resultados no controlados (dependientes de la interpretación):

algoritmo Uno procedimiento Dos(X,Y)
variable: salida UnTipo x; y



¿e m, A)

sin algoritmo \ y <- 4
— x e y + x |???

 procedimiento

n n



C
C
G
G
í

Es verdad que también cuando se devuelven parámetros por resultado pueden ocurrir



ambigüedades si un mismo parámetro real se pasa a dos parámetros formales diferentes, pero

no mientras se ejecuta el Subprograma, y en realidad para que el resultado este’ determinado lo



único que hace falta saber es en que orden se realizan las copias de los resultados. Por otra



. parte, habria que plantearse si tiene algún sentido ofrecer un mismo recipiente para obtener

d 1 . . . . .
Pa, dos cosas diferentes, incluso aunque sea sintácticamente legal en un lenguaje concreto.

sobrecarga tlreroperaﬂtres.

í
i
I
d
í
G

En ocasiones es necesariod sarrollar subprogramas que igiplementan. para algún tipo



de datos, generalmente deﬁnido por el usuario, operaciones cuyo signiﬁcado es muyísililar
a_|_d¿algún operador del lenguaje aplicado entre tipos predetinidos; operaciones para las que
incluso puede ser habitual, fuera del mundo de la informática, emplear el mismo simbolo. Por
ejemplo, si A y B son números enteros, es habitual en matemáticas expresar la suma de
ambos como "A + B". Del mismo modo si M y N son matrices de enteros, es habitual en
matemáticas simbolizar la suma de ambas como "M + N". En casi cualquier lenguaje de
programación, la suma de enteros —un tipo primitivo- se realiza con el operador "+"; pero
si el lenguaje no está especíﬁcamente orientado a calculo matricial, no es probable que se

pueda aplicar el operador "+“ para sumar vectores —tipo deﬁnido por el programador. En su
36

lugar el programador podrá desarrollar un procedimiento —que tendría los vectores a sumar
como parámetro de entrada y el resultado como parámetro de salída- o, una ﬁmción en la
que el resultado sería la suma de sus parámetros.

Sin embargo, estaria muy bien que el lenguaje permitiera ampliar el signiﬁcado del
operador "+" para que cuando se encuentra entre vectores realice la suma de vectores, pero
sin que deje de realizar la suma de enteros cuando se encuentra entre enteros. Esto es lo que
se llama sobrecargar el operador. En realidad, casi todos los lenguaje tienen algunos de sus
operadores sobrecargados para varios tipos —"+" sirve para sumar enteros, pero también para
sumar reales, y, en algunos lenguajes, pam la concatenación de ristms, que es una operación
con un claro signiﬁcado aditivo——, de lo que se trata es de que el usuario pudiera añadir sus
propios signiﬁcados —procurando que no diﬁeran en exceso de los signiﬁcados originales
del operador. puesto que ello podría crear confusión.

Ello no tiene que ser muy complicado si pensamos que, operacionalmente, un
operador es básicamente una función con l, 2 o 3 parámetros, aunque se use con una sintaxis
diferente. De esta manera, la sojgrejarga de un operador podria hacerse de un _m_odo parecidog

¿Llaginición de una ﬁmción.



tipo Vector es eetruotun enteroll 11cc] fin tipo —u- 26/»
tipo Indicevector en entero o. .10 fin tipo __ Q _
tipo Vectorliïncapsulado es estructura

campo Vector Datos

campo Indicevector NumElementos
Ein tipa

función Vectorlïncapsulado "w (v1,v2>
variables entrada Vectorlïncapsulado V1, V2
locnlee veccorEncapsuladc sum
IndiceVector í

Sumaﬂumﬂlementos * Vlﬂunﬂlementoa
pan i desde l hasta sumenNumElementos hace):

Sumajatos [i] ‘r VJHDECOSÍÁ] + V2.Datos[i]
¡ln para

devolver Suma
(in función

Debe tenerse en cuenta que, cuando hablamos de sobrecarga de operadores, hablamos
de dar nuevos signiﬁcados a los operadores existentes, pero sinyvariar elznúrnero’ de sus
parámetros, y s_in_"inventar" operadores nuevos —salvo en lenguajes muy especíﬁcos, no se

puede tomar cualquier simbolo y decir que se va a emplear como operador.

37

sobrecarga de nombres de subprogramas.

Los mismos argumentos expuestos parajustificar la sobrecarga de operadores ;usar
el símbolo más adecuado para expresar una operación— pueden aplicarse a la elección de los
nombres de los subprogramas. Si un mismo algoritmo necesita hacer uso de un subprograma
para buscar un elemento en un vector de enteros y para buscar la n-ésíma aparición de una
subristra en una ristra ¿por que’ no pueden llamarse "buscar" ambos subprogramas? Si ese es

el nombre que mejor expresa lo que hacen, bien podría dársele a ambos y di¿





guirlos por el



tipo y n’mero de sus parámetros opor el tipo de su resultado si son funciones. Hacer esto,

que algunos lenguajes admiten incluso antes que la sobrecarga de operadores, es lo que se
conoce como sobrecargar el nombre de un subprograma.

Considéresc a modo de ejemplo estos dos procedimientos, el primero sirve para
ordenar un vector de números reales, mientras que el segundo realiza la ordenación de un

vector de ristras de caracteres.

procedimiento Ordenar (V, n)
Vaziableaentzadalsalida real Vll. ,100]
entrada natural n .__ 41v a > _ , r , , ,., cu, 4. ,, ,.
locales naturales i, j, k y
real e a ma, r 4‘ , u »,.,



para i desde 1 hasta n-l hacer p, «¡Num - ‘y; 4.. , l’, , V,
k ‘ í Ame.  / '

para j desde 1+1 hasta n hacer
u vlj] < vu] entoncas k e j un si
sin para

si k > i entonces

e * Vlí]
Vli] * Vlk]
Vlk] * e
Ein si
fin para
retornar

un procedimiento

38

 9npnppnennonpnmr¡»mwcwmarrones:

procedimiento Ordenar (V, n)
varinbleuentrada/aalida ristra V[1. . 100]
entrada natural n
locales naturales i, j, k
rístra e

para i desde 1 hasta 11-1 hacaz
k «e i

para j desde 1+1 hasta n hace:
si V[j] < Vlí] entonces k k j fin si
fin para

a1 k > i entonces
e * Vli]
Vlii r Vlk]
vlkl F e
Ein si
fin para

ZGCOÉHH!‘
fin procedimiento

Algoritmos genéricos.

Tomando como ejemplo los procedimientos del párrafo anterior, podemos observar
que el primero es un procedimiento para ordenar numérícamente entre sí los n primeros
valores de un vector de reales y el segundo sirve para ordenar alfabéticamente los n primeros
elementos de un vector de ristras. A pesar de que el tipo de los datos sobre el que actúan es
diferente, resulta evidente que ambos procedimientos siguen el mismo algoritmo. Un
algoritmo de ordenación lo único que necesita es que el conjunto a ordenar esté formado por
elementos ordenables, es decir que su tipo pennita determinar si un elemento es menor,
mayor o igual que otro. Podemos encontrar muchos otros casos de algoritmos que podrian
aplicarse en distintas situaciones, sólo con un pequeño retoque en la deﬁnición de los
elementos sobre los que actúan. Por ejemplo, si retomamos la suma de vectores utilizada
previamente para explicar la sobrecarga de operadores, podemos darnos cuenta que el
algoritmo seria el mismo entre elementos de tipo entero, real, complejo o racional; lo único
que hace falta es que el tipo en cuestión tenga deﬁnida la operación de suma. En casos como
éste, seria muy útil poder escribir algoritmos genéricos, en los que se indicara los elementos

gue habria que Líoncretarrpara aplicarlos en distintas situaciones.

39

/



giran-lxs». Mm_gL(X,)/_—T>  Gcüiun‘



ssnn r: » y » W """"*’
\_ r un tipo
“ Menor(T,T) una operación relacional definida sobre T {A ’” ‘¿te /
Rango un subrango ordinal wm n.» w mu:

,.
sumo».



procedimiento Ordenar (6,11).
variablesentradn/sslidu T vlRango]
entrada Rango n

locales Rango 1, j, k

wm h’ T e
l ‘"0 mp7,;
para i desde leie-iotkango) hasta Predecesorkx) hacer
k <e í

para j desde sucesor i) hasta n hacer
si MenofrlvljLvlﬁi) entonces k e j fin si
un para r 5 ¿"17  ' '
si k > í iñtbnhes
e k Vlí]
vii] v Vlk] Í’ A  A,” , ‘¡pg/Wow - .— vww
V[k] v e ‘
Ein si
tin para



0/1



IG COÏDEI
fin procedimiento

En este ejemplo, se usa la eláusula sea antepuesta al’ procedimiento Ordenar para
¡Pdiür l°5 element“ d‘: ‘QÉHWÉÏI ¿‘SQÉÍTEÉSÍEÉÉÜJÏÍÉÏÏÏÉ y que 5° Ïmdría" 935311“? 93-”
distintas apjí_c¿a_ oi —En este caso, el algoritmo de ordenación es el mismo aunque cambie
el tipo de los datos a ordenar (T), la operación con la que se averigua que un valor es menor
que otro (Menor), y el rango de los índices del vector (Rango). Si queremos ordenar un vector
de enteros de rango entero de 0 a 100, un vector de reales de rango carácter de ‘A’ a 'Z‘, o un
vector de ristras de rango natural de l a lO, sólo tendremos que cambiar las apariciones de los
elementos enumerados en la cláusula sea. De hecho, hay lenguajes de programación en los
que dichos cambios pueden hacerse de manera automática o semiautomática; pero aunque no
ﬁiese así, los algoritmos genéricos tienen un papel que jugar en la transmisión de soluciones

con un amplio espectro de aplicación.

40

Esquemas algorítmicos

Problemas de secuencias.

El tipo de problemas más frecuente con el que podemos enﬁentamos implica la



’ manipulación de una secuencia de valores de algún tipo (realizar el desarrollo en serie de una
función, poner las notas a los alumnos de una lista, calcular la raíz cuadrada de un número

.. i real por el método de Newtonjlaphson, facturar a una lista de clientes,...). Esta manipulación



puede requerir la generación de la secuencia o el recorrido de una secuencia almacenada en
t alguna estructura de datos, sin que ello implique ninguna diferencia sustancial en los
f esquemas algorítmicos a aplicar. En vista de ello, parece adecuado estudiar dichos esquemas,
k J ilustrando este estudio con ejemplos de su aplicación a problemas diversos.
A? Podemos entender una secuencia como un conjunto de elementos que se acceden uno
a uno, empezando por un elemento inicial, al cual le sigue otro, y a éste otro, y así

sucesivamente hasta llegar al último —la secuencia debe ser ﬁnita. Un simil muy utilizado




para explicar esta forma de actuar consiste en decir que los elementos se ponen en ﬁla y se

‘ los hace ir pasando por delante de una ventana cuyo tamaño sólo permite ver un elemento



Í cada vez. En un momento dado, hay un subconjunto de elementos que ya han pasado, uno y



’ ‘i sólo uno que es el actual —vísible en este momento— y otro subconjunto que está por venir.



- s,s,...s,,¡ ,s,.,...s,,

Pasado Actual Pendxente

De esta manera el problema de tratar un conjunto de elementos se divide en dos
subproblemas mucho mas sencillos: que’ hacer con el elemento "actual" y (una vez hecho)

cómo "avanzar" en la secuencia para "ver" el siguiente elemento. Las acciones para resolver



¡J i ambos subproblemas se repiten hasta alcanzar el último elemento de la secuencia. ¿Cómo
y / saber que ha pasado el último elemento? Depende de las caracteristicas de la secuencia:

l l‘ , . , . ,
u“ , ¿dpodriamos hablar de secuencias marcadas y de secuencias numeradas. En las segundas, se
r v‘



' x

. - Í . . .
conoce a priori el numero de elementos y para saber que se han tratado todos sólo hace falta
contar; en las primeras, sin embargo, el número de elementos es desconocido a priori y el

ﬁnal se determina por una marca o valor especial que sigue al último elemento o está



asociada a él.

41

Esquemas de generación y recorrido.

, Según lo descrito, el acceso secuencial a un conjunto de elementos conlleva una
inicialización que nos sitúe en el primer elemento, un avance que nos dé acceso al siguiente y
o r c  » L i una evaluación que nos pennita saber cuándo hemos llegado al ﬁnal de la secuencia, ta] como

Se muestra en el siguiente esquema:



iniciar
mientras no ﬁin hace:
avanzar
Ein mientras

i‘ Secuencia aleatoria. o
El esquema de generación secuencial más simple ocurre cuando cada elemento de la

» ' ' ' ‘L secuencia es absolutamente independiente de factores asociados a la secuencia —su valor no



7 .
al, K se ve inﬂuenciado, ni por otros elementos de la secuencia, ni por su posición en la misma. Un

l ik ejemplo podria ser el siguiente trozo de algoritmo que va leyendo una serie de números hasta



‘que el usuario teclea un cero:

leer x W Iniciar E leer x
mientras x # O hace: ‘C Ein E lx = D)
leer x IV Avanzar s leer x

Ein mientras

z
"I" t El principal problema es que si los sucesivos valores son realmente aleatorios, no hay



nada que garantice que va a llegar a cumplirse la condición de ﬁnalización de la secuencia.



n. . r. mu.

j > Secuencia en que cada elemento depende del anterior.

K Cuando la secuencia no es aleatoria, el valor de cada elemento se halla en relación con

l .
i’ ' su posición en la secuencia. De las posibles dependencias, podemos considerar la más simple:




 aquella en la que cada elemento evoluciona a partir del que le precede. Es requisito
K indispensable que exista un valor inicial independiente a partir del que se desarrolla el resto:
S¡::u
Si = F(Sl-|)

42

ïjhonnmmmmnmnnn...nganan--------------------------

El esquema para obtener este efecto implica la inicialízación de la variable que
representa el elemento actual de la secuencia con el valor inicial y un bucle para su
actualización según la función de dependencia, la cual se supone que debe conducir al
cumplimiento de la propiedad de ﬁnalización:

¿"L a
mientras no Fin(x) hace:

x e F‘(x)
Ein mientras

Siguiendo este esquema, el siguiente trozo de algoritmo "desgranzﬂ la secuencia de
los M primeros números naturales:
n e o
mientras n < M hace:

n “ n + 1
fin mientras

El ejemplo se puede generalizar para cualquier secuencia de un tipo ordinal:

n e 0K
mientras n S B hacer

n e Sucesorm)
ﬁin mientras

Secuencias controladas por otras secuencias.

Los esquemas de conteo, como los de los ejemplos anteriores son muy útiles en el
control de la creación y recorrido de secuencias, hasta tal punto, que se incorporan como una

sentencia de control especíﬁca, la repetitiva controlada por contador:

n? a 5;. n desde oz hasta La hace:

mienttn n s B hace: .- -
_ _ _ fin para

n k Sucesorln)
Ein mientrnn

Una forma de ejercer este control puede ser "forzar" la tenninación de una secuencia
tras un número detemtinado de iteraeiones, si no se han alcanzado antes otras condiciones de

ﬁnalización:
43

leer x
n v 1
mientras lx s o) y (n < 10o) hace:
leer x
n «e n + 1
ﬁin mientras

De hecho, pueden llegar a sustituir completamente a otras condiciones de ﬁnalización,
como en los siguientes ejemplos —se convierte en una secuencia numerada en vez de

marcada:

algoritmo Multiplica algoritmo factorial
vnrisblas naturales M1, M2, p, c variables naturales n, r, 1

escribir "Multiplicandoz" escribir "déme un valor natural: "

leer M1 leer n

escribir "Multiplicador=" f z: 1

leer M2 pura i desde n hasta 2 pase -1 hace:
P ‘r O f 4* f * i

para C desde 1 hasta M2 hacer Ein para

P ‘r P + M1 escribir "el factorial es: ", f

fin para para:

escribir "el producto es: ", P fin algoritmo

parar
f in nluoti cmo

También se pueden usar algoritmos de conteo para generar secuencias cuyos
elementos dependen de su posición. El siguiente algoritmo genera y escribe los cuadrados de

los primeros n números naturales:

algoritmo Cuadrados
variables naturales i, n, C
escribir "déme un valor natural: "
leer n
para i desde 1 hasta n hace:

c r í * i

escribir c
fin para
para:
un algoritmo

Generalizando el concepto de posición, podemos hablar de secuencias que se generan

bajo el control de otras, como en el siguiente esquema:

x e a Iniciar controladora
mientras no Fin(x) hace: mientras no Fin hace:

y e G(x) Obtener controlada

x <- mx) Avanzar controladora
un migntrgg fin mientras

44

Aﬂﬁ-IQQQIQQQDQJQQQIQ.-.nan.nnnnqnnnnnonnAgQQQQAQQQQQI

Que se use una sentencia de control "mientras", como en este esquema, o una
sentencia "para“, como en los ejemplos anteriores, depende de si la secuencia de control

responde, o no, a un algoritmo de conteo.

Esquemas de recorrido.

Cuando la ﬁmción generatriz de una secuencia consista en acceder a un componente
de una estructura en la que se hallan almacenados los elementos que la forman —como en el
siguiente trozo de algoritmo, donde la variable x toma sucesivamente los valores guardados
en un vector— parece más propio hablar de algoritmo de recorrido que de algoritmo de
generación, aunque es una distinción puramente nominal:

¿QA i donde 1 hasta n hace:

x * Vli]
Ein para

Esquemas de tratamiento.

Sabemos como generar o recorrer una secuencia de elementos; pero ¿para que’?, lo
normal es que queramos hacer algo con los elementos obtenidos. Probablemente pretendemos
aplicar algún tratamiento a cada uno de los elementos de la secuencia o, al menos, a algunos

de ellos.

Tratamiento de todos los elementos.

Empecemos por el caso más sencillo: aplicar un tratamiento a todos los elementos de

una secuencia. Si suponemos que una secuencia autogenerada responde al esquema general:

iniciar
mientras no fin hlcar
avanzar
Ein mientras

45

resulta obvio que el tratamiento de cada elemento debe realizarse al principio del bucle, justo
antes de avanzar, con lo que obtenemos un primer esquema general de tratamiento:

iniciar
mientras no fin hace!‘
tratar
avanzar
Ein mientras



que es precisamente lo que se hace en los siguientes algoritmos que escriben los n primeros

números positivos:

procedimiento Escribem)

variables entrada natural N
local natural i

para i desde 1 hasta N hace:

procedimiento Escribem)
variables entrada natural N

local natural i
i « 1 (Iniciar)

mientras i s N hacer escribir i
escribir i {Tratar} fin mientras
i e i + 1 (Avanzar) 1930133!

Ein mientras fin procedimiento

ZGÉOIDII
tin procedimiento

Si la secuencia generada o recorrida lo es bajo el control de otra, el tratamiento se
puede hacer, preferentemente, en cuanto se pueda obtener el elemento, si bien podria diferirse

hasta después de avanzar la secuencia de control:

xkor x<-a

mientras no Fin(xl hacer mientras no Fin(x) hace:
y °' Glx) Y “ Glx)
Tratauy) x k Flx)
x ‘ F(x) Tratarw)

fin mientras Ein mientras

Lo vemos en el siguiente ejemplo que escribe los n primeros elementos de un vector:

procedimiento EscribeVÜLN) procedimiento BscribeV(V,N)
variables entrada natural V[50] ,N variables entrada natural V[50] ,N
local naturales x, i local naturales x, i

i e 1 para i desde 1 hasta N hacer
mientras i s N hacer x := Vli]
x .. vri] escribir Vli]
fin mientras

escribir x
i e i + l
Ein mientras
retornar
iin procedimiento (l) (2)

IGCOÍDBX‘
fin procedimiento

46

Pï°°°dimï°nt° Escïïbwivr“) (Las dos primeras versiones
variables entznda natura]. V[S0].N son la misma en Cuanto a

local natural x, i , . . .
esquema, s1 blen, cambia el tipo de

i « 1
sentencia de control utilizada)

mientras i s N hace:
x e V[i]
i « i + 1
escribir x
Ein maneras
retornar
un procedimiento (3)

Este ejemplo tiene la particularidad de que si existiese la garantia de que N es mayor o
igual a uno, se podria pensar en la generación de la secuencia de pares (i,V[i]), en vez de, en
el recorrido de la secuencia de valores de V[i] bajo el control de la secuencia de valores de i,

con lo que la solución podria eneqiarse en el primer esquema de tratamiento:

procedimiento EscribeV(V,N)
variables entrada natural VISO] ,N
local natural X, i

i e 1 ‘¡Iniciar

x * V[i]

mientras i s n hace:
escribir x _ u-Tratar
í e i + 1 "¡Avanzar
x * V[i]

Ein mientras

retornar

E in procedimiento

Es posible encajar cualquier secuencia en este esquema si es legal obtener el primer
elemento sin haber evaluado la condición de ﬁnalización (de ahi la exigencia de que N sea

mayor que cero en el ejemplo):

x k u Dlniciar
y e GKK)

mientras no Fin(xl hace!
Tratarly)

x k F(x) ‘Avanzar
Y * Glx)
Ein mientras

47

Tratamiento de todos los elementos que cumplen una propiedad.
Si lo que queremos es tratar sólo los elementos de la secuencia que cumplan una

detenninada propiedad, basta con encapsular el tratamiento en una estructura altemativa:

iniciar x

mientras no fimx) hacer
s1 P(x) entonces tratara) fin s1
avanzarlx)

Ein mientras

Esto es lo que hace el siguiente algoritmo diseñado para escribir los números primos

comprendidos entre l y N:

procedimiento EscribePrimosﬂi) función lógica Primo(p)
variables entrada natural N variables entrada natural p
local natural i local natural d
i k 1 s1 (p s 2) y (p mod 2 : 0) entonces
mientras i 5 N hacer devolver falso
si Primoti) entonces s1 no
escribir i d v 3
“n B¿ mientras (d < p) y (p mod d r
iki+l omnes: d+d+2
tin "dancing Ein mientras
retoma: si d < p entonces
fin procedimiento “°"°1"“ E31“
s1 no
devolver verdadero
Ein si
Ein si
Ein función

El siguiente algoritmo determina el valor máximo de los elementos de un vector —se
supone que, por lo menos, hay un elemento. En este caso se tratan aquellos elementos que
sean más grandes que el mayor encontrado hasta el momento, y el tratamiento consiste en

guardarlos en una variable que representa el mayor valor encontrado.

función real Máximo(V,N)
variables entrada natura]. N

real V[50]
locales natural i
real Max
Max e V[1]
i 4* 2

mientras i s N hace:
si V[1] > Max entonces
Max k Vli]
fin ¡i
4B

¡ﬂuﬁﬁﬁﬁﬁﬂﬂﬂﬂﬁﬁﬂﬂﬁﬁﬂﬁﬂﬂﬂﬁﬂ
nnnnnnnnnnnnnnnnnanl!¡QQID!
Qﬂll

i «e i o 1
fin mientras
devolver Max
Ein función

Tratamiento del último elemento de una secuencia.

Si la propiedad que hace que un elemento sea tratado es ser el último, el bucle de
recorrido tiene que limitarse a avanzar hasta que se consiga acceder a dicho elemento,
momento en el que se realizaría el tratamiento, ya fuera de la estructura repetitiva: esto es lo

que ocurre, por ejemplo, en el algoritmo que escribe el factorial de un número:

algoritmo factorial
variable: naturales n, f, i
escribir "déme un valor natural: "
leer n
f e’ 1
pan 1 desde n hasta 2 puso »1 hacer
E 4’ f * i
un para
escribir "el factorial es: ", f
pue:
un algoritmo

Tratamiento del primer elemento que cumple una propiedad (esquema de
busqueda).

Supongamos que lo que queremos es tratar el primer elemento dc una secuencia que
cumple una detenninada propiedad, si es que hay alguno. Necesitamos un esquema de
recorrido modiﬁcado con una condición adicional para detenemos si se encuentra el elemento
y, una vez producida la detención, evaluar si ésta se ha debido a que se ha encontrado un
elemento con las caracteristicas buscadas —en cuyo caso hay que tratarlo—- o a que se ha

acabado la secuencia. El resultado es lo que se conoce como esquema de búsqueda:

<Inicialízaciones>
mientras <no se alcance el fin de la secuencia a explorar> y
<no se halla encontrado un elemento que cumpla la propiedad> hacer
<Avanzar, accediendo al siguiente elemento>
Ein mientras
al. <se ha encontrado un elemento que cumpla la propiedatb entonces
¿lociones a tomar cuando se halla el elemento buscado>
si no
<Acciones a tomar cuando no se halla el elemento buscado>
Ein ni

49

La función lógica para determinar si un número es, o no, primo que hemos visto,
responde a un esquema de búsqueda: un número no es primo si es divisible por cualquier otro
mayor que uno —y menor que élA, por tanto, lo que se hace es buscar si es divisible por
algún número de la secuencia comprendida entre 2 y el predecesor del número que se está
evaluando —lo que equivale a que el resto de la división sea cero. Como la mitad de los
números de esa secuencia son pares, se extrae la comprobación de si es divisible por 2, y lo
que queda es una búsqueda en la secuencia de impares resultante. El bucle de búsqueda está
controlado por una doble condición: "no ﬁn" (d < p) y "no encontrado" (p mod d a 0), lo que

obliga a comprobar luego cuál ha sido la condición de salida.

función lógica Primolpl
vaziablesentrada natural p
local natural d
a1 (p » 2) Y (p mod 2 i D) entonces
devolver falso

a1 no
d * 3
miantras (d < p) y (p mod d e mhacer
d * d + 2

Ein mientras
si a < p entonces
devolver falso
si no
devolver verdadero
Ein al
Ein ui
tin función

Combinación de esquemas.

En resumen, si los elementos de un problema se pueden identiﬁcar como una
secuencia —cosa que ocurre con la mayoria de los problemas que pretendamos resolver con
un ordenador de arquitectura "tradicional", dado que esta consiste básicamente en un
procesador secuencial—, se resuelve mediante una de las múltiples variaciones de un
esquema básico de generacion/recenido-tratamiento (lo llamaremos esquema de recorrido). de
entre las que destaca el que hemos denominado esquema de búsqueda, sobre el que, a su vez,
se podrian plantear variaciones. Las diversas variantes tienen que ver, sobre todo, con el tipo
de secuencia —conteada, marcada, con marca despues de o en el último elemento, etc.— que
mejor se pueda identiﬁcar en un problema concreto. Todo esto lo hemos visto para problemas
relativamente simples; pero lo interesante es que cualquier problema, sea cual sea su nivel de

complejidad, puede desglosarse en una composición de problemas más simples, con lo que,

50


Ijnrrttrttrnrmntrrooorrprrmvtvnnovnervl

en última instancia, podria resolverse combinando variantes de los dos esquemas básicos
nominados (recorrido y búsqueda). La composición de dos esquemas sólo puede ser de dos
maneras: secuencial o anidada. En el primer caso, un esquema sigue al otro, en el segundo,
uno está embebido dentro del otro —puede realizar la función de avanzar, tratar, evaluar las
condiciones de ﬁnalización, etc. La composición de múltiples esquemas no es más que la

extensión de lo anterior. Los siguientes ejemplos ilustran algunas posibilidades.

Ejemplo: algoritmo de ordenación por selección.

El metodo de ordenación por selección de una secuencia consiste en recorrerla
parándose en cada posición para elegir el elemento de la secuencia que debe ocupar esa
posición para que resulte ordenada. La búsqueda del elemento candidato debe efectuarse
siempre recorriendo la subsecuencia que empieza a partir de la posición actual, ya que, las
posiciones anteriores ya habrán sido ocupadas por los elementos adecuados cuando se pasó
por ellas. Cuando se encuentra el candidato adecuado, simplemente se intercambia con el

elemento que ocupa la posi ión actual:

3599237154 <> ogsszequ ca 0139287554 d) 012237554 w
0123387561 :> 0123457559 :9 012345199 =:> ouussgs co
01234557Q e) 0123456789

El siguiente algoritmo aplica el método a la ordenación de un vector de números

enteros:

procedimiento ordenselecciónﬂhNEleml

variables
entrada entero NElem {N° de elementos del vector)
entrada/salida entera V[50] {Vector a ordenar}

locales enteras ActuaLAux,Poscandídatcncomodín
{Recorrido del vector} ,
para Actual donde l hasta NEIem __ 1 hace:

(Búsqueda del mínimo a partir de la posición actual)

Poscandidato " Actual

para Aux desde Actual + 1 halta NElem hace:

si V[Aux] < vlPoscandidatol entonces
Poscandídato ‘> Aux
Ein ai
Ein para
{Una vez localizado el elemento que debe ir en 1a posición actual
se intercambia con el que 1a ocupa }

Comodín r vlActuall

Vmctual] h vlPoscandidato]

Vllïoscandidato] t’ Comodín
ﬁn para
retornar
un procedimiento {Ordenselección}

5|

Podemos observar el anidamiento de los dos esquemas de recorrido. El esquema
extemo recorre las distintas posiciones del vector para situar en ella el valor más adecuado;
éste se localiza aplicando el esquema intemn al subvector comprendido entre la posición

actual y el ﬁnal.

Ejemplo: esquema de melcla.

supuestas dos secuencias ordenadas, se pueden juntar en una tercera secuencia
también ordenada. Una forma de hacerlo es recorrer las dos secuencias originales, copiar en
cada iteración el elemento menor —«ie entre los "actuales" de ambas— a la nueva secuencia
y avanzar sólo en la secuencia cuyo elemento se ha copiado. Cuando una de las dos
secuencias se acabe, basta un esquema de recorrido para copiar el resto de la otra.

El siguiente algoritmo aplica el método para mezclar dos vectores de enteros:

procedimiento Mezcla (V1,V2,V3,NurnElem1,NumE1em2)
variables
entrada enteras v1[5o], v2[5o], NumEleml, NumBIemZ
salida entera v3[50]
locales enteras Actua11,Actua12,Actua13
Accuall e 1
Actualz e 1
Actual} e 1
mientras Actuall s NumE1em1 y Actual2 s Nummemz hacer
si v1 [Actuall] < V2[actua12] hacer
v3 [Actual3] e V1 [Actuall]
Actual]. «e Actuall + 1
si no
v3 [Accuala] e V2[ACtual2]
Actual2 v Actualz + 1
Ein si
Actual} e Actual} + 1
ﬁn mientras
s1 Actuall g nuunmem entonces
nientrnn Actuall s NumElernl hace:
V3[Actua13] + v1 [Actuall]
Actuall e Accuall + 1
Actual} e Actua13 + 1
fin mientras
51 no
mientras Actualz s NumEIemZ hacer
v3 [ActuaD] e’ v2 [Accualz]
Actua12 e Actua12 + 1
Actual} <— Actua13 + 1
fin mientras
tin si
IQIDIÏDRZ
un procedimiento

52

ÜVVTTÜIHllllllllnbutubbmtuuH¡HunnunlHTTTI

El primer bucle enmascara un triple recorrido sincronizado. Las condiciones de
contro] se reﬁeren a Vl y V2, pero la última sentencia es claramente un avance en V3; por lo
tanto, estamos ante un esquema de generación de V3 a partir de Vl y V2. La parte de
tratamiento de este esquema conlleva elegir el elemento adecuado y avanzar en Vl o V2,
según de dónde provenga éste. Los dos esquemas de recorrido ﬁnales son excluyentes: sólo
se sale del primer bucle cuando uno de los vectores se acaba y, por tanto, sólo puede haber
uno que tenga elementos pendientes de copiar en el vector de salida. La estructura de

seleccion que los encierra refuerza esta percepción, aunque no es estrictamente necesaria.

Conclusión.

Los dos ejemplos mostrados ilustran las dos fonnas de composición de esquemas
mencionadas previamente —anidada o secuencial. La conclusión del capítulo es que, para
cualquier problema resoluble por un ordenador, existe un algoritmo que no es más que la
composición de un conjunto de esquemas algnritmieos simples. Este algoritmo se puede
encontrar analizando el problema e intentando identiﬁcar los sucesivos esquemas implicados.
en un nivel de complejidad descendente, hasta ser capaz de describir el método de solución

en base a esquemas simples e instrucciones básicas.

53

ü“‘}))ÍÍblIIIIIIDIDDDDDDUDDUDDDIU¡»IIterritorios)»I¡r

Metodologías de diseño de algoritmos

Metodología de diseño descendente.

Estructura delos problemas.

La mayoria de los problemas que resolvemos con un ordenador no tienen una solución
inmediata. Afortunadamente, cuando un problema complejo se examina con detalle suele
mostrarse rápidamente como una combinación de subproblemas más sencillos, aunque no
necesariamente simples. Ello es lo que da validez como metodologia de diseño de algoritmos
a la técnica que se conoce como diseña descendente, y que consiste en dividir un problema
complejo en subproblemas más asequibles, que se resolverán por separado, obteniéndose la
solución del problema global como combinación de las soluciones de sus subproblemas
constituyentes.

En las sucesivas etapas del diseño, cada subproblema es examinado a su vez y
subdividido en subproblemas aún más simples. La subdivisión debe continuar hasta alcanzar
el nivel de problemas “e|ementa|es", entendidos como aquellos que son resolubles
directamente por instrucciones del procesador para el que estamos diseñando el algoritmo;
aunque puede no ser necesario llegar a ese nivel dc simplicidad si previamente nos
encontramos con un subproblema cuya solución ya conocemos; aqui la experiencia del

programador y su capacidad de reconocimiento de patrones frecuentes resulta decisiva.

Desarrollo de un diseño descendente.

Como ejemplo para ilustrar la aplicación de esta metodologia supóngase que se tiene
un vector ordenado de enteros y se desea desarrollar un procedimiento para insertar un valor

de fonna que se mantenga el orden entre los elementos.

Del estudio de lo enunciado puede deducirse un prototipo de interfaz para el

procedimiento:

procadimianto Insertar(V,N,E)
variable entrada/salida entero vt?) /VecCor ordenado de enteros,
natural N [Número de elementos en v.

entrada entero E [Elemento a insertar en v.

55

Se detectan dos aspectos que no están deﬁnidos en el enunciado y que es necesario
aclarar para tener una especiﬁcación correcta del problema que se quiere resolver antes de
seguir adelante —si se parte de una especiﬁcación mal entendida luego se tendrá que
deshacer el trabajo y costará más. cuanto más se haya avanzado-a el primero de estos
aspectos es cuál sera’ el número máximo de elementos del vector —se necesita a la hora de
ÍÏCÜJBÏQÜKÏ’. el segundo es si los elementos del vector son todos distintos o puede haber
repetidos.

La respuesta a la primera pregunta tiene como consecuencia una restricción de las
condiciones en las que funcionara el algoritmo a desarrollar: si, por ejemplo el número
máximo de elementos es 100 y N, la variable que indica el número actual, ya vale l00, no se

puede pretender insertar un nuevo valor.

procedimiento Insertar(\l,N,E)

variable entrada/salida entero V[100] /Vector ordenado de enteros.
natural N ﬂvﬁmero de elementos en V.
entrada entero E [Elemento a insertar en V.

{N debe ser menor que 10o)
{N quedará incrementado en 1,- E quedará incluido en v en la posición
adecuada}

La respuesta a la segunda pregunta también tendrá consecuencias: tanto si es "sí"
(puede haber repetidos) como sí es "no" (son todos distintos) habra’ que tenerlo en cuenta en
el desarrollo posterior; supondremos que la respuesta es "no". Empecemos a plantear este
desarrollo; tenemos que: l) hay que poner un elemento en una posición de un vector y 2)
dicha posición debe conocerse antes de poder poner el elemento en ella; luego lo primero que
debe hacer nuestro procedimiento es: dados el vector y el elemento, encontrar la posición que
debe ocupar el elemento en el vector.

Centrémonos en el problema de localizar la posición de un elemento en un vector;
podemos plantear una función para resolverlo que en principio necesitaria los mismos
parámetros que la inserción:

función natural BuscarPcsicíón (V.N,E)

variable antrndn entero vuoo] [Vector ordenado de enteros.
natural N [Número de elementos en v.
entero E /E1emento cuya posición se busca.

Para desarrollar esta función necesitamos estudiar los posibles casos: el vector puede
estar vacío —N vale cero— o no estarlo. Si está vacio la solución es simple: E deberia ir en la

primera posición.

S6

UEIIIIlllll¡ÏÏH|ll‘l\l\\\|\\Í\ll|lll

función natural BuscarPosicíónﬂhNJs)
variable entrada entero vlloo] {Vector ordenado de enteras.
natural n [Número de elementos en v.
entero E /Elemento cuya posición se busca.
s1 N = o entonces
devolver 1
si no
fin si
fin función {BuscarPosición)

Una solución cuando el vector tiene elementos puede ser ir comparando E con cada
elemento del vector —empezando por el primero— hasta encontrar uno que sea mayor que E
—entendemos que en un vector ordenado un elemento debe ir detras de los que son menores
que él: se puede hacer con un bucle, pero hay que tener en cuenta que E puede ser mayor que
todos los elementos que ya están en V, en cuyo caso se alcanzmla el ﬁnal del vector y habría

que dejar de comparar e indicar que E va en la posición N + 1.

función natural BuscarPosiCiónlVJLE)
vlnzlable entrada entero V[100] [Vector ordenado de enteras,
natural N [Número de elementos en V.
entero E [Elemento cuya posición se busca.
local natural Aux [Variable para recorrer v.

si N = 0 entonces

devolver 1
si. no

Aux ' l

mientras (Aux s N) /\ (V[Aux] < El hace‘:

Aux " Aux + 1

ﬁn mientras

devolver Aux
fin si
un función (BuscarPosición)

Podemos ver que el caso particular de que el vector este’ vacio puede englobarse
fácilmente en el caso general (se inicializa Aux a l, como N vale cero no se entra en el

mientras y se devuelve Aux, que es l); es una fonna de simpliﬁcar el algoritmo.

función natural EuscarPosící6nlV,N,El
variable entrada entero V[100] [Vector ordenado de enteros.
natural N [Número de elementos en V.
entero E [Elemento cuya posición se busca.
local natural Aux [Variable para recorrer V.
Aux ‘r 1
mientras (Aux s N) /\ (V[Aux] < E) hace:
Aux " Aux + 1
fin niantta!
devolver Aux
Ein función (suscarPcsicióx-i}

S7

Resuelto el subproblema dc la búsqueda, de momento tenemos:

procedimiento Insertar(V,N,E)
variable entrada/salida entero VIIÜO] [Vector ordenado de enteros.
natural N [Número de elementos en V.
entrada entero E {Elemento a insertar en V.

(N debe ser menor que 10a}
{N quedará incrementado en 1,- 12 quedará incluido en v en la posición

adecuada)
local natural P [Posición en que se debe insertar E en V.

P - EuscarPosiciónÜlJLE)

En principio hay que insertar E en la posición P, pero debemos recordar que no se
deben insertar elementos repetidos: si V[P] = E no hay que hacer nada puesto que el elemento

ya está en el vector —siempre que P sea menor o igual que N:

procedimiento Insertar (v, N, E)
variable entrada/salida entero vuoo] [vector ordenado de enteros.
natura]. N [Número de elementos en V.
entrada entero E [Elemento a insertar en V.

{N debe ser menor que 10o}
{N quedará incrementado en 1,- E quedará incluido en v en la posición

adecuada}
local natural p [Posición en que se debe insertar a en v.

P ' BuscarPosicíón(V,N,E)
si (t? s N) /\ (V[P] s EH V IP = N+1l ‘entonces
(Hay que insertar, si no, no se hace nada}
fin si
retornar
un procedimiento {Insertar}

Si P es mayor que N o V[P] es distinto de E es necesaria una asignación (V[P] k E),
pero no se puede hacer sin más: si P no es igual a N + l —esto incluye el caso de que V esté
vacio— habrá un elemento en la posición P que no puede perderse: al insertar E en la

posición P el elemento que actualmente la ocupa debe pasar a la P + l, pero entonces el que

ocupa la P + l debe pasar a la P + Z, y así hasta el último. que debe pasa: ala N + l.

5:22 N=s
Pili,” "EME,

' Posición donde debe insertarse E

Para desplazar los elementos desarrollaremos un procedimiento según la siguiente

interfaz:

procedimiento Desp1azar(V,N,P)

variable entrada/salida entero V[100] /VecEor ordenada de enteros.
entrada natural p [Posición a despejar.

natural N [Número de elementos en V.
{N debe ser menor que 100,- 9 debe ser menor o igual que N}

58

El problema se puede resolver mediante un huele que recorra la porción del vector
comprendida entre P y N copiando cada elemento en la posición siguiente; hemos de ﬁjamos
que ese bucle tiene que empezar por el ﬁnal e ir retrocediendo de fonna que lo primero que
se haga sea copiar V[N] en la posición V[N+l], y lo último copiar V[P] en la posición l’ + l;
si el bucle fuese ascendente, sólo se conseguiría copiar V[P] en todas las posiciones hasta el

ﬁnal del vector:
ptocadiniento Desplazarﬂ/JLP)

variable entrada/salida entero vnuu] [Vector ordenado de enteros.
entrada natural p [Posición a despejar.
natural N [Número de elementos en v.
{N debe ser menor que 100;? debe ser menor o igual que n}
local natural Aux [Variable para recorrer V.

para Aux desde N hasta P paso -1 hacer
vlAuxul r vlAux]
fin para
retorna:
fin procedimiento {nesp1azsr}

Nótese que, aunque se especiﬁca que l’ debe ser menor o igual que N —en otro caso
no hay que hacer desplazamíento—, en realidad el algoritmo no falla si no es así —se limita a

no hacer nada. Al incluir el procedimiento Desplazar la inserción quedaría:

procedimiento Insertar(V.N,E)

variable entrada/tanda entero vuoo] (vector ordenado de enteros.
natural N /Número de elementos en v.
entrada entero E {Elemento a insertar en V.

{N debe ser menor que 10o}
(u quedará incrementado en 1,- E quedará incluido en v en la posición

adecuada)
local natural p [Posición en que se debe insertar s en v.

P e BuscarPosicíónWJLE)
si ((13 s N) A (V[P] s 3)) V (P = N41) entonces
{Hay que insertar, si no, no se hace nada}

si P s N entonces [se abre hueco para E.
Desp1azar(V,N,P) '
tin si
V[P] e E [se inserta E en V.
N o N + 1
ﬁin Ii
IBCOÏDI!

fin procedimiento {Insertar}

Lo que obtenemos al aplicar la metodología de diseño descendente es una
descomposición jerárquica de la estructura del problema a resolver en subproblemas más
sencillos en cuya solución nos centramos por separado. En este caso hemos seguido un orden

de resolución "en profundidad" —cada subproblema se resuelve antes de pasar al siguiente»

S9

pero también seria válida una aproximación "a lo ancho" —identiﬁcar todos los

subproblemas de un mismo nivel de complejidad antes de empezar a resolverlos.

Heuristica de anális



Una parte del éxito del diseño descendente depende de la experiencia del
programador, de su capacidad de reconocer patrones frecuentes y de buscar subproblemas de
fonna adecuada. Un método que puede resultar útil es aplicar una heurístiea basada en el
lenguaje natural: sabemos que un verbo representa una acción y que un nombre representa
una entidad (en nuestro caso infonnación) que puede estar cualiﬁcada por adjetivos; asi la
frase: "Insertar un elemento en un vector ordenado" indica una acción ("insertar") que
implica dos entidades ("elemento", que es su objeto y "vector ordenado" que es un
complemento de lugar). Si tratamos de explicar el problema con mayor detalle, podríamos
emplear una frase como: "Buscar la posición adecuada e insertar el elemento en esa
posición"; es una sentencia compuesta en la que podemos identiﬁcar dos acciones: "Buscar" e
"Insenar".

La acción "Buscar" tiene como objeto "la posición adecuada" y como complementos
(implícitos) "del elemento en el vector" podemos desarrollarla como: "Partir de la posición
uno del vector y avanzar a la siguiente mientras queden elementos por examinar y el actual
sea menor que E. Devolver la posición de parada". Encontramos cinco verbos, pero sólo los
tres inﬁnítivos ("partir", "avanzar" y "devolver") denotan acciones primarias; las dos formas
del presente de subjuntivo ("queden" y "sean") establecen condiciones que, al ser evaluadas,
condicionan la acción de "avanzar" (subordinada al "mientras ..."). De las tres acciones
primarias: "Partir ..." se traduce en asignar el valor l a una variable índice, "Avanzar

es devolver el valor de la



consiste en incrementar en l la variable índice y "Devolver
variable índice; todas tienen, por tanto, traducción directa sin necesitar más
descomposiciones. En cuanto a la frase "mientras queden elementos por examinar y el actual
sea menor que E" denota un bucle "mientras" con una condición doble donde: "queden
elementos por examinar" debe entenderse como que "la variable índice sea menor o igual que
el número de elementos en el vector" y: "sea menor que E", tiene un signiﬁcado obvio.

La acción "insertar el elemento en esa posición" depende de si el elemento ya está, o
no. en ella, En la frase "si el elemento no está en la posición determinada" hay que realizar

tres acciones. una de ellas condicional: "s1 la posición está ocupada por otro elemento hay

60

l

que despejar]: y a continuación poner el elemento en su posición e incrementar el contador
de elementos del vector". El elemento "está" en la posición determinada si —siendo P la
posición y E el elemento —, P es menor o igual que el número de elementos y V[P] es ¡gral a
E. La posición "está ocupada" por otro elemento si, siendo falso lo anterior, "la posición es
menor o igual que el número de elementos". Para "despejar" una posición ocupada hay que

"desplazar todos los elementos desde la posición detenninada hasta el ﬁnd una posición a la

derecha" —aunque técnicamente hay que hacerlo "desde el ﬁnal hasta la posición
determinada". Llegados a este punto todas las acciones identiﬁcadas tienen ya traducción

directa en el lenguaje objetivo.

Propiedades del “buen diseño”.

Con la metodologia de diseño descendente cxaminamos un problema
descomponiéndolo en otros más simples atravesando múltiples niveles de abstracción
descendente. Ahora bien, en un nivel de abstracción dado ¿como debemos enfocar la
división? Naturalmente, no hemos de quedamos con lo primero que seamos capaces de
encontrar, sino que hemos de ir buscando que el diseño resultante cumpla la máxima de
“mantener la maxima cohesión y el minimo acoplamiento”. La cohesión y el acoplamiento
son medidas de la bondad del diseño. Si a un nivel detenninado de abstracción la división da
como resultado varios subproblemas de los cuales uno o más podrian dividirse en otros cuyo
nivel de abstracción no fuese signiﬁcativamente menor, entonces la cohesión interna de esos
subproblemas seria baja. Si entre varios subproblemas existe una ﬁierte interrelación, diremos
que el acoplamiento es alto.

Llevado esto al programa resultante, diremos que la cohesión es máxima si cada
módulo que lo constituye —procedimiento, ﬁmción, algoritmo,  resuelve una única tarea,
y que el acoplamiento es minimo si las dependencias mutuas entre módulos es la menor
posible (esto se traduce, por ejemplo, en que en las listas de parámetros no haya información
redundante, o en no usar variables globales).

Si una descomposición está bien hecha es posible cambiar la implementación de un
módulo mientras se mantenga intacta su interfaz. Así, por ejemplo, se podria utilizar el
método de la "búsqueda dicotómim" para realizar lo localización de la posición donde debe

insertarse el elemento, en el proceso de inserción ordenada.

6|

Cuando se hace una búsqueda secuencial en un conjunto de N elementos se empieza
comparando el valor a buscar con el primero del vector, si éste es menor que el que
buscamos. quedan N » l posibles candidams. Si la búsqueda es dicotómica, se empieza
comparando con el elemento que ocupa la posic n central del vector; si no coincide. los
posibles candidatos son N/2 —la mitad superior del vector si el valor es mayor que el central
o la inferior si es menor. La búsqueda continúa comparando con el elemento medio del
subvector correspondiente —cada comparación elimina la mitad de los candidatos
disponibles, mientras que en la búsqueda secuencial cada comparación sólo elimina un

candidato. Al ser las comparaciones mucho más efectivas el método es mucho más rápido.

función natural BuscarPosíción(V,N, E)

variables

entrada entero vuoo] [Vector ordenado de enteros.
natural N [Número de elementos en v.
entero E] /E1emento cuya posición se busca.

locales enteras LInf,LSup [Delimitan el subvector que se está tratando.
entera Medio [Elemento central del subvector considerado.

lógica Encontrado ¡cuando es Verdadera finaliza la búsqueda.

(Inicíalízaciones)

LInf «e 1

LSup -— N

Encontrado <- falso

mientras (Llnf s Lsup) /\ nouancontrado) hacer
{Cuando los límites se cruzan, se acaban los subvectores)
{El tratamiento consiste en examinar el elemento central}
Medio e ParteEnteraHLInf + Lsup) / 2)

si V[Medio] : E entonces
Encontrado ‘r verdadero
fin si

{Se avanza moviendo los límites, para considerar un subveccar más
pequeño}
si V[MediO] < E entonces
LInf k Medio + l
si no
LSup " Medio - 1
fin Si
fin mientras
Si. Encontrado entonces
devolver Medio
si no
devolver LInf
fin si
un función {EuscarPosición}

i I-Iﬁ É _
, 3.45 . :t3<_> _
tam. T oír. Si: z una... x...< al...

28.8 su Suns ,
5 w355»... B.
man img: ü 5mm;
. l: .035. m. n38





n 5 Dcscomposición desccndenw del problema "insertar un elemento cn un vector nrdenadn

2.38 s .125”...
. s z Á z
_ T151 noïas-zé...
_ a
> é «¿.55? ‘
_ s. 55...... ésa... .2 ¿c535 «E. _
E 355mb; gcu 22cm ﬂ 599cc: E ñ \ \ ‘ ‘ESE. E.
_ _ “l N‘ Ï5< .u..< .
‘ Ï‘ 13a.. _WV 7=<_>..>_zwÉ<. 2.3:: . ‘ 1x ‘
52225.72 u n. 3...4 .333: ‘ , W _ A 5.4
.:G.E.>::z....:. \ .
W ‘ , mas Éïiuïmaua :1. l
l N ¿caia s. _ .«.__ES..:.L 5.255s zonas... . 5.833. S!
.95 .88 oc u a coimas! 329.5 «EEB... 9.5:; n. m .352; . .. ES m. E. .._:.E .
l r \ l!‘ l.
55o“. MMO 5 , «musik ‘
35.5o.» 5.:... .323 m. ¡anna
‘ Í ‘ _
89.09.0252, :3 _

.5 3.521» .. n ¡tons “m

1\\ m

s

h

 ÉaaÉ»————————Pa‘

Desarrollo de soluciones recursivas.

Planteamiento.

No es raro encontrar funciones matemáticas cuya deﬁnición se construye empleando

la propia función que se está deﬁniendo:

Factorial
a ) l si n = 0
n :
n’f(n-l) sin 9€ 0
Fibonacci
l si n = 0
f(n) = lsin = l

mu) + f(n»2)\1n >1

Las funciones de este tipo decimos que tienen una deﬁnición recursiva, que expresa
mediante una fórmula de recurrencia una relación entre distintos términos de la funcion.
relación que pennite calcular unos términos a partir de otros. Se trata de una deﬁnición
operacional; si, por ejemplo, queremos calcular el factorial de 4, sabemos que tenemos que
calcular primero el de 3 y luego multiplicar por 4, pero para calcular el de 3 debemos calcular
primero el de 2 y multiplicar por tres, y para el de 2 calcularemos el de l y multiplicaremos
por 2‘ y el de l será el de 0 multiplicado por l. El de cero no depende de otros, y su valor es
l. que multiplicado por l da l, que multiplicado por 2 da 2. que multiplicado por 3 da 6. que
multiplicado por 4 da 24, que es el factorial de 4.

Si analizamos estas funciones desde la perspectiva (del diseño descendente) de
división de un problema en subproblemas más simples Ilegaríamos a la curiosa conclusión de
que se trata de un problema que se subdivide en problemas que son iguales que él, pero

aplicados a una entrada más pequeña.

64

mllllllllIllllntttbtwbbttwwuilninintnn)lsTrrm

l amar.)

l ,_l_
l rimnacata) I rvbonacaa) I

_,l ,> ,, I,
;



Ilnslracíón 6 Ejecución de Fibonacciﬂ)

También observamos que el dominio de estas funciones queda divido en dos
subconjuntos:
- casos que no dependen de otros para su cálculo, que denominaremos conjunto de
casos base (Vease cn la descomposición de la ﬁmción de Fibonacci cómo esos casos

quedan en la "base"; y
- casos que dependen de otros según lo establecido por la expresión de la recurrencia.

Toda deﬁnición recursiva bien formulada debe tener al menos un caso base, y la
recurrencia debe ser de tal naturaleza que su descomposición acabe conduciendo
necesariamente a alguno(s) de los casos base.

Los problemas con estas características no son exclusivos del campo de las funciones
matemáticas; por el contrario los podemos encontrar en muchas otras situaciones. Tomemos
como ejemplo el famoso enigma de las "Torres de Hanoi". Sin entrar en la leyenda, se trata
de resolver un problema en el que tenemos tres varillas en una de las cuales hay inicialmente
varios discos de distinto tamaño ordenados de mayor a menor. El juego consiste en trasladar
todos los discos a otra de las varillas, con la única restricción de que nunca se puede poner un

disco mayor sobre uno menor. Para conseguirlo hemos de ayudamos con la tercera varilla.

Í ' ' Il

srruAcIbN INICIAL SITUACION FINAL

Ilustración 7 Tona de Hanoi

65

Yendo, como siempre, por partes, podemos damos cuenta de que lo primero que
tenemos que consegrir es pasar el disco mayor desde el fondo de la varilla origen al fondo de
la varilla destino. lo cua] sería una cuestión trivial si ese ﬁrese el tínico disco que hay: como
normalmente no es así, hemos de resolver antes el problema de “quitar de en medio“ los
discos superiores, cosa que sólo podemos hacer llevándolos a la varilla intermedia.

La diﬁcultad estriba en que para apartar los discos superiores a la varilla auxiliar han de
respetarse las normas del juego, con lo que nos encontramos con el mismo problema que al
principio, sólo que con un disco menos y con las varillas auxiliar y destino intercambiadas. El
mismo problema que habrá que resolver una vez que el disco mayor haya ocupado su lugar
para pasar los restantes discos a la varilla destino. convirtiéndose ahora la inicial en intermedia.

En resumen, el problema se resuelve:

Si hay un sólo disco, pasándolo directamente a la varilla ﬁna].

Si hay N discos (N > l):
pasando N — l discos de la varilla inicial a la auxiliar, respetando las reglas del
juego
pasando un disco de la varilla inicial a la ﬁnal

pasando N — l discos de la varilla auxiliar a la ﬁnal, respetando las reglas del

juego

Podemos ver que este algoritmo sigue exactamente las mismas pautas que las
deﬁniciones de funciones matemáticas recursivas: existe un caso base y una recurrencia para el

resto de los casos planteada de forma que conduce al caso base preestablecido.



Cómo formular un algoritmo para un problema recursí

Una vez que el análisis nos ha conducido a una deﬁnicion recursiva de un problema, la
mejor táctica es la simplicidad: trasladar la deﬁnición del problema al algoritmo manteniéndola
en toda la medida que pennita la sintaxis del lenguaje utilizado. En nuestro caso eso signiﬁca
que tendremos un procedimiento o una función, cuya estructura general típica vendrá dada por
una estructura altemativa que separará los casos base de los casos generales recursivos. La
resolución de los casos recursivos implicará la aparición de llamadas al mismo Subprograma.

con nuevos parámetros.

66

función natural Factoríalm)
variable entrada natural N
local natural Resultado

a1 N < 2 entonces

Resultado <- l
si no

Resultado <- (N ‘r Factoría]. (N—1))
fin si
devolver Resultado
fin función {Factorial}

función natural FíbonaCci(N)
‘inﬂable entrada natural N
local natural Resultado
si N < 2 entonces
Resultado k l
a1 no
Resultado °
{in si
devolver Resultado
ﬁn función [Fibonacci]

(Fibonacci(N-1l"FibonaCCi(N»2)l

tipo Varillas es entero 1. .3 Ein tipo

procedimiento Hanoi (NumDis , VI , VF, VAux)
Variables antradn Positivo NumDis
Varillas vI, VF, VAux
si NumDis : 1 entonces
PasarUnDiscoWLVF)
ni no
Hanoi (NumDis—1,VI,VAux,VF)
Hanoi(1,VI,VF)
Hanoi (NuInDis-1,VAux,VF,VIl
fin si
retornar
nn procedimiento {Hanoi}

En estos tres algoritmos, que resuelven los problemas planteados previamente podemos

observar:

l. Que los tres tienen, como se había indicado, la misma estructura, basada en una
sentencia altemativa que diferencia el caso o casos base del problema, del caso general.

2. Que los tres empiezan resolviendo lo más fácil, los casas que corresponden a las

condiciones de base.

3. Que el caso general se descompone en varios casos más sencillos del mismo problema
y de una parte ——normalment.e-— no recuxsiva, que se componen entre sl para dar la
solución. Tanto la solución del caso base, como las panes no recursivas del caso general

pueden incluir las estructuras no recursivas que sean oportunas, dc acuerdo a su

{Llamada recursiva

(Llamada recursiva

¡Llamadas recursivas

complejidad, aunque esto no se vc en los ejemplos, dada su sencillez.

67

4. Que, en última instancia, la correcta solución del caso general depende de la correcta
solución del caso base, así como de la correcta formulación de la relación —
recurrencia— entre sucesivas instancias del problema Igual que en la inducción
matemática, podemos aﬁrmar que. si el problema está bien resuelto para el caso base y,
en el supuesto de estar bien resuelto para un problema de tamaño N, lo estará para un

problema de tamaño N+1, entonces está bien resuelto para todos los casos.

Cómo funciona la recursividad.

La forma más fácil de describir una llamada recursiva es decir que se trata de una
llamada "al mismo Subprograma", pero, ¿qué signiﬁca esto? No debemos olvidar que un
subpmgrama es un algoritmo y que la ejecución de un algoritmo da lugar a un proceso que se
desarrolla gobemado por ese algoritmo, en el sentido de que el procesador va siguiendo las
instrucciones escritas en el algoritmo para realizar las acciones del proceso. Cuando se produce
una llamada a un subprograma el proceso en curso queda momentáneamente suspendido, a la
espera de los resultados de un nuevo proceso independiente que es desencadenado por la
llamada. y controlado por el algoritmo del Subprograma. Esto sigue siendo cierto cuando se
trata de una llamada recursiva. Si se está ejecutando el algoritmo de cálculo de la función de
Fibonacci para el valor 4, cuando se encuentre la llamada a Fibonacci(3) se detendrá el proceso
en curso, se iniciará un proceso aparte que seguirá iguales reglas, y cuando éste tennine se
reanudará el proceso inicial en el punto donde se había parado. Si se encadenan varias llamadas
rccursivas —Fibonacci(3) llama a su vez a Fibonaccí(2), y esta a Fibonacci(l)— coexistiran
varios procesos, que responderán a idéntico algoritmo, pero que se encontrarán en diferentes
grados de ejecución. Se trata del "mismo Subprograma“ en la misma medida en que se puede
decir que dos cocineros cocinan la misma receta, estando uno en Bilbao y otro en Barcelona. y
cada uno con una copia de aquélla. De igual fonna, cada proceso está siguiendo en realidad su
propia copia del Subprograma.

En terminos técnicos, a cada proceso en ejecución le corresponde un registro de
acüvac/ón. que guarda información acerca de su estado —variables locales, dirección de retomo
cuando termine, parámetros, etc. En la mayoría de los lenguajes de programación, la ejecución
de un programa comienza cargando en memoria el registro de activación correspondiente a su
algoritmo principal. Si se produce una llamada a un subprograma, se traduce en la carga de un

registro de activación para cl proceso representado por ese Subprograma, en una dirección

68

UbillllllblllDDlI!lIDDDDlDDDDD¡lIlIDIIIIDIlliilllllllll‘!

inmediammente superior a las ocupadas por el registro del proceso principal. Si un
subpmgrama llama a otro (o a si mismo), se pone un nuevo registro de activación por encima
del suyo. De esta manera es como si los registros de activación se fuesen "apilando" en
memoria, de forma que el proceso activo es siempre aquél cuyo registro de activación se halla
en la "cima" de la "pila“, estando los demás activos. pero suspendidos. Cuando un proceso
acaba; se elimina su registro de activación, reanudándose la ejecución del que se encuentra
debajo de él, que ﬁJe quien lo llamó. La siguiente tabla muestra la evolución de procesos
dcscncadenados cuando un algoritmo principal se carga e invoca a] subprogmma que evalúa la
función de Fibonacci para el valor 3. El proceso activo en cada instante (Ti) es el que aparece

sombreado.

Flhoﬂ) Fih0(0)

Fiho(2) amm nus-xa) F|bo(2 ¡‘mom Fiba(|)

Flbo(3) ﬁboííi) FIbo(3) Fibo(3) F006) Filxxï!) HMC!) Fibc(3) Fibo(3)

Princ. Pnnc Princ Princ. Princ. Princ. Pnnc. Pnnc. PTÍHC. Princ. Princ.

T0 Tl T2 T3 T4 T5 T6 T7 T8 T9 T10 Tll Tl2

69

üvsTlTrTïñr InnnuruiuuttiunrrunnuunTrTrn-a

Ficheros

Concepto de ﬁchero.

Los algoritmos informáticos manipulan infonnación que es representada mediante
variables y constantes; hasta ahora no nos hemos ocupado de dos aspectos de la información
que, sin embargo, pueden ser muy relevantes: la caducidad y el volumen. Las variables tienen
una duración —conocida como "tiempo de vida”— limitada al período de ejecución del
bloque en que estan declaradas, pero determinadas informaciones pueden tener vigencia
mucho después de que acabe la ejecución del programa que las elabora por primera vez; por
ejemplo: si una gran empresa tiene que introducir las listas de empleados, clientes,
proveedores. articulos, etc., cada vez que arranca su programa dc gestión, no le quedará
tiempo para los negocios —y no se soluciona arrancando el programa de gestión sólo una vez
y dejándolo luego en ejecución pennanente con los ordenadores siempre encendidos: siempre
puede haber un corte de luz. Además, la cantidad de información que se puede almacenar en
variables en memoria RAM es muy limitado frente a las necesidades de algunas aplicaciones
—pensemos en el volumen de la información tributaria almacenada por el ministerio de
hacienda- debido a que la relación coste/almacenamiento de este tipo de dispositivos es
relativamente alta. Son necesarios dispositivos que pennitan {almacenar con un coste
razonable grandes volúmenes de información de forma pennanente y de tal manera que
pueda ser utilizada por diferentes programas o por un mismo programa en diferentes
ejecuciones; dispositivos de este tipo son los discos magnéticos, cintas, discos ópticos, etc..
—en todos estos dispositivos la información se organiza fumando unidades con nombre
propio llamadas ﬁcheros. La información en los ficheros se estructura en componentes o
registras que pueden ser accedidos individualmente —por "accedidos" entendemos que la
información de un componente de un ﬁchero puede copiarse a una variable (operación de
entrada) en memoria principal donde pueda ser manipulada o que el valor de una variable
pueda copiarse en una componente de un ﬁchero (operación de salida) para su
almacenamiento permanente. La información de un ﬁchero debe poder descomponerse en
unidades más pequeñas puesto que por vocación un ﬁchero tiende a representar volúmenes de

infonnación demasiado grandes como para poder cargarse completos en memoria principal.

7|

Clases de ﬁcheros.

Los ﬁcheros se pueden diferenciar según: (l) la forma en que se estructura la
infonnacion que almacenan, (2) el modo en que se puede acceder a esa información y (3) su
periodo de existencia.

Cuando hablamos de la estructura de un ﬁchero hemos de distinguir entre la estructura
lógica, que se reﬁere a como el programa “ve" el ﬁchero como un conjunto de componentes,
y la estructura ﬁsica, que alude a cómo la información se organiza en el dispositivo de
almacenamiento. Desde este punto de vista. un ﬁchero es una secuencia de bytes
posiblemente organizada en unidades superiores en función del tipo de dispositivo en que se
almacene. Desde el punto de vista lógico se distinguen poríuíestructura tres clases de
ﬁcheros: (l) ﬁcheros de componentes uniformes. (2) ﬁcheros de componentes m: uniformes y
(3) ﬁcheros de terra: En cualquier caso, puede entenderse como una secuencia marcada de

‘ datoskdue en última instancia se reduce a una secuencia marcada de bytes. La marca de ﬁn de
ﬁchero la abreviamos aquí con su acrónimo en ingles <EOF> —End Of File.

El programa interpreta la secuencia de bytes subyacente para acomodarla a los
distintos tipos de datos que para él conforman la estructura del ﬁchero.

Unfïitírggnifzïrne es una secuencia marcada de elementos que son todos del mismo

tipo, y, por tanto, ocupan el mismo número de bytes en el dispositivo de almacenamiento.

l,,,i {Mi i i V’ EOF

Ilustración 8 Estructura de un ﬁchero uniforme

Un ﬁchero nu uniforme se interpreta como una secuencia marcada de elementos que

pueden ser de distintos tipos, ocupando por tanto, cantidades distintas de espacio ﬁsico.

Ilustración 9 Estructura de un ﬁchero no uniforme

Los fïgﬁergzg de texto son una secuencia estructurada de caracteres; la estructuración
se consigue mediante marcas que son combinaciones especiﬁcas de caracteres que se
interpretan como: ﬁn de línea <EOL>, ﬁn de página <EOF> yﬁn de ﬁchero <EOF>. La

interpretacion del contenido de un ﬁchero de texto, resulta más complicada que en los otros:

72

MXÏÏIIIIJLJIII'll|Illlul-lobltlelctlallolillllIIIIIItII|J|IIFTUFÉ

aunque se encuentre organizado en lineas, éstas no son necesariamente el componente básico
de acceso. y aunque las lineas sean secuencias de caracteres, el tipo de datos al que se va a
acceder no tiene que ser interpretado obligatoriamente como ristra de caracteres:
Supongamos que en una linea de un ﬁchero aparece la secuencia "3524283 3.14". Podría
leerse en una variable de tipo ristra que respetase dicha secuencia, o en dos variables de tipo
real, interpretando la secuencia de caracteres como los números reales que representan —en
este caso, el espacio se interpretaría como delimitador de los números—, incluso podría
interpretarse como cuatro valores enteros.

7 " — WT

EOL i’ EOLE



Illlstrución ID Estructura dc un ﬁchero de texto

Los modos de acceso se diferencian por lo que se hace y por cómo se hace. I_.o único
que se puede hacer con la información almacenada en un ﬁchero son operaciones de entrada
—lecturas— para copiar componentes del ﬁchero a variables del programa y operaciones de
salida —escrituras— para copiar variables del programa en componentes del ﬁchero. En
unos casos se puede acceder ajualqíuierAcomponente en cualquier momento —acceso
d¡recIo—— y en otros para acceder a una componente se debe haber íí-Lïeﬁldﬂ antes a las que
ocupan posiciones previas en el ﬁchero wccesa secuencia]. Cuando un ﬁchero se trata en
modo secuencial es normal que sólo se hagan operaciones’ de entrada u operaciones de salida,
pero no ambas, mientras que cuando se trata en modo directo es habitual que se puedan
mezclar ambas operaciones. También es normal que los ﬁcheros de componentes unifonnes
puedan tratarse en modo directo 4a] ser todos los componentes del mismo tamaño es fácil
calcular la posición ﬁsica de uno determinado— mientras que los ﬁcheros de texto siempre
tienen que tratarse en modo secuencial —los componentes son lineas de tamaño variable
determinado por las marcas de ﬁn de linea, con lo que resulta muy diﬁcil conocer de manera
eﬁciente donde empieza cada unai; por razones similares los ﬁcheros de componentes no
homogéneas son más adecuados para un tratamiento secuencial, a menos que tengan una
estructura conocida con exactitud por algún medio.

La cuestión de la persistencia —período de existencia— de los ﬁcheros parece
contradictoria con la justiﬁcacion expuesta anterionnente —los ﬁcheros sirven para guardar
infonnación de foma pennanente—; sin embargo, existen aplicaciones en que una

infonnación que solo se requiere durante la ejecución del programa se guarda en un ﬁchero
73

temporal —por su volumen o por otras razones- que el propio programa destruye cuando

deja de necesitarlos.

Protocolo de transferencia de información programa/ﬁchero.

Para un programa, una variable es una entidad de su propiedad, que crea, destruye y
manipula a su antojo; sin embargo, un ﬁchero es una entidad ajena, con existencia propia y
situada en "el exterior" —los discos y demás dispositivos mencionados son unidades de
almacenamiento extemo—, que contiene una infonnacíón que el programa no puede
manipular directamente —tiene que hacerlo a través de transacciones con sus variables. Un
programa que pretenda almacenar o manipular información en un ﬁchero debe seguir un
estricto protocolo de comunicación con el Sistema de Gestión de Ficheros —la parte del
sistema operativo de un ordenador encargada de controlar todo lo relativo al almacenamiento

de información en dispositivos extemos.



Programa Sistema dc ﬁcheros
Ïl ’}” " . ﬁdtrolli h ‘n
V‘
ww n-Ïs; r. mu.)

Pmgmm Sistemade ﬁc ¡bs
rn " r ‘ 316m —



  Ni‘ Abrir

‘t
(‘un -v« ll.rlr‘x¡





Programa
vi c ' "c '
v2

Vln-¡Sﬂsnoi-Je; ﬁ. al CGÏÏÏZ

Ilustración Il Protocolo de transferencia dc información entre un programa y un ﬁchero

Para poder iniciar la transferencia de infonnación se necesita en primer lugar declarar
una variable que, para el programa, representará al ﬁchero; cuando se necesite una operación
que haga referencia a un ﬁchero disponible en algún dispositivo extemo —ﬁchero ﬂsico- se

empleará la variable que lo representa ——conocida como ﬁchero lógico.

74

En la declaración el programa especíﬁca como va a interpretar la información

contenida en el ﬁchero que se asocia con la variable; se contemplan tres posibilidades:

variable Fichero Nombrevariable [componentes no uniformes
variable Fichero<TipoCamponente> Nombrevariable [componentes uniformes
variable FicheroTexto Nombrevariable Michero de texto

Una vez se ha declarado una variable ﬁchero el primer paso es la apertura, que
comprende dos aspectos: l) establecer la relación entre la variable ﬁchero y el ﬁchero ﬁsico
que se pretende manipular por su intermediación —igual que una variable entera puede
representar diferentes valores enteros en momentos diferentes, una variable ﬁchero puede
representar diferentes ﬁcheros ﬁsicos— y 2) poner en marcha los rrïismos necesarios
para la transferencia efectiva de la infonnación para lo cual el programa deberá e_s_¿eeiﬁca.r el
sentido aplicado al ﬂujo de la infomtación —desde el ﬁchero haciavel programa. desde el

programa hacia el ﬁchero o en ambos sentidos. Este proceso lo lleva a cabo la operación

lógica Abrir que puede tomas las siguientes conﬁguraciones:

1.- AbtirlF, NombreF, Lectura)
2.- AbrirÍF, NombreF, Escritura)
3m Abrírﬁ‘, Nombrel’, Lectura/Escritura)

F es la variable controladora —tambie’n llamada “ﬁchero lógico”—, NombreF es una ristra
conteniendo el nombre de] ﬁchero ﬁsico que se pretende abrir —debe existir—, Lectura,
Escritura y Lectura/Escritura son palabras reservadas que actúan como indicadores del
sentido de transferencia de la información.

Para los ficheros de texto y los de componentes no uniformes el modo de apertura
sólo puede ser Eectiira o lïseritura, y se aiﬂgïﬂ los componentes de forma sejuﬁencialibos
ﬁcheros de componentes uniformes admiten, además, el modo Lectura/Escritura y el acceso
directo a sus componentes.

En nuestro pseudolenguaje, la operación Abrir es una función lógica que, además de
asociar la variable F con el ﬁchero cuyo nombre indica NombreF y dejarlo listo para ser
utilizado, devuelve un valor verdadero si la apertura tiene éxito y falso en caso contrario —
por ejemplo si el ﬁchero ﬁsico no existe. Un ffhero ﬁsico se puede crear con la (¿Eración
lógica CrearFicheroQVombref) que devuelve verdadero si lo crea y falso si no puede crearlo
:3; ejemplo si ya existe un ﬁchero con ese nombre. En muchos lenguajes, las operaciones
de apertura y creación son procedimientos, y señalan el fracaso mediante una excepción.

La siguiente fase es la de transferencia de información, que se realiza mediante

operaciones de entrada/salida según el ﬂujo sea desde el ﬁchero al programa o viceversa.
75



Habitualmente, las operaciones de entrada/salida con ﬁcheros son similares a las que se

utilizan con la pantalla y e] teclado, con la salvedad de que hay que especiﬁcar la variable
ﬁchero a la que se reﬁere la operación como primer parámetro de la misma.

Leertn , Varl)

Escribir ( F2 , Var2)
Memoria RAM Fichero Memoria RAM Fichero
Pro a Pro

Bntïer de cscmur Buffer de lectura



Ilustración ll Flujo de la información a través de buffers

Finalmente, cuando el programa haya completado el trabajo para el que necesitaba la
información del ﬁchero, debe solicitar el cierre de la comunicacion mediante otra operación
especíﬁca; de no hacerlo asi, podrían producirse pérdidas de información por el canal abieno.
Ello puede pasar, fundamentalmente, cuando el trasvase de información va desde el programa
hacia el ﬁchero y se debe a que, para minimizar el alto coste en tiempo de acceso a los
dispositivos de almacenamiento, las operaciones de lectura y escritura no se realizan
directamente con el ﬁchero. sino que se habilitan unas áreas en memoria denominadas
bufferr. de tal manera que, cuando el programa solicita un dato del ﬁchero, no sólo se
transﬁere a memoria el dato solicitado, sino un bloque mayor que se guarda en un buﬂer de
lectura en la suposición de que probablemente el programa pedirá a continuación e] siguiente
elemento; si esto es asi, en las siguientes peticiones del programa no se accederá a memoria
externa. siempre que Ia información solicitada se encuentre en el buﬂer. De modo
equivalente, cuando cl programalrealiza una operación de escritura, esta no ocurre realmente
en el ﬁchero, sino que la información se va acumulando en un bujïer de escritura que es
transferido al ﬁchero cuando se llena. La operación de cierre garantiza que la información
que quede en el buﬂer de escritura cuando se termina de trabajar con el ﬁchero sea.
efectivamente, incorporada a éste; si el programa termina bruscamente sin cenar los ﬁcheros
en los que ha escrito, la ínfon-nación que quede en los bujferx se perderá. E] intercambio de
información entre el ﬁchero y el algoritmo queda ﬁnalizado mediante la operación

cerrancerrar (F)4

íf/—

76

Cuando se manejan ﬁcheros con tipo, las variables que se usen para intercambiar
información con e] ﬁchero deberán ser compatibles con el tipo del que se han declarado los
componentes del mismo.

En todo ﬁchero supondremos la existencia de un indicador de posición (LPM) que
señala a un componente del ﬁchero. Al abrir el ﬁchero el IPos apunta al primer componente;
al efectuar una operación de lectura o escritura. se lee o escribe un registro empezando en la
posición indicada por el IPos y este avanza en proporción a la información leida o escrita,

quedando listo para que se lea o escriba el siguiente registro.

lPos —>



<EOF> IPoS -—> <EOF>



Final de fichero = Falso

Ilustración 13 indicador de posición (lPos) y marca de ﬁn de ﬁchero (EOF)

Operaciones auxi gres.

Para que la gestión de la información almacenada en ﬁcheros sea correcta es necesario
que se proporcionen operaciones de control que pennitan conocer cosas como: el tamaño de
un ﬁchero, si se ha alcanzado el ﬁnal de una linea o el ﬁnal del ﬁchero, etc, y actuar en

consecuencia.

Si un ﬁchero se recorre secuencialmente, es fundamental detectar cuando se alcanza e!

ﬁnal del mismo, para conseguirlo disponemos de una función lógica FinFicherafF)

77

Para calcular el tamaño de un ﬁchero usamos la función Ïimañaﬂ’), que dïuelve su
taLño en bytes para los ﬁcheros no uniformes y para los uniformes su tamaño en número de
componentes de ese tipo —su tamaño en bytes será este número multiplicado por lo que
ocupa un componente de ese tipo. Para conocer lo que ocupa una componente de un tipo
dado usaremos la función: Tamaño(UnTipa). g

La operación que permite situar el [Pos en una pgsíﬂfïl’ cuailouiera del ﬁchero
pennitiendo el acceso directo es I_rA(F,Pm), que coloca el indicador del posición del ﬁchero
F en la posición Pos. Los valores que puede toma: Pos están comprendidos entre l y
Tamañoﬂv‘) + l. Cuando el IPos se sitúa en esta última posición sólo se puede‘ hacer un
acceso de escritura.

La función Posiciónﬂ") devuelve un valor entero indicando la posición actual del
Ifos. en bytes o registros. según sea el ﬁchero. -7

Renambrarf/Vqmbfe Vigo, NambreNueva), donde NombreViejo y NombreNuevo son
ristras conteniendo, respectivamente, el viejo y el nuevo nombre que se quiere dar al ﬁchero,
es una función logica que devuelve verdadero sí el cambio de nombre se realiza con éxito ——
no puede hacerse si ya existe un ﬁchero con el nombre nuevo.

El procedimiento EIiminarﬂVombrgFic-hero). elimina el ﬁchero ﬁsico cuyo nombre

viene dado en la ristra NombreFichero.

Operaciones especiﬁcas de ﬁcheros de texto.
La operación LeerLíneaﬂïl/ar) lee una linea de un ﬁchero de texto y deja el ¡pax

preparado para leerla siguiente.

La operación EscribirLíneaW, Var) escribe una linea en un ﬁchero de texto y avanza



el Ipos .

La función FiíLíneaﬂï) devuelve verdadero cuando se ha alcanzado una marca
<EOI) y falso, en casoïoírario. Sirve para saber si se ha alcanzado el ﬁnal de la misma
cuando se trate una linea parcialmente.

El procedimiento SídtarLineqF) mueve el IPus del ﬁchero F detrás del próximo
<EOI> , o sea, saltar a la siguiente línea del ﬁchero. Sirve para desechar el resto de una linea
que se ha leido en parte.

El procedimiento NuevaLinea(F) escribe un salto de linea (<EOL>) en el ﬁchero F

dando comienzo a una nueva linea,

78

Ejemplos
E] siguiente algoritmo muestm los pasos más comunes a la hora de trabajar con un
ﬁchero, en este caso tipo texto. Este ejemplo copia el contenido de un ﬁchero de texto,

NUmIQEnIrada, sobre otro ﬁchero, NomlïSalida.

algoritmo copiargichero
variable FicheroTexto Fich_Entrada, Pich_Sa1ida
ristra Línea, NomF‘_Entrada. nomxgsanda

escribir 'Deme el nombre del fichero a copiar"
leer Nomlïﬁzntrada
escribir "Dame el nombre del fichero destino‘
leer NomF_Sa1ida

si Abtir(Fich_Entrada, NomF‘_Entrada, Lectura) entonces

si CrearFiChero(Nom1-'_Salida) /\
Abrir(FiCh_Sa11da, NomF_Sa1ída, Escritura) entonces

mientras no FinFiCherQKFiChÁIZ-Zntrada) hace:
LeerLínea < Fichjintrada, Línea)
EscrihirLínea(Fích_Sa1ída,Línea)

Ein mientras

Cerrar (Fichjntrada)
Cerrar(Fich_sa1ida)
si no
escribir "No se puede Crear el fichero de salida"
Cerrar lFichjlntrada)
fin al
si no
escribir "No se puede abrir el fichero de entrada
ﬁin a1
parir
fin algoritmo (Copiar_Fíchero)

El siguiente algoritmo recorre un ﬁchero de entrada que contiene un texto en el que
las palabras están separadas por un único espacio, no hay espacios al principio ni al ﬁnal de
cada línea y no hay palabras nartidas entre líneas, y calcula la frecuencia (absoluta) de
aparición de cada palabra, escribiendo en un ﬁchero con tipo las palabras diferentes y su

frecuencia.

tipo TRegFreC ea estructura {Registros del fichero resultante)
campo rístra Palabra
campo entero Frecuencia
ﬁin tipo (TRegFrec)

algoritmo FrecuenciaPalabra

variables fichercTexto FEntrada
fichera<TRegFrec> Fsalida
ristra Línea, NomFEntrada, NomFSalida

79

escribir "nombre del fichero a tratar: "
leer NomFEntrada

escribir "nombre del fichero resultante: "
leer NomFSalida

si abrir(FencradamIomFEntrada,Lectura) entonces {Abrir Ficheros}
si abrir(Fsa1ida,NomFSa1ida,Crear) entonces

mientras {no Finﬂ-‘Entradan hace: {Procesar c1 texto)
1eer(FEntrada,Línea)
SaltarLínea (FEntrada)
Procesarnínea(Líneamsalida)

Ein mientras {Procesar el texto}

cerrarmsanda) {Cerrar ficheros)
un si
cerrar (FI-Entrada)
fin si
parar

un algoritmn (Frecuenciavalabza)

procedimiento ProcesarLínea (Línea, Fsalida)
variables entrada ristra Línea
entrada/salida fichero<TRegFrec> Fsalida
lccales TRegFrec RcgFrecJzegFrecL
entera i

miantraa lHayPalabraMLíneaH hacer {procesar línea}
{Se obtiene una palabra}
RegFrezxPalabra 4— Tomarprimpauninea)
RegFreoFrecuencia <- o

í <- 1 {Buscar la palabra}
lrAtFsalidi-Ll)
mientras (i S TamañcHFSalidaH A
(RegFrecL.Pa1abra a: Regnemvalabra) hace:

leerwsalidamegFrecLl

i <- 1+1
Ein mientras

si (í > TamañtMFSalidaH entonces

RegFrecL <- RegFrec
Ein si

{Escribir la palabra con su frecuencia en el fichero de salida}
RegFrecLFrecuencia <— RegFrecL.Frecuencia+1
IrA(F‘Sa1ída,i)
escribir(FsalidenRegFrecL)
un niantrnu {Procesar línea}

retornar
un procedimiento {ProcesarLínea}

función lógica HayPaIahraSKLÍneEJ
variable entrada ristra Línea
davolver (Lonmínea) > 0)

fin función (Hay/Palabras)

80

función ristra Tomarprimpalmínea)
variable entrada/salida ristra Línea
local nstra Palabra
natural PosEsp

PosEsp 4— Pos (Línea, " ") ;

a1 PosEsp > 0 entonces
Palabra e sub(Línea,1,FosEsp — 1)
Línea <- sub(Línea,PosEsp + 1)
a1 no
Palabra 4— Línea
Línea «- --"
fin si
devolver Palabra
fin función {TomarPrimPal}

Obviamente, éste es un algaritmo muy lento, por el gran número de accesos a
ﬁcheros. Si se hubiesen calculado las frecuencias sobre un vector sería mucho más rápido.

pero estaría limitada a priori en cuanto al número de palabras diferentes que podria procesar.

¡‘I

El tructuras de datos dinámicas.

Memoria dinámica.

Planteamiento.

Hasta ahora no hemos visto la memoria como un recurso escaso y en consecuencia no
hemos tomado ninguna precaución especial respecto a su utilización por parte de nuestros
programas: simplemente declaramos todas lu variables que nos hagan falta; si la necesidad
puede variar para distintas instancias del problema, se supone el peor caso y se hacen
declaraciones acordes. Ya hemos aprendido. sin embargo, que el espacio de almacenamiento
es un bien limitado, y hemos introducido un nuevo elemento —los ﬁcheros— para disponer
de almacenamiento más barato y duradero. Sin embargo, lalemïia central sigue siendo el
área de trabajo del procesador infonnático y todo lo que ha de ser procesado ha de estar en, o
pasar por, ella —persiste el problema de¿arla_ geﬁlammás o})_ti_n1igeui_a posible. Esta
optimización pasa por que el programa tenga la opción de (¿agar memoria de fonna no
estática, tomandola cuando le haga falta y liberándola para otros usos cuando deje de
Eesitarla. La mayoria de los lenguajes modemos hacen esto de forma automática a nivel de

subprogramas: delimitan una zona de la memoria. que llaman pila de ejecución, en la que se

ubican, entre otras cosas, las variables declaradas de un Subprograma en e] momento en que
éste se va a ejecutar (proceso conocido como elaborar las declaraciones). Cuando el
subprograma termina su ejecución. sus variables son sacadas de la pila de ejecución,
quedando el espacio que ocupaban disponible para nuevos usos. En cada momento se
encuentran en la pila de ejecución las variables de todos los subprogramas activos, en orden
de más recientemente llamado a menos recientemente llamado.

El conocimiento de cada problema por parte del programador podria permitir u_n uso

aún É dinámico de la memoria, creando y destruyenglo yariables justo en el ‘momento en

que sea necesario, sin que las mismas tengan que estar determinadas a priori ní aparecer en

ninguna declaración.

Para poder hacer este uso dinámico de la memoria es p_reci_so que elsisterna en que se



vaya a ejecutar nuestro programa dispgn de gilgfyrmecanisrngﬁggegontrolela memoria.
delímitando una zona especíﬁca para este ﬁn, conocida como memoria dinámica o ”heap”. y

83

distribuyendola en respuesta a peticiones de los programas formuladas en tiempo de
ejecución mediante sentencias del lenguaje de programación que se esté usando. Un

mecanismo de esta clase lo denominaremos en adelante Módulodí Gestióníde Memoria

denes: (l) para solicitar la





Dinámica y lfiaﬁjproporcionar al menos (iii
aïción de un lﬂícrque de memoria —crear una variable dinámica—— y (2) para indicar que
un bloque de memoria deja de ser necesario y liberarlo —eliminando una variable dinámica.
A la hora de crear variables dinámicamente se plantea un problema: ¿cómo las
referenciamos? Las variables estáticas y de pila tienen un nombre que se ies da en el
momento de declararlas y por medio del cual podemos referimos a ellas en cualquier punto
del programa. Con las dinámicas podría pensarse en alguna forma de darles un nombre en el
momento en que se solicitan al MGMD, pero es técnicamente diﬁcil, y lo que nos
encontramos en los lenguajes de programación usuales es que el MGMD se limita a
proporcionar como respuesta a la petición de un bloque de memoria la dirección ﬁsica de uno
utilizable —aunque no parezca evidente, esta es una solución mucho más ﬂexible en casos en
que las necesidades de memoria puedan variar mucho. Como consecuencia aparece una
nueva Qasteïdatorque los programas deben ser capaces de manejar, el tipo "(Hi1 _de
memoria". con operaciones especiﬁcas. Vamos a llamar puntero a este nuevo tipo, y
siguiendo la norma de los lenguajes con tipado fuerte emplearemos la notación

puntem<trpo> para declarar variables cuyo onten" ¡sean diregg nes _de_ memoria, así



tendremos: h‘ ._

variables _ i
puntero<rea1> a (dirección de una variable real)
puntero<ristra> b (dirección de una Variable rístra)
puntero<entero> c (dirección de una variable entera)
puntero<puntero<rea1>> pp {dirección de una dirección de una variable

real)

Aunque todos los punteros son iguales en cuanto direcciones de memoria, el que al
declarar una variable puntero haya que especiﬁcar a qué se quiere que apunte permite un
mejor control de la actividad del programador y. por tanto, una cierta seguridad en las
acciones ejecutadas. Sin embargo. a veces es necesario hacer “operaciones peligrosas", la
posibilidad de que un mismo puntero pueda referenciar objetos de tipos diferentes en
momentos diferentes es, con frecuencia, útil en programación de sistemas. Eventualmente,
puede ser útil en ciertos entornos usar punteros para apuntar a variables estáticas ——tambie'n
tienen una dirección-z aunque no sc podrian usar para crearlas o destruirlas, y es una

B4

práctica peligrosa —se crea un alias de la variable estática que puede permitir modiﬁcaciones









encubiertas.

‘Ï Ju LasPal " '23  7
a ¿m? rene’  m; '>'>lh¿",, Laïﬂm” wwhvzs‘
a Pedro tialda: 23 ¡

É ‘n? 77? " ' 7'77 l

É m _  j

5 W, y%í>carp; Galdar _ m’ W '37};
._- , , ,

a ,_

p; 0000F_E3ft' n — —

é ooo 1343 — ——— ) _, N" _,,

g pooorroo¡ —r — ———>lM!"Ïl T515“, ,___ M22,
í

E

2

4

a

.5 .

__. _,

Memoria no dinámica Memoria dinámica

Ilustración u Ejemplo a: uso dinámico a: la memoria

Nuestros programas podrán tener yaríables de t_ipo pungo —declaradas o



dinámieas— que se utilizaran para guardar las reccíones de otras variables ——generalmente

dinámicas— ¿"servirán como mïejismos de ¿eeeso a eggs últimas. Supongamos por

ejemplo que necesitamos implementar una lista de alumnos, prevista para contener un

máximo de 600 alumnos y que esté basada en el tipo:

tipo Tnlumno en estructura
campo ristral6ül Nombre
campo ristrallüü] Dirección
campo caracter Sexo '
campo entero Edad

fin eipo (TAlumno)

Este registro puede ocupar unos l65 bytes. En caso de utilizar memoria estática

necesitaríamos un vector dimensionado para contener 600 de estos registros:

variable TAlumno LiStaAIurnnOSHOÜI

«rr to

lo cual implica una reserva de memoria de 99000 bytes (96,68 Kbytes). Sin embargo, si
declaramos un vector de punteros a registros de alumnos, y suponiendo que un puntero ocupa

4 bytes —tamaño habitual—, sólo estaríamos ocupando pennanentemente durante la

85

u
ejecución del subprograma que contuviese esta declaración 2.400 bytes (aproximadamente Z
Kbytes), mas 165 por el número real de alumnos que se este’ manejando. Bastaria con que
faltara alrededor del 2,5% de los alumnos previstos para que el uso de variables dinámicas

empezase a resultar rentable.

tipo PuntAlumno es puntero<TAlumno> Ein tipo

variable PuntAlumno ListaAlumnos [s o o]

Creación y eliminación de variables dinámicas.

Sea T un tipo cualquiera y Q una variable de tipo puntero<T>; el MGMÜ permite
considerar como primitivas las acciones de creación y de eliminación de las variables
dinámicas de tipo T. lg forma general de la acción de creación implica una indicación al
MGMD de que se necesita un bloque de un tamaño determinado y la respuesta de éste dando
Laﬂeocion de un bloque libreﬁdel tamaño especificado. si existe. En nuestra notación se
expresa COÏTIÜI T

o « Tomarmoque (T) mu‘,

lo que signiﬁca una petición para que el MGMD busque un hueco en la memoria capaz de
albergar una variable de tipo T y devuelva su dirección, la cual se asignará a Q. E_n caso de
que no exista ningún hueco capaz de albergar valores de tipo T. el MGMD devolverá un
valor que identiﬁcaremos como NULO. Qyalor NULQes _un valor especial que se emplea
siegprïiueﬁllalqueindicargue una variablepuntergno apunta a ningunrbltgue. En adelante
usaremos TomarBloque en nuestros ejemplos suponiendo que siempre hay memoria dinámica
disponible —a ﬁn de no complicar la estructura de los algoritmos. Los casos de fracaso
requieren el tratamiento de excepciones de ejecución que dependen de la naturaleza de la
aplicación y exceden nuestros objetivos actuales.

Con el ﬁn de evitar, en lo posible, agotar el espacio disponible, el programa debe
devolver sistemáticamente a la memoria dinámica disponible los objetos que ya no necesita;

laacción de "re_lirninación” de larvariable ¡jinámica referenciada por el puntero Q se expresa

como:

Liberada)

86

VEn la ejecución de la acción LÍberQrLQ, el MGMDguprime el objggogguntado poLQ
y reincorpora el espacio que ocupaba al pool de espacio disponible. me que Libegﬂlnq
¡sfïtaallaïle Q; sólo se utiliza para saber que’ bloque de memoria hay que liberar, pero
Q sigue manteniendo su valor aunque éste sea ahora la dirección de un bloque cuya
utilización sería un error; ej conveniLIteNULO a gdespLésdeAlilí el espacio que

referencia; aunque como veremos ello no soluciona todos los problemas.

Acceso "grijlwles É?‘.EE"°_¡“S¡E_R‘I'EP‘°V°S-

Preguntabamos anterionnente cómo podiamos referenciar las variables dinámicas que
creásemos, y en lugar de responder a esa cuestión hemos introducido un nuevo tipo de
variables; ahora tenemos la variable dinámica más otra que contiene su dirección; ¿cómo
podemos usar esa dirección para tener acceso a la variable dinámica? La notación que vamos
a emplear deriva de la representación gráﬁca usual para expresar la relación entre una
variable puntero y aquella a la que direcciones, representación que se maniﬁesta mediante una
ﬂecha. De esta manera, siendo Q una variable puntero, cuando en nuestro programa
escribamos Q nos estaremos reﬁriendo a dicha variable, pero si escribimrig a. nos
estaremos refugio a "lo que está detrás de la ﬂecha", es decir, a la variable apuntadaJJoLQ.
gesta variable fuese de un tipo compuesto de campos, nos refeririamos a cada campo como
gaNambreCam a, y si fuese unwvectgr, indicaríamos el i_esimo elemento como Qjﬁ]. La

operación consistente en acceder a la variable rerferenciadapor un puntero recibe el nombre

de dereﬁancitïiég.



Memoria
dinámica

Ilustración l5 Puntero y variable apuntada

Problemas al usar punteros.

Los punteros permiten un uso muy eﬁciente de la memoria en ciertas situaciones, pero
han de usarse con cuidado porque también plantean problemas:

l. la necesidad de estar segu_r0s de que el puntero_ grïiene una dirección válida —el

intento de dereferenciación o liberación de una dirección no válida podria causar un
error de acceso,

87

lo

el peligro de la creación de elias si sepsiggní a dos punteros diferentes la misma

dirección,

3. la combinación de los dos anteriores si una variable dinámica referenciada por dos
punteros es liberada usando uno de ellos —accesos posteriores con el segundo
puntero resultarían en un error—,

4. la posibilidad de dejen variables dinámicas 'nacces'bles si están referenciadas por un

único puntero y se cambia el valor de éste y

5, la inoperanciage los mecan’ mos d t s de entrada con



las yvarigsjes dinámicas cuanglrïícﬁeisepasg por parámetros es un puntero —e'ste

estaría protegido, pero no la variable a la que apunta.

A continuación se desarrolla un ejemplo que ilustra algunas de estas situaciones.
Supónganse que P, Q y R son punteros a enteros y que I y J son enteros; al elaborar la
declaración de las variables se crean cinco variables estáticas de dos tipos diferentes con

valores indeﬁnidos y ninguna variable dinámica.

variables ï 3
entera I l l
puntero<entero> P, Q P‘
entera J Q
puntero<entero> R
J l
R
Memnria
dinámica

Instrucciones como las siguientes, provocan un error de acceso:

P” *‘ 3
Liberar 1Q)

El siguiente bloque de instrucciones sí sería válido. y dejaría deﬁnidas todas las variables,

además de crear tres dinámicas:

I e 3
p k TomarBloquehentero) l 3 , i
Q ' Tomaraloquuentero) P ' >l 3 l i
J e 5 Q: >4 5 ‘
R e TomarBloquelentero) J 5
p > e I l
o > e J R y >l 7 l
R'> a 7 i ,
Memoria
dinámica

88

La siguiente sentencia crea un alias al mismo tiempo que deja inaccesible una variable

dinámica:

0*?



si ahom se libera la variable referenciada por P, Q se convierte en lo que se conoce como un

"puntero salvaje" ——contiene una dirección inválida por referenciar un bloque ya liberado.

Liberarl?)
P *’ NULO



Estructuras encadenadas. . ' v .  _ l

Concepto de ubicación encadenada.

Considérese una lista ordenada de nombres como la siguiente: ("AgustínÏ "Ana".
"Emesto", "Juan", "Plácido"); podría implementarse fácilmente mediante un vector de ristras,
pero supóngase que en esa lista las altas y las bajas, ocurren con una gran frecuencia; una
gran variabilidad se traduciría en un alto coste para mantener el orden de la lista. A modo de
ejemplo, se muestra como evoluciona el vector al introducir la secuencia de nombres anterior.
Las inserciones de "Ana", "Emesto“ y "Agustín" provocan desplazamientos de los elementos
ya insertados con el ﬁn de mantener el orden adecuado —de la misma manera, si se extrajese
un elemento que no fuese el último seria necesario desplazar los posteriores a ﬁn de rellenar

el hueco ocasionado.
89

Insertar: Insertar: Insertar: Insertar: Insertar:






"Juan" "Ana" "Plácido" "Ernesto" "Agustín"
Posición

Juan Ana ,_ _ Ana Ana ¡Agustin

_Ji_1an V Juan Ernesto p Ana
l E9 ‘M39 , , ‘Ernesto

Plácido Juan

Plácido

1
2
3
4
5
6
7
B



Ilustración I6 Secuencia de inserciones en un vector

La razón de este coste es que el orden lógico —en este caso alfabéticc- de la lista se
ha hecho coincidir con el orden ﬁsico de la ubicación contigua de los elementos del vector. Si
uLi-"Lelerimiïe, Ja lista PUÚÏCFFÏJEQPÉÑSÉJ“,“"3,¡'ldÏ°‘!9¡ó'Ï‘ É°_@LÏ,°_5°_&‘F_“ÉEE’?
tïsiínfnte su sucescggnjlícÉn lógico establecido, este no tendría que insertarse en una
posición contigua. Podemos modiﬁcar los elementos del vector dc fonna que en vez de ser
ristras. sean de un tipo estructurado con dos campos. uno ristra que contiene el nombre y otro
entero que indica en que’ posición del vector se encuentra el siguiente elemento en orden
lógico. A esto se le llama encadenar los elementos de la lista, y permite que las inserciones y
extracciones se efectúen sin desplazamiento de información; ¿orcojtra las húguedﬁ (¿i131
qiïqlïrïs —— en el vector podía emplearse, por ejemplo, un algoritmo
dicotómico- y además se necesitarïgspacpio para almacenar los mismos datos al tener
que contabilizar los campos de encadenamiento.

Como los elementos pueden hallarse ﬁsicamente en cualquier posición. se hace
necesaria una variable entera que indique dónde se encuentra el "primero" —a partir del cual
se puede recorrer toda la lista. El principio de la lista en la ﬁgura se ha simbolizado por "E".
Se ha puesto un 0 en el campo de encadenamiento del último elemento —que al ﬁnal ocupa

ﬁsicamente la 3“ posición- para indicar que detras de él no viene ningún otro —el valor



cero. al no corresponder a ninguna posi n válida del vector se ha utilizado aquí como marca

de ﬁn de la secuencia de encadenamientos.

90

D:
Insertar: Insertar: Insertar: Insertar: ‘ Insertar:
“Juan" "Ana" “P1áCid0" "En-testo“ "Agustín"
u







V 0 ‘Juan W 3

1_ Ana _ 4
m” _ Pﬁcido 0__
‘Ermua . 1

Agustín, 2

R indica la primera posición (lógica) de la lista

Ilustración 17 Inserción cn una lista eneadenada en un Vector

Situaciones especiales.

Hay algunas cuestiones que deben tenerse en cuenta: (l) la politica que se ha seguido
en la ﬁgura ha sido la de partir de un espacio de almacenamiento inicialmente vacío, y
comenzar a insertar nombres a medida que van llegando; en cada ocasión se modiﬁcan dos
encadenamientos —el del elemento recién insenado y el de su predecesor- con el ﬁn de
mantener el orden lógico, si se continúa insertando, el cuarto elemento a partir de la situación
actual —suponiendo que no se hubiesen producido extracciones— no encontraría espacio
disponible —una situación como esta, en la que se necesita gggiiïggndggg} se ha

agotado el espacio de almacenamiento, Ïfonoce como situación de “sobrecarga
(overﬂow)—; (2) podría ocurrir la situación inversa si iniciamos una secuencia continua de
extracciones  cuando I¿¡_li_sta guedase vacía se intentagennagr una extracción nos
encontraríamos ante una situación ‘de Ïbajo mínimo” (underﬂow)— y (3) el aprovechamiento
del espacio liberado por las extracciones; en el ejemplo de la ﬁgura —en el que sólo se han
hecho inserciones- el espacio vacío permanece agrupado y localizado al ﬁnal de la zona de
almacenamiento reservada, sin embargo, si se extrajese un elemento —por ejemplo Ana- de
la lista, se observa claramente en la siguiente ﬁgura que ello daria lugar a un hueco libre que
ya no estaría agrupado con el resto. Si no se implementa algún mecanismo para poder
reutilizar estos espacios liberados, el resultado serían situaciones de falsa sobrecarga —hay

espacio para nuevas inserciones pero éstas no podrían efectuarse.

9|

L3.’

onstazuuumm-



Ilustración IS Hueco al libera un elemento

Para aprovechar esos espacios no cabe plantearse el compactar la lista cada vez que se
realice una extracción —se estaría en la misma situación que cuando el almacenamiento era
secuencial , con continuos y costosos desplazamientos. Una primera solución es ggigcar de

alguna m (los huecgs libgrgtjps en el momentg de la extracción Lrecun-ir luego



periódicamente, o cuando el grado de fragmentación se estime suﬁcientemente alto, a un
pmcedímlento de firecoleccicln _de ntlesgerdíciosf (ggrlgqgeﬂcollection) que realice la
mencionada compactación. Otra solución muy efectiva es aplicar el concepto de

cncadengrnientoggglïénggjpgcïg li_bre, fumando de esta manera una Iisla encadenada de

espacm libre — la extracción de un elemento de una lista se traduce en una inserción

simultánea en la lista de espacio disponible.

“E”

EJE ta;



Aﬁsáaﬂaïrﬁ‘ Dnxsdaeaawﬂ“

Ilustración l? Lista encadenada de huecos libres

92

Representación delistas encadenndas.

En los ejemplos anteriores se han implementado las listas encadenadas en un espacio
de almacenamiento que era en esencia un vector: es sólo una de las posibles formas de
implementar una lista encadenada: podemo co ïuirie tructuras encadenadas utilizando

como base cualquier forma de almacenamiento que pennita guardar múltiples elementos

777” l

lógica a los datos almacenados en un ﬁchero o estructuras encadenadas en memoria

indi



duales y rreferenc



' dep dentemente —usarlas para dotar de estructuración

dinámica. La utilización de encadenamientos es apropiada para estructuras de datos ¡gue
tierïtyltáogïado de variación —son muy dinámieas—; los mecanismos de la ubicac n
dinámica permiten ajustar la ocupación de memoria a las necesidades existentes en cada
momento de la ejecución de un programa con lo que resultan apropiados para implementar
escrucmms encadenadas —al contrario que la representación en vectores, no requiere reserva

de memoria.

Algoritmos de manipulación de listas encadenadas.

A continuación se presentan varios algoritmos básicos de manipulación de listas
simplemente encadenadas implementadas en memoria dinámica —con otras
implementaciones los algoritmos no varían esencialmente más que en lo relacionado con los

es bas en la



mecanismos especíﬁcos de representación»; podemos identiﬁcar dos a ﬂ _ 7
manipulación delstas Qüﬂadﬂsi   un elemento —añadir un nodo- o (2)
extraer un elergitg —-eliminar un nodo—; ambas acciones se pueden realizar en tres lugares
en una lista: (l) al principio. (2) al ﬁnal o (3) enmedio. En todos los casos se supone que la
variable puntero que se va a utilizar para mantener el acceso al primer elemento de la lista se
inicializa con el valor NULO antes de empezar a usarla. Las estructuras de datos utilizadas se
deﬁnen de la siguiente manera:

en Talamanca un tipo asignable
tipo Nodo al estructura
campo TElemento Info
campo PLista Siguiente
un tipa
tipo PLIsta es puneero<Nodo> fin tipo

93

Iírlserciícírral Principio de una lista encadenada.
Es el caso más simple, ya que basta con crear un nodo con la infonnaeión requerida y
copiar en su campo de encadenamíento el valor del puntero que da acceso a la lista,

cambiando éste a continuación para que apunte al nuevo nodo.

procedimiento Insertarnelancemﬂ)
[Se inserta el Valor de v al principio de 1a lista apuntada por L.
[L debe tener una dirección Válida, o el Valor NTJLO (lista vacía) .
vatiablenentradn/anlida PLÍSCB L
entrada Tipovalor v
locales PLista Nuevo

Nuevo e romarmoquemodo) [Se coma, un bloque, se pone s1 Valor
NuevoaInEo « v [y se hace que indique como sucesor a1
Nuevoasiguience v 1. /que actualmente sea el primero. E1 puntero
L « Nuevo Ide acceso cambia para señalar a]. nuevo
retornar

un procedimiento

Tal como ilustra la ﬁgura. la inserción de un elemento al principio de una lista

encadenada se hace en tres pasos.

Ll; ">59? *"' >ñÏLl 7" >l0°Í>ll



Nuevo  " >L

L l 559M '9,°°°Ï >°°°lÏ
__, 2
Nuevo l —— > ooo ‘ '
L  ylwüf "W300,," W100i l
Nuevo JÏ esÍsíu y 3

Ilustración 20 Inserción z] principio dc una lista encadenada

En el primer paso. se reserva espacio para un nuevo nodo, recogiendo su dirección en
la variable local Nuevo y rellenando su campo de información con el valor a insertar. A
continuación hay que encadenax el nuevo nodo con el resto de la lista; para ello, primero se
copia en su campo de encadenamiento el valor de la varible L —el puntero de acceso a la
lista—. con lo que el nuevo nodo está señalando como su sucesor al primero de la lista.
Finalmente, hay que hacer que el nuevo nodo se convierta en el primero de la lista. lo que se

consigue asignando a L el valor de Nuevo.
94

Inserción gl ﬁnal de una li}? encadenada.
En este caso el problema reside en encontrar el ﬁnal de la lista para insertar un nuevo

nodo a continuación.

procedimiento InsertarDetrás (LV)
[se inserta el valor de V a1 final de la lista apuntada por L.
[L debe tener una dirección Válida, o el Valor NULL) (lista vacía).
variables entrada/salida PLista L
entrada Tipovalor V
locales PLísta Nuevo

B1 (L = MILO) entonces [Insertar al final es lo mismo que
Insercerneinneemw) [insertar a1 principio de la sublísta
si no Hvacía) que sigue al última nodo,
xnsereernecrán(Lasiguieneev) [y lo mismo que insertar al principio,
fín al [Si 1a lista está Vacía.
retornar

f in procedimi ente

Con está solución, insertar al ﬁnal de una lista encadenada se transfonna en ínsenar al
principio de la lista —vacía— que sigue al último nodo. Aunque es una solución fácil, puede
resulmr costosa si las inserciones al ﬁnal son muy frecuentes. En este caso, sería adecuada

mantener un puntero que señale siempre al último nodo de la lista, lo cual facilitiraría

enormemente la inserción.

procedimiento InsertarDetrás_2 (Prim,U1t,V)
[Se inserta el valor de v al final de 1a lista apuntada por Print.
{Prím debe tener una dirección Válida, o e1 valor me (lista vacía).
[me apunta al último nodo de la lista apuntada por Prim.
/s1 Prim es mms, v1: es NULG
vatiahlenantrnda/aalida PLista Pxirn, un:

antrnda Tipovalcr v

1een1en PLisca Nuevo

si (Prim : NULO) entonces
1nsercarnelantetvrim,v) [E1 primer y último nodo serán el misma
v1: e Prim

si no
InsertaxDelante(U1t*Siguiente,V) [Prim no ee Ve afectado

m: k Ulcüsiguience
Ein si

retorna:
E in proc edimiento

95

Inserción ordenada

Para ilustrar la inserción en cualquier lugar de la lista se presenta un procedimiento
que inserta un elemento en su lugar según un orden ascendente Aexige que el tipo de la
información de la lista, TElemento, sea ordenable, que se interpreta en este caso como
admitir el operador "s". Hay que suponer que la lista está ordenada y de lo que se trata es de

hacer una inserción sin que deje de estarlo.

procedimiento Insertarlïnorden (L, v)
¡se inserta el Valor V en su posición ordenada en la lista apuntada por L
¡L debe tener una dirección válida, o el valor Num (lista Vacía).
[si L no es NULO, los nodos encadenados deben estar ordenados entre sí
[según el valor de sus campos Info, en orden ascendente.
variableuentrada/aalidn PLista L

entrada Tipovalor v

locales PLista Nuevo

a1 1L : MILO) o ¡v s LaInto) entonces [si es menor que s1 primero,
Insercarnelancunv) ¡v Va al principio de 1a lista
si no jsino, irá donde le corresponda,
InsertarEnOrden(L"Siguíente,V) [en la sublista que Sigue
fin si [al primero.
IECOZBG!

ﬁin procedimiento

Si el valor a insenar es menor que el primero de la lista, se utiliza InsertarDelante, si
es mayor que todos los que contiene la lista. lnsertarEnOrden funciona exactamente igual que
InsenarDetrás; pero tiene la posibilidad de dejar de hacer llamadas reeursivas en cuanto
encuentre un nodo con una información igual o mayor que la que se quiere insertar, con lo
que se consigue la inserción enmedio como inserción en el principio de la sublista en la que

todos los valores son iguales o mayores que el dado.

Extracción al principio.

En el caso de la extracción, vuelve a ocurrir que el caso más simple es la extracción
del primer elemento de una lista: l) Se reserva la dirección del nodo a eliminar en una
variable auxiliar local, 2) se asigna al puntero que indica el principio de la lista la dirección
del siguiente nodo —si no hay más quedará con el valor NULO— y 3) se libera el nodo que
ocupaba la primera posición utilizando la variable auxiliar en la que se había guardado su

dirección —todo esto siempre que la lista no este’ vacía de entrada.

96

procedimiento ExtraerDelante (L)
‘Extras el primer nado de la lista apuntada por 1..
/L debe tener una dirección válida, o el valor MILO [lista vacía).
varinblesentrada/anlida PLista L
locales PLista Aux

a1 L % NULO entonces /s1‘ 1a lista no está vacía, se extras el primer
Aux k L. [nodo tras haber hecho avanzar L al segundo.
L v Lásiguience [L quedará con el valor MILO si sólo hay un nado.
Líberarﬂkux)

ﬁin si

IBCOXEÁ!

Ein procedimiento

LT W’ ‘N500 "* >'°°° >9<2E
1
Aux h —



\
x

L1’ I 000i ——>> 90o] ) ﬁoío’;
T 2
Aux ‘ V7"
L v" — r—— >gT »ﬁooow
A 3
Aux  "”'

Ilustración 2| Extracción al principia de una lista encadenada



Extras n al ﬁnal.

La exxracción del último nodo de una lista —que tenga algún nodo- de divide en dos
casos: l) que sólo haya un nodo en la ¡ista pasada —se extrae- a 2) que haya más —se
extrae recursivannente e] último del resto de la lista. A] contrario que en la inserción, tener un
puntero al ﬁnal de la lista no solucliona nada en una lista simplemente encadenada puesto que

hay que modiﬁcar el enlace Siguiente del penúltimo nodo al ¡ransfonnarse en último.

procedimiente Extraernecrás (L)

jﬂxczae el último nodo de 1a lista apuntada por L.

[L debe tener una dirección válida, o el Valor num (lista vacía).
variableaantrada/salida PLista L

n y. s Num entonces [Si la lista no está vacía se puede extraer.
¡x rnsiguience = NULO entcncan
LíberaﬁL) [Si es el última se extrae.
L ‘ NULL)

97

s1 no
ExtraerDetrás(Lesíguiente) [Si no se avanza recursivaments

ﬁn si
fin si
retornar
Sin procedimiento

Extracción ordenada.

La extraccion ordenada es la única que sigue necesitando el valor a extraer —es una
operación que depende del valor, no de la posición. El siguiente algoritmo elimina de una
lista la primera ocurrencia de un nodo cuyo campo de información tenga el valor

especiﬁcado.

procedimiento ExtraerEn0rden(L,V)
¡se extrae el primer V510; de v de la lista apuntada por L
(L debe tener una dirección Válida, o el valor NULO (lista Vacía).
[Si L no es NULO, los nodos encadenados deben estar ordenados entre sí
[según el valor de sus campos Info, en orden ascendente.
vatlablesenttadn/Belida FLista L

entrada TipoValor v

locales FLísta Nuevo
si (L r NULO) entonces

a1 (v = Lamfo) entonces /v se ha encontrado y se extrae.
ExtraerDelante (L , V)
ui no
si (v > innato) entonces ¡v puede estar más adelante, se avanza.
ExtraerEnorden (LﬁS iguiente , v)
un si
fin si [La primera ocurrencia de V (ya) no está
/en 1a lista.
fin a1
retornar

fin procedimiento

Variaciones de listas encadenadas.

El concepto de ubicación encadenada es muy potente, y permite crear toda clase de
estructuras, libres de las limitaciones de la ubicación contigua. Algunas se enumeran a
continuación a modo de ejemplo.

Listas circulares. Se hace que el último elemento de la lista apunte, con su campo de
encadenamiento, al primero. De esta manera, cualquier nodo es siempre accesible desde
cualquier otro, y el puntero de acceso no está obligado a quedarse ﬁjo en un nodo
detennínado; el inconveniente es que hay que tener cuidado de no entrar en un bucle inﬁnito
cuando se intente recorrer la lista. En ocasiones. la lista circular se monta con un nodo
especial —a veces conocido como cabeza- que actúa como sucesor del último y predecesor

98

TnTntttIl¡unnnuuuuuuntu¡|1¡

N

del primero, y existe incluso cuando la lista está vacía, apuntandose a si mismo, de fonna que

simpliﬁca los algoritmos de manipulación, al eliminar algunos casos particulares.

‘J




73°“
 r>Ï>9°
>lj>i99
ML >v9° e
3 n00

Ilustración 21 Lista circular

Lista doblemente encadenada. Cada nodo tiene dos enlaces, uno que señala, como
en las listas simplemente encadenadas, a su sucesor, y otro que señala a su predecesor, lo que
permite recorrer la lista en ambos sentidos. Aunque en la ﬁgura se han puesto dos punteros de
acceso, uno a cada uno de los nodos extremos, lo que permite iniciar un recorrido en
cualquiera de ellos, en realidad la lista sigue siendo operativa con un sólo puntero de acceso;
incluso —a diferencia de las listas simplemente encadenadas— éste no tiene por qué
pennanecer ﬁjo en el primer nodo, dado que el doble encadenamiento permite alcanzar un

nodo desde cualquier otro, sea anterior o posterior.

«X _
ooo

z l l



y Ilustración 13 Lista doblemente cncadenada
Lista multienlazada. Igual que la doblemente encadenada, cada nodo tiene dos
campos de enlaces, pero, en lugar de usarlos para apuntarse mutuamente un sucesor y su

y i predecesor, se utilizan para encadenar la lista en dos ordenes distintos —en el ejemplo, los

99



nodos están encadenados en orden númerico por el segundo enlace, y en orden de
codiﬁcación de carácteres por el primem. Los dos punteros de acceso, que ahora si son
necesarios, apuntan al primer nodo en cada orden —se puede considerar que lo que tenemos
son dos listas simplemente encadenadas que comparten los campos de ínfonnación. También
se podría pensar que una lista doblemente encadenada es una lista multíenlazada, en la que el

segundo orden es el inverso del primero.

, , ,V ,
>l . > 25 - ——>112l >400
' A

Ilustración 24 Lísla multienlazada

Se puede continuar introduciendo toda clase de variaciones, tales como listas
circulares doblemente encadenadas, listas multienlazadas doblemente encadenadas. listas
circulares con punteros a la cabeza, etc. Además. se pueden emplear los campos de
encadenamiento de otras fonnas, dando lugar a estructuras no lineales que pueden alcanzar

altos grados de complejidad, aunque ello escapa a nuestro interés en este momento.





Introducción a los métodos formales de especiﬁcación.

Concepto y propiedades.

El diccionario de la Real Academia Española deﬁne especiﬁcar como: "Fijar o
detenninar de modo preciso". Sabemos que es exactamente eso lo que hay que hacer con
cualquier problema para el que se quiera formular un algoritmo: explicar con claridad todos
los aspectos relevantes del mismo. La especiﬁcación del problema es un paso previo a la
implementación del algoritmo: debe describir qué es lo que se espera que el algoritmo haga,
pero no es su función describir cómo debe hacerlo —la separación entre el que’ y el cáma es
una de las reglas de oro de la buena programación.

La especiﬁcación persigue dos objetivos complementarios: (l) al implementador le
sirve para saber cómo debe de comportarse la aplicación que implementa y le permite buscar
la mejor manera de conseguirlo, (2) al usuario —ﬁnal o implementador de una aplicación que
usa un módulo especiﬁcado— le sirve para saber cómo debe usar la aplicación o módulo en
cuestión —que' información debe proporcionarle y cómo, y que’ infon-nación recibirá a

cambio.

La especiﬁcación y el ciclo de vida del software.

Un programa siempre —aunque se percibe más cuando es complejo— pasa por una
serie de etapas en su desarrollo: análisis de requerimientos, diseño, implementación y
validación y/o veriﬁcación. En la etapa de análisis de requerimientos la especiﬁcación capta
los elementos del problema, centra lu ideas que pudieran estar difusas y perﬁla los detalles
que determinarán la correcta implementación de la aplicación a desarrollar. Por ejemplo, ante
el enunciado ”se tiene un vector ordenada de enteros y se desea desarrollar un
procedimiento para insertar un valor de jbnna que se mantenga el arden entre las
elementos" surgen inmediatamente varias dudas que son fundamentales para saber qué es lo
que se quiere realizar: ¿Cuál es el tamaño máximo del vector? ¿puede haber elementos
repetidos? ¿ordenado signiﬁca en orden creciente]. Sólo cuando todas las preguntas hayan
sido resueltas tendremos un conocimiento preciso de lo que hay que hacer.

En la etapa de diseño se estudia cómo implementar el algoritmo más adecuado; se

divide el problema en subproblemas que se estudian por separado y generalmente se
l0l

desarrollan módulos independientes para resolverlos. Hay que especiﬁcar la ﬁmción de cada
subproblema y su relación con el conjunto prestando especial atención a la deﬁnición de las
interfaces de los módulos a desarrollar para cada uno. La correcta especiﬁcación de esta etapa
permite la implementación y prueba separada de cada módulo y su integración posterior sin
problemas para conformar la solución ﬁnal‘

Tras la implementación se puede usar la especiﬁcación en la etapa de
validación/veriﬁcación para deﬁnir casos de pmeba o para veriﬁcar formalmente el
funcionamiento de los algoritmos desarrollados.

Finalmente, la especiﬁcación interviene en la documentación del programa, tanto
intema —eomentarios insertados en el códígo- como extema —manuales de referencia y
uso—; esta ﬁmción sirve tanto para informar al usuario ﬁnal como para ayudar en la fase de
mantenimiento del programa posterior a su entrega y facilitar la realización de las revisiones

que fuesen necesarias.

Propiedades de la especiﬁcación.
Una especiﬁcación ha de ser:
(l) consistente, manteniendo coherencia lógica sin incurrir en contradicciones.
(2) completa, describiendo todos los aspectos del problema,
(3) precisa, describiendo los detalles con exactitud y

(4) realizable, pudiéndose implementar de forma práctica.

La especiﬁcación como contrato: precondiciones y postcondiciones.

Si está bien fonnulada, en la especiﬁcación de un problema se pueden identiﬁcar dos
partes: (l) la descripción de cómo deben ser —que’ condiciones deben cumplir— los datos
que se suministrarán al algoritmo para su proceso y (2) la descripción de las condiciones que
deben cumplir los resultados elaborados por el algoritmo para poder ser considerados una
solución válida al problema. Como lo primero especiﬁca las condiciones que deben cumplir
los datos antes (üviamente) de que el algoritmo los procese, recibe el nombre de
precondicíoner; asimismo lo segundo recibe el nombre de postcandicianex porque especiﬁca
las condiciones que debe cumplir la solución después (pLteriormente) de que el algoritmo la

ha elaborado. Por ejemplo, si vamos a calcular la raíz cuadrada de un número real con una

l02

determinada aproximación, el número en cuestión deberá ser positivo o no podremos intentar
el calculo —precondición—— y la solución no es cualquier número real, pero si cualquiera que
esté dentro del margen de aproximación especiﬁcado —postcnndición.

El par precondíciones/postcondiciones viene a constituir una especie de contrato que
compromete el correcto funcionamiento del algoritmo desarrollado, subordinado a que se le
proporcionen datos con las características adecuadas. Eventualmente se pueden incorporar a
ese contrato restricciones que obliguen a que la solución adoptada cumpla determinados
requisitos de implementación tales como la limitación en el uso de los recursos del

ordenador.

Lenguaje de especiﬁcación formal.

Una de las propiedades fundamentales de cualquier especiﬁcación debe ser la
precisión y claridad de su enunciado; desgraciadamente esta no es una caracteristica
dominante en el lenguaje natural. Por ello es conveniente fonnalizar las especiﬁcaciones
utilizando un lenguaje controlado; ejemplos típicos son las especiﬁcaciones pre/post de
algoritmos usando lógica de predicador‘ o las especiﬁcaciones algebraicas de Tipo:
Abstractas de Datos.

Cuando se usan predicados para especiﬁcar problemas diremos que un predicado
deﬁne —especiﬁca— aquellos estados que lo satisfacen; los predicados contradictorios no
sirven para especiﬁcar nada y las tautologías no marcan ninguna condición —si se pone una
tautologia como precondición el algoritmo deberá funcionar bajo cualquier circunstancia, y si
se pone como postcondición será correcto haga lo que haga. Las variables libres de los
predicados usados en una especiﬁcación designan información que se reﬂejará en variables
del algoritmo mientras que las. ligadas juegan un papel puramente operacional en la
deﬁnicion de los predícados, por esta razón algunos autores proponen el uso de letras griegas
para simbolizar las variables ligadas ya que las letras griegas no se pueden usar como
nombres de variables en los lenguajes de programación más extendidos y de esta manera se

ayuda a clariﬁcar las especiﬁcaciones.

5 Ver apéndice ‘Introducción a la lógica de prédicados‘
¡O3

Especiﬁcación pre/post usando lógica de predicados.

La especiﬁcación formal de un algoritmo está formada por tres elementos: (l) la
interfaz —cabecera y descripción de parámetros- del algoritmo, (2) la precondición ——un

predicado cuyas únicas variables libres son los parámetros de entrada o de entrada/salida del



algoritmo— y (3) la postcondi ón —un predicado cuyas únicas variables libres son los
parámetros de cualquier clase del algoritmo. El siguiente ejemplo muestra la especiﬁcación
fonnal de un procedimiento llamado RaizCuadrada con dos parámetros reales —x,y— que
debe calcular la raiz cuadrada de x para devolvcrla en y.

procedimiento Raízcuadrada (x,y)
variables entrada real x
salida real y

(pre :(x 2 0))
(posnty 2 o) /\ (abs(y'y - x) s 0,00009}

Si lo que se quiere especiﬁcar es una ﬁmción usaremos su nombre y parámetros para

designar el valor resultante de la ejecución de la función.

función real llaízCuadradahc)
variables entrada real x

(pre zlx > 0))
(post: Raízcuadradalx) = y /(y 2 0) /\ (abs(y‘y - x) s 0,00009)

Si el algoritmo no es un procedimiento ni una función no tendrá parametros, pero
seguramente tendrá que interaccionar con el usuario a través de los dispositivos de
entrada/salida —los procedimientos y funciones también pueden hacerlo si es necesario.

Reservaremos las palabras ENTRADA y SALIDA para designar los respectivos ﬂujos de datos

desde la entrada y hacia la salida estándar.

algoritmo Raízcuadrada
(pre : ENTRADA : x / (x 5 real) /\ (x 2 0))
(post: suma = y / (y e real) A (y 2 o) A labsly’)! e x) s 0430005))

Si la estructura de los datos de entrada o salida es compleja se puede recurrir a
mecanismos de descripción más elaborados; los mismos mecanismos se pueden utilizar para
describir la entrada/salida desde ﬁcheros. En cualquier caso, este tipo de descripción entiende
la entrada/salida como ﬂujos secuencíales de datos —no se aborda, por ejemplo, la
especiﬁcación de una interfaz gráﬁca de usuario —es un problema de diseño gráﬁco más que
de especiﬁcación de algoritmos.

Una cuestión importante es cómo expresar la modiﬁcación que sufren los parámetros
de entrada/salida de los subprogramas. Supongamos que queremos desarrollar un

104

procedimiento para intercambiar el valor de dos variables enteras, A y B. No se necesita
ninguna precondición especial aparte de que sean de tipo entero, pero ¿cómo podemos
expresar la postcondición de que al ﬁnal sus valores hayan sido intercambiados. es decir, que

A tenga el valor inicial de B y B tenga el valor inicial de A?

pzocadhniento Intercambía (A, a)
variables entrada/salida enteras A, e
(pre ; ninguna)

(post: (A = a) /\ u: = m)

Evidentemente la postcondición anterior es incorrecta; lo que expresa es que al
ﬁnalizar la ejecución del procedimiento A y B son iguales. Se necesita algún mecanismo para

distinguir el estado de una variable después de la ejecución con respecto al que tenía antes.

Usaremos un apóstrofe (') para hacer dicha distinción.

procedimiento Intercambia (A, B)
variables entrada/salida enteras A, a
(pre ; ninguna)

(post: (A' = B) /\ 03' = m)

Con la convención establecida la poscondición dice que A después de la ejecución
(A') debera tener el valor que tenia B antes de la ejecución (B), y que B después de la
ejecución (B) deberá tener el valor que tenía A antes de la ejecución (A). Para mantener una
cierta ortogonalidad en las expresiones es adecuado incluir en esta convención los parámetros
de sólo salida —aunque su valor "antes" sea irrelevante, estaríamos expresando que todo lo
que tenga apóstrofe ha sido modiﬁcado por el algortimo. En este caso la especiﬁcación del

procedimiento RaízCuadrada debe modiﬁcarse tal como se reﬂeja a continuación.

procedimiento RaizCuadrada (x, y)
variable: entrada rea]. x
salida real y

(pre :(x 2 0))
(post:(y' z o) /\ (abs(y'*y' - x) s o,oooo5))

En caso de que una especiﬁcación resulte muy compleja, se puede descomponer
deﬁniendo funciones auxiliares de una forma similar a como se hace en el diseño descendente
de programas. Las funciones de especiﬁcación tienen como objetivo simpliﬁcar la expresión
de los predicados pre/post —no deﬁnen subprogramas que tengan que ser implementados. En
el siguiente ejemplo se especiﬁca un procedimiento para insertar sin repetición un elemento

en un vector ordenado; la especiﬁcación tiene que expresar que el vector ha de estar ordenado

l05



antes de la inserción y debe seguir ordenado después, y que se añade sólo si no está ya en el

vector.
procedimiento InserCar1V,N,E)
variable entrada/salida entero vtloo] [Vector ordenado de enteros.
natural N [Número de elementos en V.
entrada entero E {Elemento a insertar en V.
(sea:
ordenadoívía b]; s «¡voce e aHbtAm < B):(V[0(] < vmn)
Está(V[a..b],E s (3a e a..b / vw] t 3))
(pre : (N s o..99) /\ tordenadotvlLdm)
(post:

(no Está(V[1..Nl,E)) -°
(mv = N + 1) /\ (Drdenado(\l‘[1..N']) /\ (zscátvunum) /\
(Ver E IIIN): (Está(V',N',V[a])
Esr.á(V,N,E) — tw = N) A (v' = v))

Obsérvese que la función Ordenado no sólo eaablece cuándo un vector está ordenado
de menor a mayor, sino que además exige que no haya elementos repetidos —al usar < en
vez de s. La precondición especiﬁca que el vector a la entrada debe estar ordenado —según
las condiciones de la función 0rdenad0— y que debe existir espacio para la inserción —N
menor que el número máximo de elementos del vector—, pero no exige que el elemento a
insertar no este’ ya en el vector. La poslrcondición se halla dividida en dos panes dependiendo
de si el elemento a insertar estaba o no en el vector de entrada. Si estaba no se modiﬁca nada.
mientras que si no estaba debe estar, y también todos los demás elementos que si estaban.

La utilización de las funciones auxiliares con nombres signiﬁcativos —0rderu1da,
Está- pennite que los predicados pre/post sean mucho más simples de entender en primera

instancia —aunque luego haya que recurrir a la cláusula sea para ver los detalles.

Ejemplos de especificaciones.

Se presentan en este apartado las especiﬁcaciones fonnales de algunos de los
algoritmos mostrados en los capítulos anteriores acompañadas de su explicación en lenguaje

natural.

función real Máximo(V,N)
variables entrada natural N
real viso]
(pre: N s 1..5o}
(post: Máximo = m /((3o« e 1..N / vta] = m) /\ (vs s 1..N: V[B] s mH)

l06

Explicación: Una función real llamada máximo que toma un vector de reales con rango de
indice 1.50 y un número natural comprendido entre l y 50, y devuelve un valor del subvector

V[ l ..N] que es mayor o igual que cualquier otro valor de ese subvector.

función lógica Primo (p)

variables entrada natural p

(pre: ninguna)

(post: Primo (p) 2 ((\1y e Nalural)/\(y n 1)A(y s p): (p mod y e 0)) )

Explicación: Dado un número natural, p, la ﬁmción lógica Primo(p) devuelve verdadero si no

existe ningún número natural distinto de l y de p que sea divisor de p.

procedimiento Ordenselección (V, N)

variables
entrada entero N (m de elementos del Vector)
entrada/salida entera v[5o] (Vector a ordenar)

(sea:
(Ordenado(V[a..b])) s (VB e a..b)/\(\1u s a..B):(V[ot] s vlﬁll)

(Frecuencia (V[a. .b] ,E) E
Il o Frecuencia(V[a+1. .b] ,E) Si VIa] : E
|u o Frecuencia(V[a+1..b],E) si V[a] s E

(pre: u g 5o)
(post: Ordenadclv‘ [1. .111) /\

(vu e 1. .N: FreCuenCia(V[1..NI,V[u]) Frecuenciaw‘ [1. .N] ,V[a] ))

Explicación: dado un vector de elementos enteros con rango de índice l..50, V, y una
variable natural, N, menor o igual que 50, el procedimiento Ordenselección reorganiza los N
primeros elementos del vector de forma que quedan ordenados entre si de menor a mayor.
Los elementos del vector después de ordenar son los mismos que antes de ordenar y con el

mismo número de apariciones.

procedimianto Mezcla(V1,V2,V3,N1,N2)
variables
entrada enteras V1[50] , V2[50] , N1, N2
salida entera V3 [100]
(sea:
(0rdenado(V[a. .b] l) í (VB E a. .b)/\(Vu s a.-B) z (Vlotl s VHS] ))
(Frecuenciatvla, .b] ,13) 2
11 + Frecuencia(V[a+1..b],E) si V[a]

E
IO + Frecuencia(V[a+1. .b] ,13) si V[a] E

«¡a

(pre: (N1 s 50)/\(N2 s 50)/\
(ordenadow1 n, .N1] J )/\(0rdenado(V2 [1 . .112] ) ))
(pose:
(0tdenado(V3' [1..N1+n21)) /\
¿(va e 1. .111; Frecuencialvav [1. 311m2] ,v1[u]) =
Frecuenciawl [1. .N1] ,V1[or] )+Frecuencia(V2 [1. .N2] ,Vl[o1] ))
(Ver e 1. .N2: Frecuenciawj‘ [1..N1+N2] ,V2[u]) =
Frecuencia(v1[1..N1],V2[o<1)+1=recuencia(v2[1..N2],v2[u]))

l07

Explicación: dados dos vectores ordenados se genera un tercero también ordenado que

Contiene todos los elementos de ambos vectores.

procedimiento InsertarBnOrden (L, V)
variables entrada/salida PLista L
entrada Tipovalcr v
(sea:
OrdenadolL) E (L : NULO) V (Lásíguiente = NULO) V
(Knaïnro s LﬁSiguiente/dnfo) A
(Ordenado (Lasignience-unto) t)
Frecuencíallqlï) E
lo si (L : NULO)
¡o + Frecuencia(Lasiguieneej) si (L r NULO) A l(L >Info v E)
Il + Frecuencia(Lesiguientej) si (L a‘ NULO) /\ (Leﬂnfo = E)

l

(pre: ordenadom)
(post: Ordenadom‘) /\ (Frecuenciamhv) : Frecuencia(L,v) + 1) /\
Va e Tipovalor: Fzecuenciamua) : Frecuenciaﬂuu)
l

Explicación: Dada una lista ordenada y un valor. se modiﬁca la lista de manera que el valor
aparece en la misma una vez más de las que aparecia, el resto de la los elementos de la lista

permanecen igual y la lista sigue ordenada.

Cumplimiento de las especiﬁcaciones: Corrección, robustez y amigabilidad.

La especiﬁcación entendida como un eontmto delimita las responsabilidades del
ímplementador y el usuario; este no está obligado a dar más que lo ﬁjado en las
preeondíciones pero aquel sólo queda obligado a que el programa funcione correctamente
cuando se ejecuta en las condiciones estipuladas. y no tiene ninguna obligación cuando las

precondiciones se incumplen. Por ejemplo. dada la especiﬁcación:

procedimiento Raízcuadrada (x, y)
variables entrada real x
salida real y
(pre :(x 2 0))
(post:(y' 2 o) A (abs(y'*y' — x) s o,oooo5))

El siguiente algoritmo es correcta:

procedimianto Raízcuadrada (x,y)

variables entrada real x
salida real y
local real z

[08

mientras abSÜt r Z) >= 0.00005 hace:
31* ((x/yl +y) /2
z " Y ' Y
fin mientras
retornar
fin procedimiento

El problema es que, aunque la precundicrón establece que x debe ser mayor o igual
que cero, dado que es una variable de tipo real el usuario podría pasar un valor negativo. Al
no cumplirse la precondición el diseñador del algortimo puede optar por cualquier opción
desde dejar que el algoritmo pueda abonar hasta que no acabe nunca ——como ocurre en este
caso. Puede elegir modiﬁcar el algoritmo de forma que ante un incumplimiento de la

preoondición se minimicen los posibles efectos indeseados:

procedinianto Raizcuadrada (x, y)
variables entrada real x
salida real y
locsl real z
si x 2 0 entoncas
y * x / 2
z " Y * Y
mientras abs(x v z) >= 0.00005 hacer
Y‘*((X/Y) +Y)/2
z e Y * Y
ﬁn mientras
ﬁin si
retorna:
un procedimiento

Tenemos ahora un algoritmo más robusta: los errores del usuario no le penurbzrn, no
abona ni entra en un ciclo inﬁnito, sino que siempre acaba, aunque si los datos de entrada son
erróneos el resultado que entrega es igualmente erróneo. Lo único criticable es que no
muestra demasiada consideración hacia el usuario —que tampoco la ha tenido——; sería más
amigable que se indicase de alguna manera que el resultado no es correcto para dar la
oportunidad al usuario de hacer alguna comprobación a posteriori —aunque si ha sido tan

descuidado como para no respetar la precondición es poco probable que las haga.

procadimianto RaizCuadrada (x, y)
variables antrads real x
salida real y
locsl real z
si x 2 0 entonces
y ‘r x / 2
z e Y ' Y
mientras abslx - z) >: 0.00005 hace:
ye (tx/y) +y) /2
z e Y * Y
Ein mientras

[09

ai no
Y ‘ "1
un si
IGCOIHSZ‘
ﬁn procedimiento

En la última versión del algoritmo se ha optado por indicar el error asignando -l al
parámetro de salida. Se ha podido tomar esta decisión porque el rango de valores válidos de y
como solución de la raíz cuadrada no cubre el rango de valores de su tipo Ay tiene que ser
mayor o igual que cero y quedan los negativos para asignar códigos de error. Si no hay
valores inválidos que se puedan usar como códigos de error y no se quiere o no se puede
modiﬁcar la interfaz, se puede recurrir a los mecanismos de resolución de excepciones que
ofrezcan los lenguajes a los que el algoritmo vaya a traducirse.

Cara al usuario ﬁnal la amigabilidad de un programa implica que le proporcione
ayuda, le informe de las causas de los errores que se produzcan y le de la oportunidad de

corregirlos y continuar la ejecución.

Apéndice: Introducción ala lógica de predicados.

Deﬁnición.

Un predicado es una aﬁrmación; por ejemplo "x es mayor que cero", que formalmente
se expresa como: x > 0. Un predicado elemental —re'rmino— puede ser: una variable lógica,
una constante lógica, una función lógica —en este contexto una función lógica es un
predicado formado por un nombre y una lista de argumentos entre paréntesis, como Par(x) o
Primo(x)— o una expresión relacional. Un predicado no elemental se puede formar como la
negación de un predicado (mP), la disyunción de dos predicados (P V Q) o la conjunción de
dos predicados (P A Q) —en deﬁnitiva, una expresión lógica. También se forma un predicado
relacionando otros dos mediante una implicación (—». leido si  entonces ...) o un
bicondicional (n, leido  si y solo si ...).

Dado un predicado, denominaremos estado a cualquier posible asociación de valores
a sus variables. Se dice que un estado satisface un predicado si el predicado es verdadero para
ese estado. Un predicado es sarísfacible si existe al menos un estado que lo satisface. El

conjunto de estados para los que un predicado se satisface constituye su dominio de verdad.

lll]

Un predicado no satisfacible es una contradicción. uno que se satisface siempre es una
raulalagia. Decimos que un predicado, P, es mas fuerte que otro, Q, si el conjunto de estados
deﬁnidos por P es un subconjunto propio“ del conjunto de estados deﬁnidos por Q. Un
predicado se debilita al añadir disyunciones y se fonalece al añadir conjunciones.
(x>0)V(x=0):(x>0):(x>0)/\Par(x)

Equivalencia.

Dos predieados, P y Q, son equivalentes —simbolizado P e Qv si siempre que uno es
verdadero el otro es verdadero y siempre que uno es falso el otro es falso —se satisfacen
exactamente en los mismos estados. Decir que dos predicado, P y Q, son equivalentes es lo

mismo que decir P - Q. La equivalencia sigue las siguientes leyes:

Leyes de la equivalencia

Identidad: P s P

Negación: 1*?) z P

Exclusión del termino medio: P V "P 2 verdadero

Contradicción: P /\ “P s falso
Ccnmutativa: P V Q z Q V P
P /\ Q s Q A P
Distributiva: P A (Q v R) z (P A Q ) V (P A R)

PV(Q/\R)E(P vomawk)

Asociativa; ¡wo/ima (PAQ)/\R
Pv(QvR)s(PvQ)vR

Simpliﬁcación de la P V P z P
disyunción: P V verdadero s verdadero

Pvfalsoal’
PV(PAQ)sP

" Un conjunto, A, es un subconjunto propia de otro, B, si todos los elementos de A son elementos de
B pero existe algún elemento de B que no es elemento de A.
l l l

Leyes ¡‘le la equivalencia

Simpliﬁcación de la P /\ P z P
conjunción: P /\ verdadero 2 l’
P /\ falso 2 falso
P /\ (P v Q) s P
Leyes de De Morgan: 1P V Q) 2 '*P A ﬁQ
‘(P /\ Q) í ‘l’ V ﬁQ
Ley de la implicación P =- Q s ‘P V Q
Ley del bicondicional P - Q E (P -= Q) /\ (Q — P)

Usaremos el símbolo z para deﬁnir un predicado mediante una equivalencia, por
ejemplo. la siguiente expresión: "Par(x)í(x mod2:0)". deﬁne el predicado Par(x)

estableciendo su equivalencia con (x mod 2 = 0).

Cuuutiﬁcadores.

Al enunciar un predicado es necesario exponer cuál es su dominio de verdad. esto
suele implicar frases del estilo de: "el predicado se cumple gara todos los valores de x que ..."
o "existe atgún (algunos) valor de x que cumple  y satisface el predicado". Para formalizar
esta clase de expresiones existen el cuantiﬁcador universal (V, leído "para todo...") y el
cuantiﬁcador existencial (E, leído "existe algún..."). Junto con los cuantiﬁcadores usaremos
los símbolos "/" (tal que ...) y "z" (se veriﬁca. se cumple que ...), además de los propios del
álgebra de conjuntos —un dominió es un conjunto de estados.

Primo(x) a ((Vy s Natural)/\(y ; l)/\(y c x): (x mod y s 0))

Se deﬁne que x es primo si gara todo y natural distinto de l y de x se
veriﬁca que x no es dívísible por y.
(Ex c Natural) / *PrÍmo(x)

Se aﬁrma que existe algún número natural que no es primo.

Las variables que en un predicado aparezcan afectadas por un cuantiﬁcador se
denominan variables ligadax —al cuan\iﬁcador—, el resto se denominan variables libres. En

|l2

los ejemplos anteriores x es libre en el primer predicado pero ligada en el segundo e y es
ligada en el primero.

Si un predicado está afectado por una cuantiﬁcación universal y el dominio de valores
de la variable ligada al cuantiﬁcador resulta ser el conjunto vacío, el predicado se considerará
verdadero —"Para todos los elementos de C se cumple P" es equivalente a "No hay ningún
elemento de C para el que no se cumpla P"; si C es el conjunto vacio lo segundo se cumple, y
en consecuencia también lo primero. De forma similar. si un predicado está afectado por una
cuantiﬁcación existencial y el dominio de valores de la variable ligada al cuantiﬁcador resulta
ser el conjunto vacio, se entenderá que el predicado es falso. En los siguientes predicado: el
dominio de valores de x se expresa como un rango —cosa frecuente— que es vacío si N < l:

(VX e 1>IN:V[X]> 0)

(sx e l..N/ V[x] > 0)

Vistos en detalle, los cuanliﬁcadores universal y existencial no son más que la
acumulación de las operaciones de conjunción y disyunción:
(vx s LN: V[x] > 0) 2 (V[l] > 0) /\ (V[2] > 0) A  A (V[N] > O)
(Ex e1..N/V[x]> o)2 (v[1] > o) v (V[2] > o) v  v (vm > o)

En matemáticas estamos acostumbrados a otros simbolos que expresan la

acumulación de una operación: el producto (H) y el sumatorio (D. Estos cuanliﬁcadores

pueden también resultar útiles en la construcción de predicados.

ll}
